<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Cudafy.NET</name>
  </assembly>
  <members>
    <member name="T:Cloo.Bindings.CL10">
      <summary>
            Contains bindings to the OpenCL 1.0 functions.
            </summary>
      <remarks> See the OpenCL specification for documentation regarding these functions. </remarks>
    </member>
    <member name="F:Cloo.Bindings.CL10.libName">
      <summary>
            The name of the library that contains the available OpenCL function points.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetPlatformIDs(System.Int32,Cloo.Bindings.CLPlatformHandle[],System.Int32@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetPlatformInfo(Cloo.Bindings.CLPlatformHandle,Cloo.ComputePlatformInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetDeviceIDs(Cloo.Bindings.CLPlatformHandle,Cloo.ComputeDeviceTypes,System.Int32,Cloo.Bindings.CLDeviceHandle[],System.Int32@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetDeviceInfo(Cloo.Bindings.CLDeviceHandle,Cloo.ComputeDeviceInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateContext(System.IntPtr[],System.Int32,Cloo.Bindings.CLDeviceHandle[],Cloo.Bindings.ComputeContextNotifier,System.IntPtr,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateContextFromType(System.IntPtr[],Cloo.ComputeDeviceTypes,Cloo.Bindings.ComputeContextNotifier,System.IntPtr,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainContext(Cloo.Bindings.CLContextHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseContext(Cloo.Bindings.CLContextHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetContextInfo(Cloo.Bindings.CLContextHandle,Cloo.ComputeContextInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateCommandQueue(Cloo.Bindings.CLContextHandle,Cloo.Bindings.CLDeviceHandle,Cloo.ComputeCommandQueueFlags,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainCommandQueue(Cloo.Bindings.CLCommandQueueHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseCommandQueue(Cloo.Bindings.CLCommandQueueHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetCommandQueueInfo(Cloo.Bindings.CLCommandQueueHandle,Cloo.ComputeCommandQueueInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.SetCommandQueueProperty(Cloo.Bindings.CLCommandQueueHandle,Cloo.ComputeCommandQueueFlags,System.Boolean,Cloo.ComputeCommandQueueFlags@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateBuffer(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,System.IntPtr,System.IntPtr,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateImage2D(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,Cloo.ComputeImageFormat@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateImage3D(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,Cloo.ComputeImageFormat@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainMemObject(Cloo.Bindings.CLMemoryHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseMemObject(Cloo.Bindings.CLMemoryHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetSupportedImageFormats(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,Cloo.ComputeMemoryType,System.Int32,Cloo.ComputeImageFormat[],System.Int32@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetMemObjectInfo(Cloo.Bindings.CLMemoryHandle,Cloo.ComputeMemoryInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetImageInfo(Cloo.Bindings.CLMemoryHandle,Cloo.ComputeImageInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateSampler(Cloo.Bindings.CLContextHandle,System.Boolean,Cloo.ComputeImageAddressing,Cloo.ComputeImageFiltering,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainSampler(Cloo.Bindings.CLSamplerHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseSampler(Cloo.Bindings.CLSamplerHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetSamplerInfo(Cloo.Bindings.CLSamplerHandle,Cloo.ComputeSamplerInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateProgramWithSource(Cloo.Bindings.CLContextHandle,System.Int32,System.String[],System.IntPtr[],Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateProgramWithBinary(Cloo.Bindings.CLContextHandle,System.Int32,Cloo.Bindings.CLDeviceHandle[],System.IntPtr[],System.IntPtr[],System.Int32[],Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainProgram(Cloo.Bindings.CLProgramHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseProgram(Cloo.Bindings.CLProgramHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.BuildProgram(Cloo.Bindings.CLProgramHandle,System.Int32,Cloo.Bindings.CLDeviceHandle[],System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.UnloadCompiler">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetProgramInfo(Cloo.Bindings.CLProgramHandle,Cloo.ComputeProgramInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetProgramBuildInfo(Cloo.Bindings.CLProgramHandle,Cloo.Bindings.CLDeviceHandle,Cloo.ComputeProgramBuildInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateKernel(Cloo.Bindings.CLProgramHandle,System.String,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateKernelsInProgram(Cloo.Bindings.CLProgramHandle,System.Int32,Cloo.Bindings.CLKernelHandle[],System.Int32@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainKernel(Cloo.Bindings.CLKernelHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseKernel(Cloo.Bindings.CLKernelHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.SetKernelArg(Cloo.Bindings.CLKernelHandle,System.Int32,System.IntPtr,System.IntPtr)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetKernelInfo(Cloo.Bindings.CLKernelHandle,Cloo.ComputeKernelInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetKernelWorkGroupInfo(Cloo.Bindings.CLKernelHandle,Cloo.Bindings.CLDeviceHandle,Cloo.ComputeKernelWorkGroupInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.WaitForEvents(System.Int32,Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetEventInfo(Cloo.Bindings.CLEventHandle,Cloo.ComputeEventInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.RetainEvent(Cloo.Bindings.CLEventHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.ReleaseEvent(Cloo.Bindings.CLEventHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetEventProfilingInfo(Cloo.Bindings.CLEventHandle,Cloo.ComputeCommandProfilingInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.Flush(Cloo.Bindings.CLCommandQueueHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.Finish(Cloo.Bindings.CLCommandQueueHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueReadBuffer(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueWriteBuffer(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueCopyBuffer(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,Cloo.Bindings.CLMemoryHandle,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueReadImage(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueWriteImage(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueCopyImage(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,Cloo.Bindings.CLMemoryHandle,Cloo.SysIntX3@,Cloo.SysIntX3@,Cloo.SysIntX3@,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueCopyImageToBuffer(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,Cloo.Bindings.CLMemoryHandle,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueCopyBufferToImage(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,Cloo.Bindings.CLMemoryHandle,System.IntPtr,Cloo.SysIntX3@,Cloo.SysIntX3@,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueMapBuffer(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,Cloo.ComputeMemoryMappingFlags,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[],Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueMapImage(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,Cloo.ComputeMemoryMappingFlags,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr@,System.IntPtr@,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[],Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueUnmapMemObject(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueNDRangeKernel(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLKernelHandle,System.Int32,System.IntPtr[],System.IntPtr[],System.IntPtr[],System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueTask(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLKernelHandle,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueMarker(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLEventHandle@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueWaitForEvents(Cloo.Bindings.CLCommandQueueHandle,System.Int32,Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueBarrier(Cloo.Bindings.CLCommandQueueHandle)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetExtensionFunctionAddress(System.String)">
      <summary>
            Gets the extension function address for the given function name,
            or NULL if a valid function can not be found. The client must
            check to make sure the address is not NULL, before using or 
            calling the returned function address.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateFromGLBuffer(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,System.Int32,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateFromGLTexture2D(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,System.Int32,System.Int32,System.Int32,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateFromGLTexture3D(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,System.Int32,System.Int32,System.Int32,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.CreateFromGLRenderbuffer(Cloo.Bindings.CLContextHandle,Cloo.ComputeMemoryFlags,System.Int32,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetGLObjectInfo(Cloo.Bindings.CLMemoryHandle,Cloo.ComputeGLObjectType@,System.Int32@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.GetGLTextureInfo(Cloo.Bindings.CLMemoryHandle,Cloo.ComputeGLTextureInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueAcquireGLObjects(Cloo.Bindings.CLCommandQueueHandle,System.Int32,Cloo.Bindings.CLMemoryHandle[],System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL10.EnqueueReleaseGLObjects(Cloo.Bindings.CLCommandQueueHandle,System.Int32,Cloo.Bindings.CLMemoryHandle[],System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.ComputeContextNotifier">
      <summary>
            A callback function that can be registered by the application to report information on errors that occur in the <see cref="T:Cloo.ComputeContext" />.
            </summary>
      <param name="errorInfo"> An error string. </param>
      <param name="clDataPtr"> A pointer to binary data that is returned by the OpenCL implementation that can be used to log additional information helpful in debugging the error.</param>
      <param name="clDataSize"> The size of the binary data that is returned by the OpenCL. </param>
      <param name="userDataPtr"> The pointer to the optional user data specified in <paramref name="userDataPtr" /> argument of <see cref="T:Cloo.ComputeContext" /> constructor. </param>
      <remarks> This callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe. </remarks>
    </member>
    <member name="T:Cloo.Bindings.ComputeProgramBuildNotifier">
      <summary>
            A callback function that can be registered by the application to report the <see cref="T:Cloo.ComputeProgram" /> build status.
            </summary>
      <param name="programHandle"> The handle of the <see cref="T:Cloo.ComputeProgram" /> being built. </param>
      <param name="notifyDataPtr"> The pointer to the optional user data specified in <paramref name="notifyDataPtr" /> argument of <see cref="M:Cloo.ComputeProgram.Build(System.Collections.Generic.ICollection{Cloo.ComputeDevice},System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)" />. </param>
      <remarks> This callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe. </remarks>
    </member>
    <member name="T:Cloo.Bindings.CL11">
      <summary>
            Contains bindings to the OpenCL 1.1 functions.
            </summary>
      <remarks> See the OpenCL specification for documentation regarding these functions. </remarks>
    </member>
    <member name="M:Cloo.Bindings.CL11.CreateSubBuffer(Cloo.Bindings.CLMemoryHandle,Cloo.ComputeMemoryFlags,Cloo.ComputeBufferCreateType,Cloo.SysIntX2@,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.SetMemObjectDestructorCallback(Cloo.Bindings.CLMemoryHandle,Cloo.Bindings.ComputeMemoryDestructorNotifer,System.IntPtr)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.CreateUserEvent(Cloo.Bindings.CLContextHandle,Cloo.ComputeErrorCode@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.SetUserEventStatus(Cloo.Bindings.CLEventHandle,System.Int32)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.SetEventCallback(Cloo.Bindings.CLEventHandle,System.Int32,Cloo.Bindings.ComputeEventCallback,System.IntPtr)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.EnqueueReadBufferRect(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,Cloo.SysIntX3@,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.EnqueueWriteBufferRect(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.Boolean,Cloo.SysIntX3@,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.EnqueueCopyBufferRect(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,Cloo.Bindings.CLMemoryHandle,Cloo.SysIntX3@,Cloo.SysIntX3@,Cloo.SysIntX3@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CL11.SetCommandQueueProperty(Cloo.Bindings.CLCommandQueueHandle,Cloo.ComputeCommandQueueFlags,System.Boolean,Cloo.ComputeCommandQueueFlags@)">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.ComputeMemoryDestructorNotifer">
      <summary>
            A callback function that can be registered by the application.
            </summary>
      <param name="memobj"> The memory object being deleted. When the user callback is called, this memory object is not longer valid. <paramref name="memobj" /> is only provided for reference purposes. </param>
      <param name="user_data"> A pointer to user supplied data. </param>
            /// <remarks> This callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe. </remarks></member>
    <member name="T:Cloo.Bindings.ComputeEventCallback">
      <summary>
            The event callback function that can be registered by the application.
            </summary>
      <param name="eventHandle"> The event object for which the callback function is invoked. </param>
      <param name="cmdExecStatusOrErr"> Represents the execution status of the command for which this callback function is invoked. If the callback is called as the result of the command associated with the event being abnormally terminated, an appropriate error code for the error that caused the termination will be passed to <paramref name="cmdExecStatusOrErr" /> instead. </param>
      <param name="userData"> A pointer to user supplied data. </param>
            /// <remarks> This callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe. </remarks></member>
    <member name="T:Cloo.Bindings.CLCommandQueueHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeCommandQueue" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLCommandQueueHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLCommandQueueHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLCommandQueueHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLContextHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeContext" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLContextHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLContextHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLContextHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLDeviceHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeDevice" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLDeviceHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLDeviceHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLDeviceHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLEventHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeEvent" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLEventHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLEventHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLEventHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLKernelHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeKernel" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLKernelHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLKernelHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLKernelHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLMemoryHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeMemory" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLMemoryHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLMemoryHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLMemoryHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLPlatformHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputePlatform" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLPlatformHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLPlatformHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLPlatformHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLProgramHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeProgram" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLProgramHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLProgramHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLProgramHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLSamplerHandle">
      <summary>
            Represents the <see cref="T:Cloo.ComputeSampler" /> ID.
            </summary>
    </member>
    <member name="M:Cloo.Bindings.CLSamplerHandle.Invalidate">
      <summary>
            Invalidates the handle.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLSamplerHandle.IsValid">
      <summary>
            Gets a logic value indicating whether the handle is valid.
            </summary>
    </member>
    <member name="P:Cloo.Bindings.CLSamplerHandle.Value">
      <summary>
            Gets the value of the handle.
            </summary>
    </member>
    <member name="T:Cloo.Bindings.CLx">
      <summary>
            Contains bindings to the OpenCL extension functions.
            </summary>
      <remarks> See the Khronos OpenCL API extensions registry for documentation regarding these functions. </remarks>
    </member>
    <member name="M:Cloo.Bindings.CLx.CreateSubDevicesEXT(System.IntPtr,Cloo.cl_device_partition_property_ext[],System.Int32,System.IntPtr[],System.Int32@)">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.Bindings.CLx.EnqueueMigrateMemObjectEXT(System.IntPtr,System.Int32,System.IntPtr[],Cloo.cl_mem_migration_flags_ext,System.Int32,System.IntPtr[],System.IntPtr[])">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.Bindings.CLx.GetGLContextInfoKHR(System.IntPtr[],Cloo.ComputeGLContextInfo,System.IntPtr,System.IntPtr,System.IntPtr@)">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.Bindings.CLx.ReleaseDeviceEXT(System.IntPtr)">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.Bindings.CLx.RetainDeviceEXT(System.IntPtr)">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.Bindings.CLx.#ctor(Cloo.ComputePlatform)">
      <summary>
      </summary>
      <param name="platform">
      </param>
    </member>
    <member name="T:Cloo.ComputeObject">
      <summary>
            Represents an OpenCL object.
            </summary>
      <remarks> An OpenCL object is an object that is identified by its handle in the OpenCL environment. </remarks>
    </member>
    <member name="T:Cloo.ComputeObject.GetInfoDelegate`2">
      <summary>
      </summary>
      <typeparam name="HandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <param name="objectHandle">
      </param>
      <param name="paramName">
      </param>
      <param name="paramValueSize">
      </param>
      <param name="paramValue">
      </param>
      <param name="paramValueSizeRet">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Cloo.ComputeObject.GetInfoDelegateEx`3">
      <summary>
      </summary>
      <typeparam name="MainHandleType">
      </typeparam>
      <typeparam name="SecondHandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <param name="mainObjectHandle">
      </param>
      <param name="secondaryObjectHandle">
      </param>
      <param name="paramName">
      </param>
      <param name="paramValueSize">
      </param>
      <param name="paramValue">
      </param>
      <param name="paramValueSizeRet">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.Equals(System.Object,System.Object)">
      <summary>
            Checks if two <c>object</c>s are equal. These <c>object</c>s must be cast from <see cref="T:Cloo.ComputeObject" />s.
            </summary>
      <param name="objA"> The first <c>object</c> to compare. </param>
      <param name="objB"> The second <c>object</c> to compare. </param>
      <returns>
        <c>true</c> if the <c>object</c>s are equal otherwise <c>false</c>. </returns>
    </member>
    <member name="M:Cloo.ComputeObject.Equals(System.Object)">
      <summary>
            Checks if the <see cref="T:Cloo.ComputeObject" /> is equal to a specified <see cref="T:Cloo.ComputeObject" /> cast to an <c>object</c>.
            </summary>
      <param name="obj"> The specified <c>object</c> to compare the <see cref="T:Cloo.ComputeObject" /> with. </param>
      <returns>
        <c>true</c> if the <see cref="T:Cloo.ComputeObject" /> is equal with <paramref name="obj" /> otherwise <c>false</c>. </returns>
    </member>
    <member name="M:Cloo.ComputeObject.Equals(Cloo.ComputeObject)">
      <summary>
            Checks if the <see cref="T:Cloo.ComputeObject" /> is equal to a specified <see cref="T:Cloo.ComputeObject" />.
            </summary>
      <param name="obj"> The specified <see cref="T:Cloo.ComputeObject" /> to compare the <see cref="T:Cloo.ComputeObject" /> with. </param>
      <returns>
        <c>true</c> if the <see cref="T:Cloo.ComputeObject" /> is equal with <paramref name="obj" /> otherwise <c>false</c>. </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetHashCode">
      <summary>
            Gets the hash code of the <see cref="T:Cloo.ComputeObject" />.
            </summary>
      <returns> The hash code of the <see cref="T:Cloo.ComputeObject" />. </returns>
    </member>
    <member name="M:Cloo.ComputeObject.ToString">
      <summary>
            Gets the string representation of the <see cref="T:Cloo.ComputeObject" />.
            </summary>
      <returns> The string representation of the <see cref="T:Cloo.ComputeObject" />. </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetArrayInfo``3(``0,``1,Cloo.ComputeObject.GetInfoDelegate{``0,``1})">
      <summary>
      </summary>
      <typeparam name="HandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <typeparam name="QueriedType">
      </typeparam>
      <param name="handle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetArrayInfo``4(``0,``1,``2,Cloo.ComputeObject.GetInfoDelegateEx{``0,``1,``2})">
      <summary>
      </summary>
      <typeparam name="MainHandleType">
      </typeparam>
      <typeparam name="SecondHandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <typeparam name="QueriedType">
      </typeparam>
      <param name="mainHandle">
      </param>
      <param name="secondHandle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetBoolInfo``2(``0,``1,Cloo.ComputeObject.GetInfoDelegate{``0,``1})">
      <summary>
      </summary>
      <typeparam name="HandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <param name="handle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetInfo``3(``0,``1,Cloo.ComputeObject.GetInfoDelegate{``0,``1})">
      <summary>
      </summary>
      <typeparam name="HandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <typeparam name="QueriedType">
      </typeparam>
      <param name="handle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetInfo``4(``0,``1,``2,Cloo.ComputeObject.GetInfoDelegateEx{``0,``1,``2})">
      <summary>
      </summary>
      <typeparam name="MainHandleType">
      </typeparam>
      <typeparam name="SecondHandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <typeparam name="QueriedType">
      </typeparam>
      <param name="mainHandle">
      </param>
      <param name="secondHandle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetStringInfo``2(``0,``1,Cloo.ComputeObject.GetInfoDelegate{``0,``1})">
      <summary>
      </summary>
      <typeparam name="HandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <param name="handle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.GetStringInfo``3(``0,``1,``2,Cloo.ComputeObject.GetInfoDelegateEx{``0,``1,``2})">
      <summary>
      </summary>
      <typeparam name="MainHandleType">
      </typeparam>
      <typeparam name="SecondHandleType">
      </typeparam>
      <typeparam name="InfoType">
      </typeparam>
      <param name="mainHandle">
      </param>
      <param name="secondHandle">
      </param>
      <param name="paramName">
      </param>
      <param name="getInfoDelegate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeObject.SetID(System.IntPtr)">
      <summary>
      </summary>
      <param name="id">
      </param>
    </member>
    <member name="T:Cloo.ComputeResource">
      <summary>
            Represents an OpenCL resource.
            </summary>
      <remarks> An OpenCL resource is an OpenCL object that can be created and deleted by the application. </remarks>
      <seealso cref="T:Cloo.ComputeObject" />
    </member>
    <member name="M:Cloo.ComputeResource.Dispose">
      <summary>
            Deletes the <see cref="T:Cloo.ComputeResource" /> and frees its accompanying OpenCL resources.
            </summary>
    </member>
    <member name="M:Cloo.ComputeResource.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="M:Cloo.ComputeResource.Finalize">
      <summary>
            Releases the associated OpenCL object.
            </summary>
    </member>
    <member name="T:Cloo.ComputeMemory">
      <summary>
            Represents an OpenCL memory object.
            </summary>
      <remarks> A memory object is a handle to a region of global memory. </remarks>
      <seealso cref="T:Cloo.ComputeBuffer`1" />
      <seealso cref="T:Cloo.ComputeImage" />
    </member>
    <member name="M:Cloo.ComputeMemory.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags)">
      <summary>
      </summary>
      <param name="context">
      </param>
      <param name="flags">
      </param>
    </member>
    <member name="M:Cloo.ComputeMemory.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeMemory.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeMemory" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeMemory.Context">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeMemory" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeMemory" />. </value>
    </member>
    <member name="P:Cloo.ComputeMemory.Flags">
      <summary>
            Gets the <see cref="T:Cloo.ComputeMemoryFlags" /> of the <see cref="T:Cloo.ComputeMemory" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeMemoryFlags" /> of the <see cref="T:Cloo.ComputeMemory" />. </value>
    </member>
    <member name="P:Cloo.ComputeMemory.Size">
      <summary>
            Gets or sets (protected) the size in bytes of the <see cref="T:Cloo.ComputeMemory" />.
            </summary>
      <value> The size in bytes of the <see cref="T:Cloo.ComputeMemory" />. </value>
    </member>
    <member name="T:Cloo.ComputeBufferBase`1">
      <summary>
            Represents the parent type to any Cloo buffer types.
            </summary>
      <typeparam name="T"> The type of the elements of the buffer. </typeparam>
    </member>
    <member name="M:Cloo.ComputeBufferBase`1.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags)">
      <summary>
      </summary>
      <param name="context">
      </param>
      <param name="flags">
      </param>
    </member>
    <member name="M:Cloo.ComputeBufferBase`1.Init">
      <summary>
      </summary>
    </member>
    <member name="P:Cloo.ComputeBufferBase`1.Count">
      <summary>
            Gets the number of elements in the <see cref="T:Cloo.ComputeBufferBase`1" />.
            </summary>
      <value> The number of elements in the <see cref="T:Cloo.ComputeBufferBase`1" />. </value>
    </member>
    <member name="T:Cloo.ComputeBuffer`1">
      <summary>
            Represents an OpenCL buffer.
            </summary>
      <typeparam name="T"> The type of the elements of the <see cref="T:Cloo.ComputeBuffer`1" />. <typeparamref name="T" /> is restricted to value types and <c>struct</c>s containing such types. </typeparam>
      <remarks> A memory object that stores a linear collection of bytes. Buffer objects are accessible using a pointer in a kernel executing on a device. </remarks>
      <seealso cref="T:Cloo.ComputeDevice" />
      <seealso cref="T:Cloo.ComputeKernel" />
      <seealso cref="T:Cloo.ComputeMemory" />
    </member>
    <member name="M:Cloo.ComputeBuffer`1.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,System.Int64)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeBuffer`1" />.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> used to create the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="flags"> A bit-field that is used to specify allocation and usage information about the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="count"> The number of elements of the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
    </member>
    <member name="M:Cloo.ComputeBuffer`1.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,System.Int64,System.IntPtr)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeBuffer`1" />.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> used to create the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="flags"> A bit-field that is used to specify allocation and usage information about the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="count"> The number of elements of the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="dataPtr"> A pointer to the data for the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
    </member>
    <member name="M:Cloo.ComputeBuffer`1.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,`0[])">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeBuffer`1" />.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> used to create the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="flags"> A bit-field that is used to specify allocation and usage information about the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="data"> The data for the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <remarks> Note, that <paramref name="data" /> cannot be an "immediate" parameter, i.e.: <c>new T[100]</c>, because it could be quickly collected by the GC causing Cloo to send and invalid reference to OpenCL. </remarks>
    </member>
    <member name="M:Cloo.ComputeBuffer`1.CreateFromGLBuffer``1(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,System.Int32)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeBuffer`1" /> from an existing OpenGL buffer object.
            </summary>
      <typeparam name="DataType"> The type of the elements of the <see cref="T:Cloo.ComputeBuffer`1" />. <typeparamref name="T" /> should match the type of the elements in the OpenGL buffer. </typeparam>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> with enabled CL/GL sharing. </param>
      <param name="flags"> A bit-field that is used to specify usage information about the <see cref="T:Cloo.ComputeBuffer`1" />. Only <see cref="F:Cloo.ComputeMemoryFlags.ReadOnly" />, <see cref="F:Cloo.ComputeMemoryFlags.WriteOnly" /> and <see cref="F:Cloo.ComputeMemoryFlags.ReadWrite" /> are allowed. </param>
      <param name="bufferId"> The OpenGL buffer object id to use for the creation of the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <returns> The created <see cref="T:Cloo.ComputeBuffer`1" />. </returns>
    </member>
    <member name="T:Cloo.ComputeCommandQueue">
      <summary>
            Represents an OpenCL command queue.
            </summary>
      <remarks> A command queue is an object that holds commands that will be executed on a specific device. The command queue is created on a specific device in a context. Commands to a command queue are queued in-order but may be executed in-order or out-of-order. </remarks>
      <seealso cref="T:Cloo.ComputeContext" />
      <seealso cref="T:Cloo.ComputeDevice" />
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBuffer``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source buffer to a destination buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBuffer``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},System.Int64,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source buffer to a destination buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBuffer``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},Cloo.SysIntX2,Cloo.SysIntX2,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source buffer to a destination buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBuffer``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source buffer to a destination buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBuffer``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},Cloo.SysIntX2,Cloo.SysIntX2,Cloo.SysIntX2,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source buffer to a destination buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="sourceRowPitch"> The size of a row of elements of <paramref name="source" /> in bytes. </param>
      <param name="destinationRowPitch"> The size of a row of elements of <paramref name="destination" /> in bytes. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBuffer``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source buffer to a destination buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="sourceRowPitch"> The size of a row of elements of <paramref name="source" /> in bytes. </param>
      <param name="destinationRowPitch"> The size of a row of elements of <paramref name="destination" /> in bytes. </param>
      <param name="sourceSlicePitch"> The size of a 2D slice of elements of <paramref name="source" /> in bytes. </param>
      <param name="destinationSlicePitch"> The size of a 2D slice of elements of <paramref name="destination" /> in bytes. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBufferToImage``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeImage,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a buffer to an image.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="source" />. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBufferToImage``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeImage2D,System.Int64,Cloo.SysIntX2,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a buffer to an image.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="source" />. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyBufferToImage``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeImage3D,System.Int64,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a buffer to an image.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="source" />. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImage(Cloo.ComputeImage,Cloo.ComputeImage,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source image to a destination image.
            </summary>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImage(Cloo.ComputeImage2D,Cloo.ComputeImage2D,Cloo.SysIntX2,Cloo.SysIntX2,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source image to a destination image.
            </summary>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImage(Cloo.ComputeImage2D,Cloo.ComputeImage3D,Cloo.SysIntX2,Cloo.SysIntX3,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source image to a destination image.
            </summary>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImage(Cloo.ComputeImage3D,Cloo.ComputeImage2D,Cloo.SysIntX3,Cloo.SysIntX2,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source image to a destination image.
            </summary>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImage(Cloo.ComputeImage3D,Cloo.ComputeImage3D,Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a source image to a destination image.
            </summary>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImageToBuffer``1(Cloo.ComputeImage,Cloo.ComputeBufferBase{``0},System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from an image to a buffer.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="destination" />. </typeparam>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImageToBuffer``1(Cloo.ComputeImage2D,Cloo.ComputeBufferBase{``0},Cloo.SysIntX2,System.Int64,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from an image to a buffer.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="destination" />. </typeparam>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.CopyImageToBuffer``1(Cloo.ComputeImage3D,Cloo.ComputeBufferBase{``0},Cloo.SysIntX3,System.Int64,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from a 3D image to a buffer.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="destination" />. </typeparam>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromBuffer``1(Cloo.ComputeBufferBase{``0},``0[]@,System.Boolean,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from a buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffer. </typeparam>
      <param name="source"> The buffer to read from. </param>
      <param name="destination"> The array to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromBuffer``1(Cloo.ComputeBufferBase{``0},``0[]@,System.Boolean,System.Int64,System.Int64,System.Int64,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from a buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffer. </typeparam>
      <param name="source"> The buffer to read from. </param>
      <param name="destination"> The array to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromBufferEx``1(Cloo.ComputeBufferBase{``0},System.Array@,System.Boolean,System.Int64,System.Int64,System.Int64,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Added by Hybrid DSP
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="destination">
      </param>
      <param name="blocking">
      </param>
      <param name="sourceOffset">
      </param>
      <param name="destinationOffset">
      </param>
      <param name="region">
      </param>
      <param name="events">
      </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromImage(Cloo.ComputeImage,System.IntPtr,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from an image.
            </summary>
      <param name="source"> The image to read from. </param>
      <param name="destination"> A valid pointer to a preallocated memory area to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromImage(Cloo.ComputeImage2D,System.IntPtr,System.Boolean,Cloo.SysIntX2,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from an image.
            </summary>
      <param name="source"> The image to read from. </param>
      <param name="destination"> A valid pointer to a preallocated memory area to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromImage(Cloo.ComputeImage3D,System.IntPtr,System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from an image.
            </summary>
      <param name="source"> The image to read from. </param>
      <param name="destination"> A valid pointer to a preallocated memory area to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromImage(Cloo.ComputeImage2D,System.IntPtr,System.Boolean,Cloo.SysIntX2,Cloo.SysIntX2,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from an image.
            </summary>
      <param name="source"> The image to read from. </param>
      <param name="destination"> A valid pointer to a preallocated memory area to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="sourceRowPitch"> The size of a row of pixels of <paramref name="destination" /> in bytes. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReadFromImage(Cloo.ComputeImage3D,System.IntPtr,System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from an image.
            </summary>
      <param name="source"> The image to read from. </param>
      <param name="destination"> A valid pointer to a preallocated memory area to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="sourceRowPitch"> The size of a row of pixels of <paramref name="destination" /> in bytes. </param>
      <param name="sourceSlicePitch"> The size of a 2D slice of pixels of <paramref name="destination" /> in bytes. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToBuffer``1(``0[],Cloo.ComputeBufferBase{``0},System.Boolean,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to a buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffer. </typeparam>
      <param name="source"> The array to read from. </param>
      <param name="destination"> The buffer to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToBuffer``1(``0[],Cloo.ComputeBufferBase{``0},System.Boolean,System.Int64,System.Int64,System.Int64,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to a buffer.
            </summary>
      <typeparam name="T"> The type of data in the buffer. </typeparam>
      <param name="source"> The array to read from. </param>
      <param name="destination"> The buffer to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToBufferEx``1(System.Array,Cloo.ComputeBufferBase{``0},System.Boolean,System.Int64,System.Int64,System.Int64,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Added by Hybrid DSP
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">The source.</param>
      <param name="destination">The destination.</param>
      <param name="blocking">if set to <c>true</c> [blocking].</param>
      <param name="sourceOffset">The source offset.</param>
      <param name="destinationOffset">The destination offset.</param>
      <param name="region">The region.</param>
      <param name="events">The events.</param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToBufferEx``1(System.Array,Cloo.Bindings.CLMemoryHandle,System.Boolean,System.Int64,System.Int64,System.Int64,System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Added by Hybrid DSP
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">The source.</param>
      <param name="destination">The destination.</param>
      <param name="blocking">if set to <c>true</c> [blocking].</param>
      <param name="sourceOffset">The source offset.</param>
      <param name="destinationOffset">The destination offset.</param>
      <param name="region">The region.</param>
      <param name="events">The events.</param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToImage(System.IntPtr,Cloo.ComputeImage,System.Boolean,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to an image.
            </summary>
      <param name="source"> A pointer to a memory area to read from. </param>
      <param name="destination"> The image to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToImage(System.IntPtr,Cloo.ComputeImage2D,System.Boolean,Cloo.SysIntX2,Cloo.SysIntX2,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to an image.
            </summary>
      <param name="source"> A pointer to a memory area to read from. </param>
      <param name="destination"> The image to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToImage(System.IntPtr,Cloo.ComputeImage3D,System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to an image.
            </summary>
      <param name="source"> A pointer to a memory area to read from. </param>
      <param name="destination"> The image to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToImage(System.IntPtr,Cloo.ComputeImage2D,System.Boolean,Cloo.SysIntX2,Cloo.SysIntX2,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to an image.
            </summary>
      <param name="source"> A pointer to a memory area to read from. </param>
      <param name="destination"> The image to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="destinationRowPitch"> The size of a row of pixels of <paramref name="destination" /> in bytes. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteToImage(System.IntPtr,Cloo.ComputeImage3D,System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to an image.
            </summary>
      <param name="source"> A pointer to a memory area to read from. </param>
      <param name="destination"> The image to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="destinationRowPitch"> The size of a row of pixels of <paramref name="destination" /> in bytes. </param>
      <param name="destinationSlicePitch"> The size of a 2D slice of pixels of <paramref name="destination" /> in bytes. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.#ctor(Cloo.ComputeContext,Cloo.ComputeDevice,Cloo.ComputeCommandQueueFlags)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeCommandQueue" />.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="device"> A <see cref="T:Cloo.ComputeDevice" /> associated with the <paramref name="context" />. It can either be one of <see cref="P:Cloo.ComputeContext.Devices" /> or have the same <see cref="T:Cloo.ComputeDeviceTypes" /> as the <paramref name="device" /> specified when the <paramref name="context" /> is created. </param>
      <param name="properties"> The properties for the <see cref="T:Cloo.ComputeCommandQueue" />. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.AcquireGLObjects(System.Collections.Generic.ICollection{Cloo.ComputeMemory},System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to acquire a collection of <see cref="T:Cloo.ComputeMemory" />s that have been previously created from OpenGL objects.
            </summary>
      <param name="memObjs"> A collection of OpenCL memory objects that correspond to OpenGL objects. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.AddBarrier">
      <summary>
            Enqueues a barrier.
            </summary>
      <remarks> A barrier ensures that all queued commands have finished execution before the next batch of commands can begin execution. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.AddMarker">
      <summary>
            Enqueues a marker.
            </summary>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Copy``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},System.Int64,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data between buffers.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> a new event identifying this command is attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Copy``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeBufferBase{``0},Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy a 2D or 3D region of elements between two buffers.
            </summary>
      <typeparam name="T"> The type of data in the buffers. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="sourceRowPitch"> The size of the source buffer row in bytes. If set to zero then <paramref name="sourceRowPitch" /> equals <c>region.X * sizeof(T)</c>. </param>
      <param name="sourceSlicePitch"> The size of the source buffer 2D slice in bytes. If set to zero then <paramref name="sourceSlicePitch" /> equals <c>region.Y * sizeof(T) * sourceRowPitch</c>. </param>
      <param name="destinationRowPitch"> The size of the destination buffer row in bytes. If set to zero then <paramref name="destinationRowPitch" /> equals <c>region.X * sizeof(T)</c>. </param>
      <param name="destinationSlicePitch"> The size of the destination buffer 2D slice in bytes. If set to zero then <paramref name="destinationSlicePitch" /> equals <c>region.Y * sizeof(T) * destinationRowPitch</c>. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Copy``1(Cloo.ComputeBufferBase{``0},Cloo.ComputeImage,System.Int64,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from buffer to <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <typeparam name="T"> The type of data in <paramref name="source" />. </typeparam>
      <param name="source"> The buffer to copy from. </param>
      <param name="destination"> The image to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Copy``1(Cloo.ComputeImage,Cloo.ComputeBufferBase{``0},Cloo.SysIntX3,System.Int64,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data from <see cref="T:Cloo.ComputeImage" /> to buffer.
            </summary>
      <param name="source"> The image to copy from. </param>
      <param name="destination"> The buffer to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Copy(Cloo.ComputeImage,Cloo.ComputeImage,Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to copy data between <see cref="T:Cloo.ComputeImage" />s.
            </summary>
      <param name="source"> The <see cref="T:Cloo.ComputeImage" /> to copy from. </param>
      <param name="destination"> The <see cref="T:Cloo.ComputeImage" /> to copy to. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ExecuteTask(Cloo.ComputeKernel,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to execute a single <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <param name="kernel"> The <see cref="T:Cloo.ComputeKernel" /> to execute. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Execute(Cloo.ComputeKernel,System.Int64[],System.Int64[],System.Int64[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to execute a range of <see cref="T:Cloo.ComputeKernel" />s in parallel.
            </summary>
      <param name="kernel"> The <see cref="T:Cloo.ComputeKernel" /> to execute. </param>
      <param name="globalWorkOffset"> An array of values that describe the offset used to calculate the global ID of a work-item instead of having the global IDs always start at offset (0, 0,... 0). </param>
      <param name="globalWorkSize"> An array of values that describe the number of global work-items in dimensions that will execute the kernel function. The total number of global work-items is computed as global_work_size[0] *...* global_work_size[work_dim - 1]. </param>
      <param name="localWorkSize"> An array of values that describe the number of work-items that make up a work-group (also referred to as the size of the work-group) that will execute the <paramref name="kernel" />. The total number of work-items in a work-group is computed as local_work_size[0] *... * local_work_size[work_dim - 1]. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Finish">
      <summary>
            Blocks until all previously enqueued commands are issued to the <see cref="P:Cloo.ComputeCommandQueue.Device" /> and have completed.
            </summary>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Flush">
      <summary>
            Issues all previously enqueued commands to the <see cref="P:Cloo.ComputeCommandQueue.Device" />.
            </summary>
      <remarks> This method only guarantees that all previously enqueued commands get issued to the OpenCL device. There is no guarantee that they will be complete after this method returns. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Map``1(Cloo.ComputeBufferBase{``0},System.Boolean,Cloo.ComputeMemoryMappingFlags,System.Int64,System.Int64,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to map a part of a buffer into the host address space.
            </summary>
      <param name="buffer"> The buffer to map. </param>
      <param name="blocking">  The mode of operation of this call. </param>
      <param name="flags"> A list of properties for the mapping mode. </param>
      <param name="offset"> The <paramref name="buffer" /> element position where mapping starts. </param>
      <param name="region"> The region of elements to map. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> If <paramref name="blocking" /> is <c>true</c> this method will not return until the command completes. If <paramref name="blocking" /> is <c>false</c> this method will return immediately after the command is enqueued. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Map(Cloo.ComputeImage,System.Boolean,Cloo.ComputeMemoryMappingFlags,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to map a part of a <see cref="T:Cloo.ComputeImage" /> into the host address space.
            </summary>
      <param name="image"> The <see cref="T:Cloo.ComputeImage" /> to map. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="flags"> A list of properties for the mapping mode. </param>
      <param name="offset"> The <paramref name="image" /> element position where mapping starts. </param>
      <param name="region"> The region of elements to map. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> If <paramref name="blocking" /> is <c>true</c> this method will not return until the command completes. If <paramref name="blocking" /> is <c>false</c> this method will return immediately after the command is enqueued. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Read``1(Cloo.ComputeBufferBase{``0},System.Boolean,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from a buffer.
            </summary>
      <param name="source"> The buffer to read from. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="offset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="destination"> A pointer to a preallocated memory area to read the data into. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> If <paramref name="blocking" /> is <c>true</c> this method will not return until the command completes. If <paramref name="blocking" /> is <c>false</c> this method will return immediately after the command is enqueued. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Read``1(Cloo.ComputeBufferBase{``0},System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read a 2D or 3D region of elements from a buffer.
            </summary>
      <typeparam name="T"> The type of the elements of the buffer. </typeparam>
      <param name="source"> The buffer to read from. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="sourceRowPitch"> The size of the source buffer row in bytes. If set to zero then <paramref name="sourceRowPitch" /> equals <c>region.X * sizeof(T)</c>. </param>
      <param name="sourceSlicePitch"> The size of the source buffer 2D slice in bytes. If set to zero then <paramref name="sourceSlicePitch" /> equals <c>region.Y * sizeof(T) * sourceRowPitch</c>. </param>
      <param name="destinationRowPitch"> The size of the destination buffer row in bytes. If set to zero then <paramref name="destinationRowPitch" /> equals <c>region.X * sizeof(T)</c>. </param>
      <param name="destinationSlicePitch"> The size of the destination buffer 2D slice in bytes. If set to zero then <paramref name="destinationSlicePitch" /> equals <c>region.Y * sizeof(T) * destinationRowPitch</c>. </param>
      <param name="destination"> A pointer to a preallocated memory area to read the data into. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Read(Cloo.ComputeImage,System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to read data from a <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <param name="source"> The <see cref="T:Cloo.ComputeImage" /> to read from. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="offset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to read. </param>
      <param name="rowPitch"> The <see cref="P:Cloo.ComputeImage.RowPitch" /> of <paramref name="source" /> or 0. </param>
      <param name="slicePitch"> The <see cref="P:Cloo.ComputeImage.SlicePitch" /> of <paramref name="source" /> or 0. </param>
      <param name="destination"> A pointer to a preallocated memory area to read the data into. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> If <paramref name="blocking" /> is <c>true</c> this method will not return until the command completes. If <paramref name="blocking" /> is <c>false</c> this method will return immediately after the command is enqueued. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.ReleaseGLObjects(System.Collections.Generic.ICollection{Cloo.ComputeMemory},System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to release <see cref="T:Cloo.ComputeMemory" />s that have been created from OpenGL objects.
            </summary>
      <param name="memObjs"> A collection of <see cref="T:Cloo.ComputeMemory" />s that correspond to OpenGL memory objects. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Unmap(Cloo.ComputeMemory,System.IntPtr@,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to unmap a buffer or a <see cref="T:Cloo.ComputeImage" /> from the host address space.
            </summary>
      <param name="memory"> The <see cref="T:Cloo.ComputeMemory" />. </param>
      <param name="mappedPtr"> The host address returned by a previous call to <see cref="M:Cloo.ComputeCommandQueue.Map(Cloo.ComputeImage,System.Boolean,Cloo.ComputeMemoryMappingFlags,Cloo.SysIntX3,Cloo.SysIntX3,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})" />. This pointer is <c>IntPtr.Zero</c> after this method returns. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Wait(System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a wait command for a collection of <see cref="T:Cloo.ComputeEvent" />s to complete before any future commands queued in the <see cref="T:Cloo.ComputeCommandQueue" /> are executed.
            </summary>
      <param name="events"> The <see cref="T:Cloo.ComputeEvent" />s that this command will wait for. </param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Write``1(Cloo.ComputeBufferBase{``0},System.Boolean,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to a buffer.
            </summary>
      <param name="destination"> The buffer to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="source"> The data written to the buffer. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> If <paramref name="blocking" /> is <c>true</c> this method will not return until the command completes. If <paramref name="blocking" /> is <c>false</c> this method will return immediately after the command is enqueued. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.WriteEx``1(Cloo.Bindings.CLMemoryHandle,System.Boolean,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Added by Hybrid DSP
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="destinationHandle">The destination.</param>
      <param name="blocking">if set to <c>true</c> [blocking].</param>
      <param name="destinationOffset">The destination offset.</param>
      <param name="region">The region.</param>
      <param name="source">The source.</param>
      <param name="events">The events.</param>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Write``1(Cloo.ComputeBufferBase{``0},System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write a 2D or 3D region of elements to a buffer.
            </summary>
      <typeparam name="T"> The type of the elements of the buffer. </typeparam>
      <param name="destination"> The buffer to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="sourceOffset"> The <paramref name="source" /> element position where reading starts. </param>
      <param name="region"> The region of elements to copy. </param>
      <param name="destinationRowPitch"> The size of the destination buffer row in bytes. If set to zero then <paramref name="destinationRowPitch" /> equals <c>region.X * sizeof(T)</c>. </param>
      <param name="destinationSlicePitch"> The size of the destination buffer 2D slice in bytes. If set to zero then <paramref name="destinationSlicePitch" /> equals <c>region.Y * sizeof(T) * destinationRowPitch</c>. </param>
      <param name="sourceRowPitch"> The size of the memory area row in bytes. If set to zero then <paramref name="sourceRowPitch" /> equals <c>region.X * sizeof(T)</c>. </param>
      <param name="sourceSlicePitch"> The size of the memory area 2D slice in bytes. If set to zero then <paramref name="sourceSlicePitch" /> equals <c>region.Y * sizeof(T) * sourceRowPitch</c>. </param>
      <param name="source"> The data written to the buffer. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Write(Cloo.ComputeImage,System.Boolean,Cloo.SysIntX3,Cloo.SysIntX3,System.Int64,System.Int64,System.IntPtr,System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Enqueues a command to write data to a <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <param name="destination"> The <see cref="T:Cloo.ComputeImage" /> to write to. </param>
      <param name="blocking"> The mode of operation of this command. If <c>true</c> this call will not return until the command has finished execution. </param>
      <param name="destinationOffset"> The <paramref name="destination" /> element position where writing starts. </param>
      <param name="region"> The region of elements to write. </param>
      <param name="rowPitch"> The <see cref="P:Cloo.ComputeImage.RowPitch" /> of <paramref name="destination" /> or 0. </param>
      <param name="slicePitch"> The <see cref="P:Cloo.ComputeImage.SlicePitch" /> of <paramref name="destination" /> or 0. </param>
      <param name="source"> The content written to the <see cref="T:Cloo.ComputeImage" />. </param>
      <param name="events"> A collection of events that need to complete before this particular command can be executed. If <paramref name="events" /> is not <c>null</c> or read-only a new <see cref="T:Cloo.ComputeEvent" /> identifying this command is created and attached to the end of the collection. </param>
      <remarks> If <paramref name="blocking" /> is <c>true</c> this method will not return until the command completes. If <paramref name="blocking" /> is <c>false</c> this method will return immediately after the command is enqueued. </remarks>
    </member>
    <member name="M:Cloo.ComputeCommandQueue.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeCommandQueue.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeCommandQueue" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeCommandQueue.Context">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeCommandQueue" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeCommandQueue" />. </value>
    </member>
    <member name="P:Cloo.ComputeCommandQueue.Device">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" /> of the <see cref="T:Cloo.ComputeCommandQueue" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" /> of the <see cref="T:Cloo.ComputeCommandQueue" />. </value>
    </member>
    <member name="P:Cloo.ComputeCommandQueue.OutOfOrderExecution">
      <summary>
            Gets the out-of-order execution mode of the commands in the <see cref="T:Cloo.ComputeCommandQueue" />.
            </summary>
      <value> Is <c>true</c> if <see cref="T:Cloo.ComputeCommandQueue" /> has out-of-order execution mode enabled and <c>false</c> otherwise. </value>
    </member>
    <member name="P:Cloo.ComputeCommandQueue.Profiling">
      <summary>
            Gets the profiling mode of the commands in the <see cref="T:Cloo.ComputeCommandQueue" />.
            </summary>
      <value> Is <c>true</c> if <see cref="T:Cloo.ComputeCommandQueue" /> has profiling enabled and <c>false</c> otherwise. </value>
    </member>
    <member name="T:Cloo.ComputeCompiler">
      <summary>
            Represents the OpenCL compiler.
            </summary>
    </member>
    <member name="M:Cloo.ComputeCompiler.Unload">
      <summary>
            Unloads the OpenCL compiler.
            </summary>
    </member>
    <member name="T:Cloo.ComputeContext">
      <summary>
            Represents an OpenCL context.
            </summary>
      <remarks> The environment within which the kernels execute and the domain in which synchronization and memory management is defined. </remarks>
      <br />
      <example> 
            This example shows how to create a <see cref="T:Cloo.ComputeContext" /> that is able to share data with an OpenGL context in a Microsoft Windows OS:
            <code><![CDATA[
            
            // NOTE: If you see some non C# bits surrounding this code section, ignore them. They're not part of the code.
            
            // We will need the device context, which is obtained through an OS specific function.
            [DllImport("opengl32.dll")]
            extern static IntPtr wglGetCurrentDC();
            
            // Query the device context.
            IntPtr deviceContextHandle = wglGetCurrentDC();
            
            // Select a platform which is capable of OpenCL/OpenGL interop.
            ComputePlatform platform = ComputePlatform.GetByName(name);
            
            // Create the context property list and populate it.
            ComputeContextProperty p1 = new ComputeContextProperty(ComputeContextPropertyName.Platform, platform.Handle.Value);
            ComputeContextProperty p2 = new ComputeContextProperty(ComputeContextPropertyName.CL_GL_CONTEXT_KHR, openGLContextHandle);
            ComputeContextProperty p3 = new ComputeContextProperty(ComputeContextPropertyName.CL_WGL_HDC_KHR, deviceContextHandle);
            ComputeContextPropertyList cpl = new ComputeContextPropertyList(new ComputeContextProperty[] { p1, p2, p3 });
            
            // Create the context. Usually, you'll want this on a GPU but other options might be available as well.
            ComputeContext context = new ComputeContext(ComputeDeviceTypes.Gpu, cpl, null, IntPtr.Zero);
            
            // Create a shared OpenCL/OpenGL buffer.
            // The generic type should match the type of data that the buffer contains.
            // glBufferId is an existing OpenGL buffer identifier.
            ComputeBuffer<float> clglBuffer = ComputeBuffer.CreateFromGLBuffer<float>(context, ComputeMemoryFlags.ReadWrite, glBufferId);
            
            ]]></code>
            Before working with the <c>clglBuffer</c> you should make sure of two things:<br />
            1) OpenGL isn't using <c>glBufferId</c>. You can achieve this by calling <c>glFinish</c>.<br />
            2) Make it available to OpenCL through the <see cref="M:Cloo.ComputeCommandQueue.AcquireGLObjects(System.Collections.Generic.ICollection{Cloo.ComputeMemory},System.Collections.Generic.ICollection{Cloo.ComputeEventBase})" /> method.<br />
            When finished, you should wait until <c>clglBuffer</c> isn't used any longer by OpenCL. After that, call <see cref="M:Cloo.ComputeCommandQueue.ReleaseGLObjects(System.Collections.Generic.ICollection{Cloo.ComputeMemory},System.Collections.Generic.ICollection{Cloo.ComputeEventBase})" /> to make the buffer available to OpenGL again.
            </example>
      <seealso cref="T:Cloo.ComputeDevice" />
      <seealso cref="T:Cloo.ComputePlatform" />
    </member>
    <member name="M:Cloo.ComputeContext.#ctor(System.Collections.Generic.ICollection{Cloo.ComputeDevice},Cloo.ComputeContextPropertyList,Cloo.Bindings.ComputeContextNotifier,System.IntPtr)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeContext" /> on a collection of <see cref="T:Cloo.ComputeDevice" />s.
            </summary>
      <param name="devices"> A collection of <see cref="T:Cloo.ComputeDevice" />s to associate with the <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="properties"> A <see cref="T:Cloo.ComputeContextPropertyList" /> of the <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="notify"> A delegate instance that refers to a notification routine. This routine is a callback function that will be used by the OpenCL implementation to report information on errors that occur in the <see cref="T:Cloo.ComputeContext" />. The callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe and that the delegate instance doesn't get collected by the Garbage Collector until <see cref="T:Cloo.ComputeContext" /> is disposed. If <paramref name="notify" /> is <c>null</c>, no callback function is registered. </param>
      <param name="notifyDataPtr"> Optional user data that will be passed to <paramref name="notify" />. </param>
    </member>
    <member name="M:Cloo.ComputeContext.#ctor(Cloo.ComputeDeviceTypes,Cloo.ComputeContextPropertyList,Cloo.Bindings.ComputeContextNotifier,System.IntPtr)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeContext" /> on all the <see cref="T:Cloo.ComputeDevice" />s that match the specified <see cref="T:Cloo.ComputeDeviceTypes" />.
            </summary>
      <param name="deviceType"> A bit-field that identifies the type of <see cref="T:Cloo.ComputeDevice" /> to associate with the <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="properties"> A <see cref="T:Cloo.ComputeContextPropertyList" /> of the <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="notify"> A delegate instance that refers to a notification routine. This routine is a callback function that will be used by the OpenCL implementation to report information on errors that occur in the <see cref="T:Cloo.ComputeContext" />. The callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe and that the delegate instance doesn't get collected by the Garbage Collector until <see cref="T:Cloo.ComputeContext" /> is disposed. If <paramref name="notify" /> is <c>null</c>, no callback function is registered. </param>
      <param name="userDataPtr"> Optional user data that will be passed to <paramref name="notify" />. </param>
    </member>
    <member name="M:Cloo.ComputeContext.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeContext.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeContext" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeContext.Devices">
      <summary>
            Gets a read-only collection of the <see cref="T:Cloo.ComputeDevice" />s of the <see cref="T:Cloo.ComputeContext" />.
            </summary>
      <value> A read-only collection of the <see cref="T:Cloo.ComputeDevice" />s of the <see cref="T:Cloo.ComputeContext" />. </value>
    </member>
    <member name="P:Cloo.ComputeContext.Platform">
      <summary>
            Gets the <see cref="T:Cloo.ComputePlatform" /> of the <see cref="T:Cloo.ComputeContext" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputePlatform" /> of the <see cref="T:Cloo.ComputeContext" />. </value>
    </member>
    <member name="P:Cloo.ComputeContext.Properties">
      <summary>
            Gets a collection of <see cref="T:Cloo.ComputeContextProperty" />s of the <see cref="T:Cloo.ComputeContext" />.
            </summary>
      <value> A collection of <see cref="T:Cloo.ComputeContextProperty" />s of the <see cref="T:Cloo.ComputeContext" />. </value>
    </member>
    <member name="T:Cloo.ComputeContextPropertyList">
      <summary>
            Represents a list of <see cref="T:Cloo.ComputeContextProperty" />s.
            </summary>
      <remarks> A <see cref="T:Cloo.ComputeContextPropertyList" /> is used to specify the properties of a <see cref="T:Cloo.ComputeContext" />. </remarks>
      <seealso cref="T:Cloo.ComputeContext" />
      <seealso cref="T:Cloo.ComputeContextProperty" />
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.#ctor(Cloo.ComputePlatform)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeContextPropertyList" /> which contains a single item specifying a <see cref="T:Cloo.ComputePlatform" />.
            </summary>
      <param name="platform"> A <see cref="T:Cloo.ComputePlatform" />. </param>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.#ctor(System.Collections.Generic.IEnumerable{Cloo.ComputeContextProperty})">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeContextPropertyList" /> which contains the specified <see cref="T:Cloo.ComputeContextProperty" />s.
            </summary>
      <param name="properties"> An enumerable of <see cref="T:Cloo.ComputeContextProperty" />'s. </param>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.GetByName(Cloo.ComputeContextPropertyName)">
      <summary>
            Gets a <see cref="T:Cloo.ComputeContextProperty" /> of a specified <c>ComputeContextPropertyName</c>.
            </summary>
      <param name="name"> The <see cref="T:Cloo.ComputeContextPropertyName" /> of the <see cref="T:Cloo.ComputeContextProperty" />. </param>
      <returns> The requested <see cref="T:Cloo.ComputeContextProperty" /> or <c>null</c> if no such <see cref="T:Cloo.ComputeContextProperty" /> exists in the <see cref="T:Cloo.ComputeContextPropertyList" />. </returns>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.Add(Cloo.ComputeContextProperty)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.Contains(Cloo.ComputeContextProperty)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.CopyTo(Cloo.ComputeContextProperty[],System.Int32)">
      <summary>
      </summary>
      <param name="array">
      </param>
      <param name="arrayIndex">
      </param>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.Remove(Cloo.ComputeContextProperty)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeContextPropertyList.GetEnumerator">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Cloo.ComputeContextPropertyList.Count">
      <summary>
      </summary>
    </member>
    <member name="P:Cloo.ComputeContextPropertyList.IsReadOnly">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeContextProperty">
      <summary>
            Represents an OpenCL context property.
            </summary>
      <remarks> An OpenCL context property is a (name, value) data pair. </remarks>
    </member>
    <member name="M:Cloo.ComputeContextProperty.#ctor(Cloo.ComputeContextPropertyName,System.IntPtr)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeContextProperty" />.
            </summary>
      <param name="name"> The name of the <see cref="T:Cloo.ComputeContextProperty" />. </param>
      <param name="value"> The value of the created <see cref="T:Cloo.ComputeContextProperty" />. </param>
    </member>
    <member name="M:Cloo.ComputeContextProperty.ToString">
      <summary>
            Gets the string representation of the <see cref="T:Cloo.ComputeContextProperty" />.
            </summary>
      <returns> The string representation of the <see cref="T:Cloo.ComputeContextProperty" />. </returns>
    </member>
    <member name="P:Cloo.ComputeContextProperty.Name">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContextPropertyName" /> of the <see cref="T:Cloo.ComputeContextProperty" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContextPropertyName" /> of the <see cref="T:Cloo.ComputeContextProperty" />. </value>
    </member>
    <member name="P:Cloo.ComputeContextProperty.Value">
      <summary>
            Gets the value of the <see cref="T:Cloo.ComputeContextProperty" />.
            </summary>
      <value> The value of the <see cref="T:Cloo.ComputeContextProperty" />. </value>
    </member>
    <member name="T:Cloo.ComputeDevice">
      <summary>
            Represents an OpenCL device.
            </summary>
      <value> A device is a collection of compute units. A command queue is used to queue commands to a device. Examples of commands include executing kernels, or reading and writing memory objects. OpenCL devices typically correspond to a GPU, a multi-core CPU, and other processors such as DSPs and the Cell/B.E. processor. </value>
      <seealso cref="T:Cloo.ComputeCommandQueue" />
      <seealso cref="T:Cloo.ComputeKernel" />
      <seealso cref="T:Cloo.ComputeMemory" />
      <seealso cref="T:Cloo.ComputePlatform" />
    </member>
    <member name="P:Cloo.ComputeDevice.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeDevice.AddressBits">
      <summary>
            Gets the default <see cref="T:Cloo.ComputeDevice" /> address space size in bits.
            </summary>
      <value> Currently supported values are 32 or 64 bits. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Available">
      <summary>
            Gets the availability state of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> Is <c>true</c> if the <see cref="T:Cloo.ComputeDevice" /> is available and <c>false</c> otherwise. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.CommandQueueFlags">
      <summary>
            Gets the <see cref="T:Cloo.ComputeCommandQueueFlags" /> supported by the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeCommandQueueFlags" /> supported by the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.CompilerAvailable">
      <summary>
            Gets the availability state of the OpenCL compiler of the <see cref="P:Cloo.ComputeDevice.Platform" />.
            </summary>
      <value> Is <c>true</c> if the implementation has a compiler available to compile the program source and <c>false</c> otherwise. This can be <c>false</c> for the embededed platform profile only. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.DriverVersion">
      <summary>
            Gets the OpenCL software driver version string of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The version string in the form <c>major_number.minor_number</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.EndianLittle">
      <summary>
            Gets the endianness of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> Is <c>true</c> if the <see cref="T:Cloo.ComputeDevice" /> is a little endian device and <c>false</c> otherwise. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.ErrorCorrectionSupport">
      <summary>
            Gets the error correction support state of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> Is <c>true</c> if the <see cref="T:Cloo.ComputeDevice" /> implements error correction for the memories, caches, registers etc. Is <c>false</c> if the <see cref="T:Cloo.ComputeDevice" /> does not implement error correction. This can be a requirement for certain clients of OpenCL. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.ExecutionCapabilities">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDeviceExecutionCapabilities" /> of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDeviceExecutionCapabilities" /> of the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Extensions">
      <summary>
            Gets a read-only collection of names of extensions that the <see cref="T:Cloo.ComputeDevice" /> supports.
            </summary>
      <value> A read-only collection of names of extensions that the <see cref="T:Cloo.ComputeDevice" /> supports. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.GlobalMemoryCacheLineSize">
      <summary>
            Gets the size of the global <see cref="T:Cloo.ComputeDevice" /> memory cache line in bytes.
            </summary>
      <value> The size of the global <see cref="T:Cloo.ComputeDevice" /> memory cache line in bytes. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.GlobalMemoryCacheSize">
      <summary>
            Gets the size of the global <see cref="T:Cloo.ComputeDevice" /> memory cache in bytes.
            </summary>
      <value> The size of the global <see cref="T:Cloo.ComputeDevice" /> memory cache in bytes. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.GlobalMemoryCacheType">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDeviceMemoryCacheType" /> of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDeviceMemoryCacheType" /> of the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.GlobalMemorySize">
      <summary>
            Gets the size of the global <see cref="T:Cloo.ComputeDevice" /> memory in bytes.
            </summary>
      <value> The size of the global <see cref="T:Cloo.ComputeDevice" /> memory in bytes. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Image2DMaxHeight">
      <summary>
            Gets the maximum <see cref="!:ComputeImage2D.Height" /> value that the <see cref="T:Cloo.ComputeDevice" /> supports in pixels.
            </summary>
      <value> The minimum value is 8192 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Image2DMaxWidth">
      <summary>
            Gets the maximum <see cref="!:ComputeImage2D.Width" /> value that the <see cref="T:Cloo.ComputeDevice" /> supports in pixels.
            </summary>
      <value> The minimum value is 8192 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Image3DMaxDepth">
      <summary>
            Gets the maximum <see cref="!:ComputeImage3D.Depth" /> value that the <see cref="T:Cloo.ComputeDevice" /> supports in pixels.
            </summary>
      <value> The minimum value is 2048 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Image3DMaxHeight">
      <summary>
            Gets the maximum <see cref="!:ComputeImage3D.Height" /> value that the <see cref="T:Cloo.ComputeDevice" /> supports in pixels.
            </summary>
      <value> The minimum value is 2048 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Image3DMaxWidth">
      <summary>
            Gets the maximum <see cref="!:ComputeImage3D.Width" /> value that the <see cref="T:Cloo.ComputeDevice" /> supports in pixels.
            </summary>
      <value> The minimum value is 2048 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.ImageSupport">
      <summary>
            Gets the state of image support of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> Is <c>true</c> if <see cref="T:Cloo.ComputeImage" />s are supported by the <see cref="T:Cloo.ComputeDevice" /> and <c>false</c> otherwise. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.LocalMemorySize">
      <summary>
            Gets the size of local memory are of the <see cref="T:Cloo.ComputeDevice" /> in bytes.
            </summary>
      <value> The minimum value is 16 KB (OpenCL 1.0) or 32 KB (OpenCL 1.1). </value>
    </member>
    <member name="P:Cloo.ComputeDevice.LocalMemoryType">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDeviceLocalMemoryType" /> that is supported on the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDeviceLocalMemoryType" /> that is supported on the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxClockFrequency">
      <summary>
            Gets the maximum configured clock frequency of the <see cref="T:Cloo.ComputeDevice" /> in MHz.
            </summary>
      <value> The maximum configured clock frequency of the <see cref="T:Cloo.ComputeDevice" /> in MHz. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxComputeUnits">
      <summary>
            Gets the number of parallel compute cores on the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The minimum value is 1. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxConstantArguments">
      <summary>
            Gets the maximum number of arguments declared with the <c>__constant</c> or <c>constant</c> qualifier in a <see cref="T:Cloo.ComputeKernel" /> executing in the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The minimum value is 8. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxConstantBufferSize">
      <summary>
            Gets the maximum size in bytes of a constant buffer allocation in the <see cref="T:Cloo.ComputeDevice" /> memory.
            </summary>
      <value> The minimum value is 64 KB. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxMemoryAllocationSize">
      <summary>
            Gets the maximum size of memory object allocation in the <see cref="T:Cloo.ComputeDevice" /> memory in bytes.
            </summary>
      <value> The minimum value is <c>max(<see cref="P:Cloo.ComputeDevice.GlobalMemorySize" />/4, 128*1024*1024)</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxParameterSize">
      <summary>
            Gets the maximum size in bytes of the arguments that can be passed to a <see cref="T:Cloo.ComputeKernel" /> executing in the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The minimum value is 256 (OpenCL 1.0) or 1024 (OpenCL 1.1). </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxReadImageArguments">
      <summary>
            Gets the maximum number of simultaneous <see cref="T:Cloo.ComputeImage" />s that can be read by a <see cref="T:Cloo.ComputeKernel" /> executing in the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The minimum value is 128 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxSamplers">
      <summary>
            Gets the maximum number of <see cref="T:Cloo.ComputeSampler" />s that can be used in a <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <value> The minimum value is 16 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxWorkGroupSize">
      <summary>
            Gets the maximum number of work-items in a work-group executing a <see cref="T:Cloo.ComputeKernel" /> in a <see cref="T:Cloo.ComputeDevice" /> using the data parallel execution model.
            </summary>
      <value> The minimum value is 1. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxWorkItemDimensions">
      <summary>
            Gets the maximum number of dimensions that specify the global and local work-item IDs used by the data parallel execution model.
            </summary>
      <value> The minimum value is 3. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxWorkItemSizes">
      <summary>
            Gets the maximum number of work-items that can be specified in each dimension of the <paramref name="globalWorkSize" /> argument of <see cref="M:Cloo.ComputeCommandQueue.Execute(Cloo.ComputeKernel,System.Int64[],System.Int64[],System.Int64[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})" />.
            </summary>
      <value> The maximum number of work-items that can be specified in each dimension of the <paramref name="globalWorkSize" /> argument of <see cref="M:Cloo.ComputeCommandQueue.Execute(Cloo.ComputeKernel,System.Int64[],System.Int64[],System.Int64[],System.Collections.Generic.ICollection{Cloo.ComputeEventBase})" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MaxWriteImageArguments">
      <summary>
            Gets the maximum number of simultaneous <see cref="T:Cloo.ComputeImage" />s that can be written to by a <see cref="T:Cloo.ComputeKernel" /> executing in the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The minimum value is 8 if <see cref="P:Cloo.ComputeDevice.ImageSupport" /> is <c>true</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MemoryBaseAddressAlignment">
      <summary>
            Gets the alignment in bits of the base address of any <see cref="T:Cloo.ComputeMemory" /> allocated in the <see cref="T:Cloo.ComputeDevice" /> memory.
            </summary>
      <value> The alignment in bits of the base address of any <see cref="T:Cloo.ComputeMemory" /> allocated in the <see cref="T:Cloo.ComputeDevice" /> memory. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.MinDataTypeAlignmentSize">
      <summary>
            Gets the smallest alignment in bytes which can be used for any data type allocated in the <see cref="T:Cloo.ComputeDevice" /> memory.
            </summary>
      <value> The smallest alignment in bytes which can be used for any data type allocated in the <see cref="T:Cloo.ComputeDevice" /> memory. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Name">
      <summary>
            Gets the name of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The name of the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Platform">
      <summary>
            Gets the <see cref="T:Cloo.ComputePlatform" /> associated with the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputePlatform" /> associated with the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthChar">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>char</c>s.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>char</c>s. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthDouble">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>double</c>s or 0 if the <c>cl_khr_fp64</c> format is not supported.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>double</c>s or 0 if the <c>cl_khr_fp64</c> format is not supported. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthFloat">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>float</c>s.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>float</c>s. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthHalf">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>half</c>s or 0 if the <c>cl_khr_fp16</c> format is not supported.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>half</c>s or 0 if the <c>cl_khr_fp16</c> format is not supported. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthInt">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>int</c>s.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>int</c>s. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthLong">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>long</c>s.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>long</c>s. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.PreferredVectorWidthShort">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>short</c>s.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" />'s preferred native vector width size for vector of <c>short</c>s. </value>
      <remarks> The vector width is defined as the number of scalar elements that can be stored in the vector. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.Profile">
      <summary>
            Gets the OpenCL profile name supported by the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> 
            The profile name returned can be one of the following strings:
            <list type="bullets"><item><term> FULL_PROFILE </term><description> The <see cref="T:Cloo.ComputeDevice" /> supports the OpenCL specification (functionality defined as part of the core specification and does not require any extensions to be supported). </description></item><item><term> EMBEDDED_PROFILE </term><description> The <see cref="T:Cloo.ComputeDevice" /> supports the OpenCL embedded profile. </description></item></list></value>
    </member>
    <member name="P:Cloo.ComputeDevice.ProfilingTimerResolution">
      <summary>
            Gets the resolution of the <see cref="T:Cloo.ComputeDevice" /> timer in nanoseconds.
            </summary>
      <value> The resolution of the <see cref="T:Cloo.ComputeDevice" /> timer in nanoseconds. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.SingleCapabilites">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDeviceSingleCapabilities" /> of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDeviceSingleCapabilities" /> of the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Type">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDeviceTypes" /> of the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDeviceTypes" /> of the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.Vendor">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" /> vendor name string.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" /> vendor name string. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.VendorId">
      <summary>
            Gets a unique <see cref="T:Cloo.ComputeDevice" /> vendor identifier.
            </summary>
      <value> A unique <see cref="T:Cloo.ComputeDevice" /> vendor identifier. </value>
      <remarks> An example of a unique device identifier could be the PCIe ID. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.Version">
      <summary>
            Gets the OpenCL version supported by the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The OpenCL version supported by the <see cref="T:Cloo.ComputeDevice" />. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.VersionString">
      <summary>
            Gets the OpenCL version string supported by the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The version string has the following format: <c>OpenCL[space][major_version].[minor_version][space][vendor-specific information]</c>. </value>
    </member>
    <member name="P:Cloo.ComputeDevice.HostUnifiedMemory">
      <summary>
            Gets information about the presence of the unified memory subsystem.
            </summary>
      <value> Is <c>true</c> if the <see cref="T:Cloo.ComputeDevice" /> and the host have a unified memory subsystem and <c>false</c> otherwise. </value>
      <remarks> Requires OpenCL 1.1 </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthChar">
      <summary>
            Gets the native ISA vector width size for vector of <c>char</c>s.
            </summary>
      <value> The native ISA vector width size for vector of <c>char</c>s. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthDouble">
      <summary>
            Gets the native ISA vector width size for vector of <c>double</c>s or 0 if the <c>cl_khr_fp64</c> format is not supported.
            </summary>
      <value> The native ISA vector width size for vector of <c>double</c>s or 0 if the <c>cl_khr_fp64</c> format is not supported. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthFloat">
      <summary>
            Gets the native ISA vector width size for vector of <c>float</c>s.
            </summary>
      <value> The native ISA vector width size for vector of <c>float</c>s. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthHalf">
      <summary>
            Gets the native ISA vector width size for vector of <c>half</c>s or 0 if the <c>cl_khr_fp16</c> format is not supported.
            </summary>
      <value> The native ISA vector width size for vector of <c>half</c>s or 0 if the <c>cl_khr_fp16</c> format is not supported. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthInt">
      <summary>
            Gets the native ISA vector width size for vector of <c>int</c>s.
            </summary>
      <value> The native ISA vector width size for vector of <c>int</c>s. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthLong">
      <summary>
            Gets the native ISA vector width size for vector of <c>long</c>s.
            </summary>
      <value> The native ISA vector width size for vector of <c>long</c>s. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.NativeVectorWidthShort">
      <summary>
            Gets the native ISA vector width size for vector of <c>short</c>s.
            </summary>
      <value> The native ISA vector width size for vector of <c>short</c>s. </value>
      <remarks>
        <para> The vector width is defined as the number of scalar elements that can be stored in the vector. </para>
        <para> Requires OpenCL 1.1 </para>
      </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.OpenCLCVersion">
      <summary>
            Gets the OpenCL C version supported by the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> Is <c>1.1</c> if <see cref="P:Cloo.ComputeDevice.Version" /> is <c>1.1</c>. Is <c>1.0</c> or <c>1.1</c> if <see cref="P:Cloo.ComputeDevice.Version" /> is <c>1.0</c>. </value>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="P:Cloo.ComputeDevice.OpenCLCVersionString">
      <summary>
            Gets the OpenCL C version string supported by the <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <value> The OpenCL C version string supported by the <see cref="T:Cloo.ComputeDevice" />. The version string has the following format: <c>OpenCL[space]C[space][major_version].[minor_version][space][vendor-specific information]</c>. </value>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="T:Cloo.ComputeEventBase">
      <summary>
            Represents the parent type to any Cloo event types.
            </summary>
      <seealso cref="T:Cloo.ComputeEvent" />
      <seealso cref="T:Cloo.ComputeUserEvent" />
    </member>
    <member name="M:Cloo.ComputeEventBase.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="M:Cloo.ComputeEventBase.HookNotifier">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.ComputeEventBase.OnCompleted(System.Object,Cloo.ComputeCommandStatusArgs)">
      <summary>
      </summary>
      <param name="sender">
      </param>
      <param name="evArgs">
      </param>
    </member>
    <member name="M:Cloo.ComputeEventBase.OnAborted(System.Object,Cloo.ComputeCommandStatusArgs)">
      <summary>
      </summary>
      <param name="sender">
      </param>
      <param name="evArgs">
      </param>
    </member>
    <member name="P:Cloo.ComputeEventBase.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeEventBase" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeEventBase.Context">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContext" /> associated with the <see cref="T:Cloo.ComputeEventBase" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContext" /> associated with the <see cref="T:Cloo.ComputeEventBase" />. </value>
    </member>
    <member name="P:Cloo.ComputeEventBase.FinishTime">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command has finished execution.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command has finished execution. </value>
    </member>
    <member name="P:Cloo.ComputeEventBase.EnqueueTime">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command is enqueued in the <see cref="T:Cloo.ComputeCommandQueue" /> by the host.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command is enqueued in the <see cref="T:Cloo.ComputeCommandQueue" /> by the host. </value>
    </member>
    <member name="P:Cloo.ComputeEventBase.Status">
      <summary>
            Gets the execution status of the associated command.
            </summary>
      <value> The execution status of the associated command or a negative value if the execution was abnormally terminated. </value>
    </member>
    <member name="P:Cloo.ComputeEventBase.StartTime">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command starts execution.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command starts execution. </value>
    </member>
    <member name="P:Cloo.ComputeEventBase.SubmitTime">
      <summary>
            Gets the <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command that has been enqueued is submitted by the host to the device.
            </summary>
      <value> The <see cref="T:Cloo.ComputeDevice" /> time counter in nanoseconds when the associated command that has been enqueued is submitted by the host to the device. </value>
    </member>
    <member name="P:Cloo.ComputeEventBase.Type">
      <summary>
            Gets the <see cref="T:Cloo.ComputeCommandType" /> associated with the event.
            </summary>
      <value> The <see cref="T:Cloo.ComputeCommandType" /> associated with the event. </value>
    </member>
    <member name="E:Cloo.ComputeEventBase.Aborted">
      <summary>
            Occurs when the command associated with the event is abnormally terminated.
            </summary>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="E:Cloo.ComputeEventBase.Completed">
      <summary>
            Occurs when <c>ComputeEventBase.Status</c> changes to <c>ComputeCommandExecutionStatus.Complete</c>.
            </summary>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="T:Cloo.ComputeEvent">
      <summary>
            Represents an OpenCL event.
            </summary>
      <remarks> An event encapsulates the status of an operation such as a command. It can be used to synchronize operations in a context. </remarks>
      <seealso cref="T:Cloo.ComputeUserEvent" />
      <seealso cref="T:Cloo.ComputeCommandQueue" />
      <seealso cref="T:Cloo.ComputeContext" />
    </member>
    <member name="M:Cloo.ComputeEvent.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeEvent.CommandQueue">
      <summary>
            Gets the <see cref="T:Cloo.ComputeCommandQueue" /> associated with the <see cref="T:Cloo.ComputeEvent" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeCommandQueue" /> associated with the <see cref="T:Cloo.ComputeEvent" />. </value>
    </member>
    <member name="T:Cloo.ComputeCommandStatusArgs">
      <summary>
            Represents the arguments of a command status change.
            </summary>
    </member>
    <member name="M:Cloo.ComputeCommandStatusArgs.#ctor(Cloo.ComputeEventBase,Cloo.ComputeCommandExecutionStatus)">
      <summary>
            Creates a new <c>ComputeCommandStatusArgs</c> instance.
            </summary>
      <param name="ev"> The event representing the command that had its status changed. </param>
      <param name="status"> The status of the command. </param>
    </member>
    <member name="M:Cloo.ComputeCommandStatusArgs.#ctor(Cloo.ComputeEventBase,System.Int32)">
      <summary>
            Creates a new <c>ComputeCommandStatusArgs</c> instance.
            </summary>
      <param name="ev"> The event of the command that had its status changed. </param>
      <param name="status"> The status of the command. </param>
    </member>
    <member name="P:Cloo.ComputeCommandStatusArgs.Event">
      <summary>
            Gets the event associated with the command that had its status changed.
            </summary>
    </member>
    <member name="P:Cloo.ComputeCommandStatusArgs.Status">
      <summary>
            Gets the execution status of the command represented by the event.
            </summary>
      <remarks> Returns a negative integer if the command was abnormally terminated. </remarks>
    </member>
    <member name="T:Cloo.ComputeCommandStatusChanged">
      <summary>
      </summary>
      <param name="sender">
      </param>
      <param name="args">
      </param>
    </member>
    <member name="T:Cloo.ComputeEventList">
      <summary>
            Represents a list of OpenCL generated or user created events.
            </summary>
      <seealso cref="T:Cloo.ComputeCommandQueue" />
    </member>
    <member name="M:Cloo.ComputeEventList.#ctor">
      <summary>
            Creates an empty <see cref="T:Cloo.ComputeEventList" />.
            </summary>
    </member>
    <member name="M:Cloo.ComputeEventList.#ctor(System.Collections.Generic.IList{Cloo.ComputeEventBase})">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeEventList" /> from an existing list of <see cref="T:Cloo.ComputeEventBase" />s.
            </summary>
      <param name="events"> A list of <see cref="T:Cloo.ComputeEventBase" />s. </param>
    </member>
    <member name="M:Cloo.ComputeEventList.Wait(System.Collections.Generic.ICollection{Cloo.ComputeEventBase})">
      <summary>
            Waits on the host thread for the specified events to complete.
            </summary>
      <param name="events"> The events to be waited for completition. </param>
    </member>
    <member name="M:Cloo.ComputeEventList.Wait">
      <summary>
            Waits on the host thread for the <see cref="T:Cloo.ComputeEventBase" />s in the <see cref="T:Cloo.ComputeEventList" /> to complete.
            </summary>
    </member>
    <member name="M:Cloo.ComputeEventList.IndexOf(Cloo.ComputeEventBase)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeEventList.Insert(System.Int32,Cloo.ComputeEventBase)">
      <summary>
      </summary>
      <param name="index">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:Cloo.ComputeEventList.RemoveAt(System.Int32)">
      <summary>
      </summary>
      <param name="index">
      </param>
    </member>
    <member name="M:Cloo.ComputeEventList.Add(Cloo.ComputeEventBase)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:Cloo.ComputeEventList.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:Cloo.ComputeEventList.Contains(Cloo.ComputeEventBase)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeEventList.CopyTo(Cloo.ComputeEventBase[],System.Int32)">
      <summary>
      </summary>
      <param name="array">
      </param>
      <param name="arrayIndex">
      </param>
    </member>
    <member name="M:Cloo.ComputeEventList.Remove(Cloo.ComputeEventBase)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeEventList.GetEnumerator">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Cloo.ComputeEventList.Last">
      <summary>
            Gets the last <see cref="T:Cloo.ComputeEventBase" /> on the list.
            </summary>
      <value> The last <see cref="T:Cloo.ComputeEventBase" /> on the list. </value>
    </member>
    <member name="P:Cloo.ComputeEventList.Item(System.Int32)">
      <summary>
      </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Cloo.ComputeEventList.Count">
      <summary>
      </summary>
    </member>
    <member name="P:Cloo.ComputeEventList.IsReadOnly">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeException">
      <summary>
            Represents an error state that occurred while executing an OpenCL API call.
            </summary>
      <seealso cref="P:Cloo.ComputeException.ComputeErrorCode" />
    </member>
    <member name="M:Cloo.ComputeException.#ctor(Cloo.ComputeErrorCode)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeException" /> with a specified <see cref="P:Cloo.ComputeException.ComputeErrorCode" />.
            </summary>
      <param name="code"> A <see cref="P:Cloo.ComputeException.ComputeErrorCode" />. </param>
    </member>
    <member name="M:Cloo.ComputeException.ThrowOnError(System.Int32)">
      <summary>
            Checks for an OpenCL error code and throws a <see cref="T:Cloo.ComputeException" /> if such is encountered.
            </summary>
      <param name="errorCode"> The value to be checked for an OpenCL error. </param>
    </member>
    <member name="M:Cloo.ComputeException.ThrowOnError(Cloo.ComputeErrorCode)">
      <summary>
            Checks for an OpenCL error code and throws a <see cref="T:Cloo.ComputeException" /> if such is encountered.
            </summary>
      <param name="errorCode"> The OpenCL error code. </param>
    </member>
    <member name="P:Cloo.ComputeException.ComputeErrorCode">
      <summary>
            Gets the <see cref="P:Cloo.ComputeException.ComputeErrorCode" /> of the <see cref="T:Cloo.ComputeException" />.
            </summary>
    </member>
    <member name="T:Cloo.ComputeImage">
      <summary>
            Represents an OpenCL image.
            </summary>
      <remarks> A memory object that stores a two- or three- dimensional structured array. Image data can only be accessed with read and write functions. The read functions use a sampler. </remarks>
      <seealso cref="T:Cloo.ComputeMemory" />
      <seealso cref="T:Cloo.ComputeSampler" />
    </member>
    <member name="M:Cloo.ComputeImage.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags)">
      <summary>
      </summary>
      <param name="context">
      </param>
      <param name="flags">
      </param>
    </member>
    <member name="M:Cloo.ComputeImage.GetSupportedFormats(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,Cloo.ComputeMemoryType)">
      <summary>
      </summary>
      <param name="context">
      </param>
      <param name="flags">
      </param>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cloo.ComputeImage.Init">
      <summary>
      </summary>
    </member>
    <member name="P:Cloo.ComputeImage.Depth">
      <summary>
            Gets or sets (protected) the depth in pixels of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The depth in pixels of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="P:Cloo.ComputeImage.ElementSize">
      <summary>
            Gets or sets (protected) the size of the elements (pixels) of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The size of the elements (pixels) of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="P:Cloo.ComputeImage.Height">
      <summary>
            Gets or sets (protected) the height in pixels of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The height in pixels of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="P:Cloo.ComputeImage.RowPitch">
      <summary>
            Gets or sets (protected) the size in bytes of a row of elements of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The size in bytes of a row of elements of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="P:Cloo.ComputeImage.SlicePitch">
      <summary>
            Gets or sets (protected) the size in bytes of a 2D slice of a <see cref="T:Cloo.ComputeImage3D" />.
            </summary>
      <value> The size in bytes of a 2D slice of a <see cref="T:Cloo.ComputeImage3D" />. For a <see cref="T:Cloo.ComputeImage2D" /> this value is 0. </value>
    </member>
    <member name="P:Cloo.ComputeImage.Width">
      <summary>
            Gets or sets (protected) the width in pixels of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The width in pixels of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="T:Cloo.ComputeImage2D">
      <summary>
            Represents an OpenCL 2D image.
            </summary>
      <seealso cref="T:Cloo.ComputeImage" />
    </member>
    <member name="M:Cloo.ComputeImage2D.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,Cloo.ComputeImageFormat,System.Int32,System.Int32,System.Int64,System.IntPtr)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeImage2D" />.
            </summary>
      <param name="context"> A valid <see cref="T:Cloo.ComputeContext" /> in which the <see cref="T:Cloo.ComputeImage2D" /> is created. </param>
      <param name="flags"> A bit-field that is used to specify allocation and usage information about the <see cref="T:Cloo.ComputeImage2D" />. </param>
      <param name="format"> A structure that describes the format properties of the <see cref="T:Cloo.ComputeImage2D" />. </param>
      <param name="width"> The width of the <see cref="T:Cloo.ComputeImage2D" /> in pixels. </param>
      <param name="height"> The height of the <see cref="T:Cloo.ComputeImage2D" /> in pixels. </param>
      <param name="rowPitch"> The size in bytes of each row of elements of the <see cref="T:Cloo.ComputeImage2D" />. If <paramref name="rowPitch" /> is zero, OpenCL will compute the proper value based on <see cref="P:Cloo.ComputeImage.Width" /> and <see cref="P:Cloo.ComputeImage.ElementSize" />. </param>
      <param name="data"> The data to initialize the <see cref="T:Cloo.ComputeImage2D" />. Can be <c>IntPtr.Zero</c>. </param>
    </member>
    <member name="M:Cloo.ComputeImage2D.CreateFromGLRenderbuffer(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,System.Int32)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeImage2D" /> from an OpenGL renderbuffer object.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> with enabled CL/GL sharing. </param>
      <param name="flags"> A bit-field that is used to specify usage information about the <see cref="T:Cloo.ComputeImage2D" />. Only <c>ComputeMemoryFlags.ReadOnly</c>, <c>ComputeMemoryFlags.WriteOnly</c> and <c>ComputeMemoryFlags.ReadWrite</c> are allowed. </param>
      <param name="renderbufferId"> The OpenGL renderbuffer object id to use. </param>
      <returns> The created <see cref="T:Cloo.ComputeImage2D" />. </returns>
    </member>
    <member name="M:Cloo.ComputeImage2D.CreateFromGLTexture2D(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeImage2D" /> from an OpenGL 2D texture object.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> with enabled CL/GL sharing. </param>
      <param name="flags"> A bit-field that is used to specify usage information about the <see cref="T:Cloo.ComputeImage2D" />. Only <c>ComputeMemoryFlags.ReadOnly</c>, <c>ComputeMemoryFlags.WriteOnly</c> and <c>ComputeMemoryFlags.ReadWrite</c> are allowed. </param>
      <param name="textureTarget"> One of the following values: GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE. Using GL_TEXTURE_RECTANGLE for texture_target requires OpenGL 3.1. Alternatively, GL_TEXTURE_RECTANGLE_ARB may be specified if the OpenGL extension GL_ARB_texture_rectangle is supported. </param>
      <param name="mipLevel"> The mipmap level of the OpenGL 2D texture object to be used. </param>
      <param name="textureId"> The OpenGL 2D texture object id to use. </param>
      <returns> The created <see cref="T:Cloo.ComputeImage2D" />. </returns>
    </member>
    <member name="M:Cloo.ComputeImage2D.GetSupportedFormats(Cloo.ComputeContext,Cloo.ComputeMemoryFlags)">
      <summary>
            Gets a collection of supported <see cref="T:Cloo.ComputeImage2D" /><see cref="T:Cloo.ComputeImageFormat" />s in a <see cref="T:Cloo.ComputeContext" />.
            </summary>
      <param name="context"> The <see cref="T:Cloo.ComputeContext" /> for which the collection of <see cref="T:Cloo.ComputeImageFormat" />s is queried. </param>
      <param name="flags"> The <c>ComputeMemoryFlags</c> for which the collection of <see cref="T:Cloo.ComputeImageFormat" />s is queried. </param>
      <returns> The collection of the required <see cref="T:Cloo.ComputeImageFormat" />s. </returns>
    </member>
    <member name="T:Cloo.ComputeImage3D">
      <summary>
            Represents an OpenCL 3D image.
            </summary>
      <seealso cref="T:Cloo.ComputeImage" />
    </member>
    <member name="M:Cloo.ComputeImage3D.#ctor(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,Cloo.ComputeImageFormat,System.Int32,System.Int32,System.Int32,System.Int64,System.Int64,System.IntPtr)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeImage3D" />.
            </summary>
      <param name="context"> A valid <see cref="T:Cloo.ComputeContext" /> in which the <see cref="T:Cloo.ComputeImage3D" /> is created. </param>
      <param name="flags"> A bit-field that is used to specify allocation and usage information about the <see cref="T:Cloo.ComputeImage3D" />. </param>
      <param name="format"> A structure that describes the format properties of the <see cref="T:Cloo.ComputeImage3D" />. </param>
      <param name="width"> The width of the <see cref="T:Cloo.ComputeImage3D" /> in pixels. </param>
      <param name="height"> The height of the <see cref="T:Cloo.ComputeImage3D" /> in pixels. </param>
      <param name="depth"> The depth of the <see cref="T:Cloo.ComputeImage3D" /> in pixels. </param>
      <param name="rowPitch"> The size in bytes of each row of elements of the <see cref="T:Cloo.ComputeImage3D" />. If <paramref name="rowPitch" /> is zero, OpenCL will compute the proper value based on <see cref="P:Cloo.ComputeImage.Width" /> and <see cref="P:Cloo.ComputeImage.ElementSize" />. </param>
      <param name="slicePitch"> The size in bytes of each 2D slice in the <see cref="T:Cloo.ComputeImage3D" />. If <paramref name="slicePitch" /> is zero, OpenCL will compute the proper value based on <see cref="P:Cloo.ComputeImage.RowPitch" /> and <see cref="P:Cloo.ComputeImage.Height" />. </param>
      <param name="data"> The data to initialize the <see cref="T:Cloo.ComputeImage3D" />. Can be <c>IntPtr.Zero</c>. </param>
    </member>
    <member name="M:Cloo.ComputeImage3D.CreateFromGLTexture3D(Cloo.ComputeContext,Cloo.ComputeMemoryFlags,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeImage3D" /> from an OpenGL 3D texture object.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" /> with enabled CL/GL sharing. </param>
      <param name="flags"> A bit-field that is used to specify usage information about the <see cref="T:Cloo.ComputeImage3D" />. Only <c>ComputeMemoryFlags.ReadOnly</c>, <c>ComputeMemoryFlags.WriteOnly</c> and <c>ComputeMemoryFlags.ReadWrite</c> are allowed. </param>
      <param name="textureTarget"> The image type of texture. Must be GL_TEXTURE_3D. </param>
      <param name="mipLevel"> The mipmap level of the OpenGL 2D texture object to be used. </param>
      <param name="textureId"> The OpenGL 2D texture object id to use. </param>
      <returns> The created <see cref="T:Cloo.ComputeImage2D" />. </returns>
    </member>
    <member name="M:Cloo.ComputeImage3D.GetSupportedFormats(Cloo.ComputeContext,Cloo.ComputeMemoryFlags)">
      <summary>
            Gets a collection of supported <see cref="T:Cloo.ComputeImage3D" /><see cref="T:Cloo.ComputeImageFormat" />s in a <see cref="T:Cloo.ComputeContext" />.
            </summary>
      <param name="context"> The <see cref="T:Cloo.ComputeContext" /> for which the collection of <see cref="T:Cloo.ComputeImageFormat" />s is queried. </param>
      <param name="flags"> The <c>ComputeMemoryFlags</c> for which the collection of <see cref="T:Cloo.ComputeImageFormat" />s is queried. </param>
      <returns> The collection of the required <see cref="T:Cloo.ComputeImageFormat" />s. </returns>
    </member>
    <member name="T:Cloo.ComputeImageFormat">
      <summary>
            Represents an OpenCL image format.
            </summary>
      <remarks> This structure defines the type, count and size of the image channels. </remarks>
      <seealso cref="T:Cloo.ComputeImage" />
    </member>
    <member name="M:Cloo.ComputeImageFormat.#ctor(Cloo.ComputeImageChannelOrder,Cloo.ComputeImageChannelType)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeImageFormat" />.
            </summary>
      <param name="channelOrder"> The number of channels and the channel layout i.e. the memory layout in which channels are stored in the <see cref="T:Cloo.ComputeImage" />. </param>
      <param name="channelType"> The type of the channel data. The number of bits per element determined by the <paramref name="channelType" /> and <paramref name="channelOrder" /> must be a power of two. </param>
    </member>
    <member name="P:Cloo.ComputeImageFormat.ChannelOrder">
      <summary>
            Gets the <see cref="T:Cloo.ComputeImageChannelOrder" /> of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeImageChannelOrder" /> of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="P:Cloo.ComputeImageFormat.ChannelType">
      <summary>
            Gets the <see cref="T:Cloo.ComputeImageChannelType" /> of the <see cref="T:Cloo.ComputeImage" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeImageChannelType" /> of the <see cref="T:Cloo.ComputeImage" />. </value>
    </member>
    <member name="T:Cloo.ComputeKernel">
      <summary>
            Represents an OpenCL kernel.
            </summary>
      <remarks> A kernel object encapsulates a specific kernel function declared in a program and the argument values to be used when executing this kernel function. </remarks>
      <seealso cref="T:Cloo.ComputeCommandQueue" />
      <seealso cref="T:Cloo.ComputeProgram" />
    </member>
    <member name="M:Cloo.ComputeKernel.GetLocalMemorySize(Cloo.ComputeDevice)">
      <summary>
            Gets the amount of local memory in bytes used by the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <param name="device"> One of the <see cref="!:ComputeKernel.Program.Device" />s. </param>
      <returns> The amount of local memory in bytes used by the <see cref="T:Cloo.ComputeKernel" />. </returns>
    </member>
    <member name="M:Cloo.ComputeKernel.GetCompileWorkGroupSize(Cloo.ComputeDevice)">
      <summary>
            Gets the compile work-group size specified by the <c>__attribute__((reqd_work_group_size(X, Y, Z)))</c> qualifier.
            </summary>
      <param name="device"> One of the <see cref="!:ComputeKernel.Program.Device" />s. </param>
      <returns> The compile work-group size specified by the <c>__attribute__((reqd_work_group_size(X, Y, Z)))</c> qualifier. If no such qualifier is specified, (0, 0, 0) is returned. </returns>
    </member>
    <member name="M:Cloo.ComputeKernel.GetPreferredWorkGroupSizeMultiple(Cloo.ComputeDevice)">
      <summary>
            Gets the preferred multiple of workgroup size for launch. 
            </summary>
      <param name="device"> One of the <see cref="!:ComputeKernel.Program.Device" />s. </param>
      <returns> The preferred multiple of workgroup size for launch. </returns>
      <remarks> The returned value is a performance hint. Specifying a workgroup size that is not a multiple of the value returned by this query as the value of the local work size argument to ComputeCommandQueue.Execute will not fail to enqueue the kernel for execution unless the work-group size specified is larger than the device maximum. </remarks>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.GetPrivateMemorySize(Cloo.ComputeDevice)">
      <summary>
            Gets the minimum amount of memory, in bytes, used by each work-item in the kernel.
            </summary>
      <param name="device"> One of the <see cref="!:ComputeKernel.Program.Device" />s. </param>
      <returns> The minimum amount of memory, in bytes, used by each work-item in the kernel. </returns>
      <remarks> The returned value may include any private memory needed by an implementation to execute the kernel, including that used by the language built-ins and variable declared inside the kernel with the <c>__private</c> or <c>private</c> qualifier. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.GetWorkGroupSize(Cloo.ComputeDevice)">
      <summary>
            Gets the maximum work-group size that can be used to execute the <see cref="T:Cloo.ComputeKernel" /> on a <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <param name="device"> One of the <see cref="!:ComputeKernel.Program.Device" />s. </param>
      <returns> The maximum work-group size that can be used to execute the <see cref="T:Cloo.ComputeKernel" /> on <paramref name="device" />. </returns>
    </member>
    <member name="M:Cloo.ComputeKernel.SetArgument(System.Int32,System.IntPtr,System.IntPtr)">
      <summary>
            Sets an argument of the <see cref="T:Cloo.ComputeKernel" /> (no argument tracking).
            </summary>
      <param name="index"> The argument index. </param>
      <param name="dataSize"> The size of the argument data in bytes. </param>
      <param name="dataAddr"> A pointer to the data that should be used as the argument value. </param>
      <remarks> 
            Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n-1, where n is the total number of arguments declared by the kernel.
            <br />
            Note that this method does not provide argument tracking. It is up to the user to reference the kernel arguments (i.e. prevent them from being garbage collected) until the kernel has finished execution.
            </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.SetLocalArgument(System.Int32,System.Int64)">
      <summary>
            Sets the size in bytes of an argument specfied with the <c>local</c> or <c>__local</c> address space qualifier.
            </summary>
      <param name="index"> The argument index. </param>
      <param name="dataSize"> The size of the argument data in bytes. </param>
      <remarks> Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n-1, where n is the total number of arguments declared by the kernel. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.SetMemoryArgument(System.Int32,Cloo.ComputeMemory)">
      <summary>
            Sets a <c>T*</c>, <c>image2d_t</c> or <c>image3d_t</c> argument of the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <param name="index"> The argument index. </param>
      <param name="memObj"> The <see cref="T:Cloo.ComputeMemory" /> that is passed as the argument. </param>
      <remarks> This method will automatically track <paramref name="memObj" /> to prevent it from being collected by the GC.<br /> Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n-1, where n is the total number of arguments declared by the kernel. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.SetMemoryArgument(System.Int32,Cloo.Bindings.CLMemoryHandle)">
      <summary>
            Added by Hybrid DSP
            </summary>
      <param name="index">
      </param>
      <param name="memObj">
      </param>
    </member>
    <member name="M:Cloo.ComputeKernel.SetSamplerArgument(System.Int32,Cloo.ComputeSampler)">
      <summary>
            Sets a <c>sampler_t</c> argument of the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <param name="index"> The argument index. </param>
      <param name="sampler"> The <see cref="T:Cloo.ComputeSampler" /> that is passed as the argument. </param>
      <remarks> This method will automatically track <paramref name="sampler" /> to prevent it from being collected by the GC.<br /> Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n-1, where n is the total number of arguments declared by the kernel. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.SetValueArgument``1(System.Int32,``0)">
      <summary>
            Sets a value argument of the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <typeparam name="T"> The type of the argument. </typeparam>
      <param name="index"> The argument index. </param>
      <param name="data"> The data that is passed as the argument value. </param>
      <remarks> Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n-1, where n is the total number of arguments declared by the kernel. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.SetValueArgument(System.Int32,System.Int32,System.Object)">
      <summary>
            Added by Hybrid DSP. Sets a value argument of the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <typeparam name="T"> The type of the argument. </typeparam>
      <param name="index"> The argument index. </param>
      <param name="data"> The data that is passed as the argument value. </param>
      <remarks> Arguments to the kernel are referred by indices that go from 0 for the leftmost argument to n-1, where n is the total number of arguments declared by the kernel. </remarks>
    </member>
    <member name="M:Cloo.ComputeKernel.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeKernel.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeKernel.Context">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContext" /> associated with the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContext" /> associated with the <see cref="T:Cloo.ComputeKernel" />. </value>
    </member>
    <member name="P:Cloo.ComputeKernel.FunctionName">
      <summary>
            Gets the function name of the <see cref="T:Cloo.ComputeKernel" />.
            </summary>
      <value> The function name of the <see cref="T:Cloo.ComputeKernel" />. </value>
    </member>
    <member name="P:Cloo.ComputeKernel.Program">
      <summary>
            Gets the <see cref="T:Cloo.ComputeProgram" /> that the <see cref="T:Cloo.ComputeKernel" /> belongs to.
            </summary>
      <value> The <see cref="T:Cloo.ComputeProgram" /> that the <see cref="T:Cloo.ComputeKernel" /> belongs to. </value>
    </member>
    <member name="T:Cloo.ComputePlatform">
      <summary>
            Represents an OpenCL platform.
            </summary>
      <remarks> The host plus a collection of devices managed by the OpenCL framework that allow an application to share resources and execute kernels on devices in the platform. </remarks>
      <seealso cref="T:Cloo.ComputeDevice" />
      <seealso cref="T:Cloo.ComputeKernel" />
      <seealso cref="T:Cloo.ComputeResource" />
    </member>
    <member name="M:Cloo.ComputePlatform.GetByHandle(System.IntPtr)">
      <summary>
            Gets a <see cref="T:Cloo.ComputePlatform" /> of a specified handle.
            </summary>
      <param name="handle"> The handle of the queried <see cref="T:Cloo.ComputePlatform" />. </param>
      <returns> The <see cref="T:Cloo.ComputePlatform" /> of the matching handle or <c>null</c> if none matches. </returns>
    </member>
    <member name="M:Cloo.ComputePlatform.GetByName(System.String)">
      <summary>
            Gets the first matching <see cref="T:Cloo.ComputePlatform" /> of a specified name.
            </summary>
      <param name="platformName"> The name of the queried <see cref="T:Cloo.ComputePlatform" />. </param>
      <returns> The first <see cref="T:Cloo.ComputePlatform" /> of the specified name or <c>null</c> if none matches. </returns>
    </member>
    <member name="M:Cloo.ComputePlatform.GetByVendor(System.String)">
      <summary>
            Gets the first matching <see cref="T:Cloo.ComputePlatform" /> of a specified vendor.
            </summary>
      <param name="platformVendor"> The vendor of the queried <see cref="T:Cloo.ComputePlatform" />. </param>
      <returns> The first <see cref="T:Cloo.ComputePlatform" /> of the specified vendor or <c>null</c> if none matches. </returns>
    </member>
    <member name="M:Cloo.ComputePlatform.QueryDevices">
      <summary>
            Gets a read-only collection of available <see cref="T:Cloo.ComputeDevice" />s on the <see cref="T:Cloo.ComputePlatform" />.
            </summary>
      <returns> A read-only collection of the available <see cref="T:Cloo.ComputeDevice" />s on the <see cref="T:Cloo.ComputePlatform" />. </returns>
      <remarks> This method resets the <c>ComputePlatform.Devices</c>. This is useful if one or more of them become unavailable (<c>ComputeDevice.Available</c> is <c>false</c>) after a <see cref="T:Cloo.ComputeContext" /> and <see cref="T:Cloo.ComputeCommandQueue" />s that use the <see cref="T:Cloo.ComputeDevice" /> have been created and commands have been queued to them. Further calls will trigger an <c>OutOfResourcesComputeException</c> until this method is executed. You will also need to recreate any <see cref="T:Cloo.ComputeResource" /> that was created on the no longer available <see cref="T:Cloo.ComputeDevice" />. </remarks>
    </member>
    <member name="P:Cloo.ComputePlatform.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputePlatform" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputePlatform.Devices">
      <summary>
            Gets a read-only collection of <see cref="T:Cloo.ComputeDevice" />s available on the <see cref="T:Cloo.ComputePlatform" />.
            </summary>
      <value> A read-only collection of <see cref="T:Cloo.ComputeDevice" />s available on the <see cref="T:Cloo.ComputePlatform" />. </value>
    </member>
    <member name="P:Cloo.ComputePlatform.Extensions">
      <summary>
            Gets a read-only collection of extension names supported by the <see cref="T:Cloo.ComputePlatform" />.
            </summary>
      <value> A read-only collection of extension names supported by the <see cref="T:Cloo.ComputePlatform" />. </value>
    </member>
    <member name="P:Cloo.ComputePlatform.Name">
      <summary>
            Gets the <see cref="T:Cloo.ComputePlatform" /> name.
            </summary>
      <value> The <see cref="T:Cloo.ComputePlatform" /> name. </value>
    </member>
    <member name="P:Cloo.ComputePlatform.Platforms">
      <summary>
            Gets a read-only collection of available <see cref="T:Cloo.ComputePlatform" />s.
            </summary>
      <value> A read-only collection of available <see cref="T:Cloo.ComputePlatform" />s. </value>
      <remarks> The collection will contain no items, if no OpenCL platforms are found on the system. </remarks>
    </member>
    <member name="P:Cloo.ComputePlatform.Profile">
      <summary>
            Gets the name of the profile supported by the <see cref="T:Cloo.ComputePlatform" />.
            </summary>
      <value> The name of the profile supported by the <see cref="T:Cloo.ComputePlatform" />. </value>
    </member>
    <member name="P:Cloo.ComputePlatform.Vendor">
      <summary>
            Gets the <see cref="T:Cloo.ComputePlatform" /> vendor.
            </summary>
      <value> The <see cref="T:Cloo.ComputePlatform" /> vendor. </value>
    </member>
    <member name="P:Cloo.ComputePlatform.Version">
      <summary>
            Gets the OpenCL version string supported by the <see cref="T:Cloo.ComputePlatform" />.
            </summary>
      <value> The OpenCL version string supported by the <see cref="T:Cloo.ComputePlatform" />. It has the following format: <c>OpenCL[space][major_version].[minor_version][space][vendor-specific information]</c>. </value>
    </member>
    <member name="T:Cloo.ComputeProgram">
      <summary>
            Represents an OpenCL program.
            </summary>
      <remarks> An OpenCL program consists of a set of kernels. Programs may also contain auxiliary functions called by the kernel functions and constant data. </remarks>
      <seealso cref="T:Cloo.ComputeKernel" />
    </member>
    <member name="M:Cloo.ComputeProgram.#ctor(Cloo.ComputeContext,System.String)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeProgram" /> from a source code string.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="source"> The source code for the <see cref="T:Cloo.ComputeProgram" />. </param>
      <remarks> The created <see cref="T:Cloo.ComputeProgram" /> is associated with the <see cref="P:Cloo.ComputeContext.Devices" />. </remarks>
    </member>
    <member name="M:Cloo.ComputeProgram.#ctor(Cloo.ComputeContext,System.String[])">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeProgram" /> from an array of source code strings.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="source"> The source code lines for the <see cref="T:Cloo.ComputeProgram" />. </param>
      <remarks> The created <see cref="T:Cloo.ComputeProgram" /> is associated with the <see cref="P:Cloo.ComputeContext.Devices" />. </remarks>
    </member>
    <member name="M:Cloo.ComputeProgram.#ctor(Cloo.ComputeContext,System.Collections.Generic.IList{System.Byte[]},System.Collections.Generic.IList{Cloo.ComputeDevice})">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeProgram" /> from a specified list of binaries.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="binaries"> A list of binaries, one for each item in <paramref name="devices" />. </param>
      <param name="devices"> A subset of the <see cref="P:Cloo.ComputeContext.Devices" />. If <paramref name="devices" /> is <c>null</c>, OpenCL will associate every binary from <see cref="P:Cloo.ComputeProgram.Binaries" /> with a corresponding <see cref="T:Cloo.ComputeDevice" /> from <see cref="P:Cloo.ComputeContext.Devices" />. </param>
    </member>
    <member name="M:Cloo.ComputeProgram.Build(System.Collections.Generic.ICollection{Cloo.ComputeDevice},System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)">
      <summary>
            Builds (compiles and links) a program executable from the program source or binary for all or some of the <see cref="P:Cloo.ComputeProgram.Devices" />.
            </summary>
      <param name="devices"> A subset or all of <see cref="P:Cloo.ComputeProgram.Devices" />. If <paramref name="devices" /> is <c>null</c>, the executable is built for every item of <see cref="P:Cloo.ComputeProgram.Devices" /> for which a source or a binary has been loaded. </param>
      <param name="options"> A set of options for the OpenCL compiler. </param>
      <param name="notify"> A delegate instance that represents a reference to a notification routine. This routine is a callback function that an application can register and which will be called when the program executable has been built (successfully or unsuccessfully). If <paramref name="notify" /> is not <c>null</c>, <see cref="M:Cloo.ComputeProgram.Build(System.Collections.Generic.ICollection{Cloo.ComputeDevice},System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)" /> does not need to wait for the build to complete and can return immediately. If <paramref name="notify" /> is <c>null</c>, <see cref="M:Cloo.ComputeProgram.Build(System.Collections.Generic.ICollection{Cloo.ComputeDevice},System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)" /> does not return until the build has completed. The callback function may be called asynchronously by the OpenCL implementation. It is the application's responsibility to ensure that the callback function is thread-safe and that the delegate instance doesn't get collected by the Garbage Collector until the build operation triggers the callback. </param>
      <param name="notifyDataPtr"> Optional user data that will be passed to <paramref name="notify" />. </param>
    </member>
    <member name="M:Cloo.ComputeProgram.CreateAllKernels">
      <summary>
            Creates a <see cref="T:Cloo.ComputeKernel" /> for every <c>kernel</c> function in <see cref="T:Cloo.ComputeProgram" />.
            </summary>
      <returns> The collection of created <see cref="T:Cloo.ComputeKernel" />s. </returns>
      <remarks>
        <see cref="T:Cloo.ComputeKernel" />s are not created for any <c>kernel</c> functions in <see cref="T:Cloo.ComputeProgram" /> that do not have the same function definition across all <see cref="P:Cloo.ComputeProgram.Devices" /> for which a program executable has been successfully built. </remarks>
    </member>
    <member name="M:Cloo.ComputeProgram.CreateKernel(System.String)">
      <summary>
            Creates a <see cref="T:Cloo.ComputeKernel" /> for a kernel function of a specified name.
            </summary>
      <returns> The created <see cref="T:Cloo.ComputeKernel" />. </returns>
    </member>
    <member name="M:Cloo.ComputeProgram.GetBuildLog(Cloo.ComputeDevice)">
      <summary>
            Gets the build log of the <see cref="T:Cloo.ComputeProgram" /> for a specified <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <param name="device"> The <see cref="T:Cloo.ComputeDevice" /> building the <see cref="T:Cloo.ComputeProgram" />. Must be one of <see cref="P:Cloo.ComputeProgram.Devices" />. </param>
      <returns> The build log of the <see cref="T:Cloo.ComputeProgram" /> for <paramref name="device" />. </returns>
    </member>
    <member name="M:Cloo.ComputeProgram.GetBuildStatus(Cloo.ComputeDevice)">
      <summary>
            Gets the <see cref="T:Cloo.ComputeProgramBuildStatus" /> of the <see cref="T:Cloo.ComputeProgram" /> for a specified <see cref="T:Cloo.ComputeDevice" />.
            </summary>
      <param name="device"> The <see cref="T:Cloo.ComputeDevice" /> building the <see cref="T:Cloo.ComputeProgram" />. Must be one of <see cref="P:Cloo.ComputeProgram.Devices" />. </param>
      <returns> The <see cref="T:Cloo.ComputeProgramBuildStatus" /> of the <see cref="T:Cloo.ComputeProgram" /> for <paramref name="device" />. </returns>
    </member>
    <member name="M:Cloo.ComputeProgram.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeProgram.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeProgram" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeProgram.Binaries">
      <summary>
            Gets a read-only collection of program binaries associated with the <see cref="P:Cloo.ComputeProgram.Devices" />.
            </summary>
      <value> A read-only collection of program binaries associated with the <see cref="P:Cloo.ComputeProgram.Devices" />. </value>
      <remarks> The bits returned can be an implementation-specific intermediate representation (a.k.a. IR) or device specific executable bits or both. The decision on which information is returned in the binary is up to the OpenCL implementation. </remarks>
    </member>
    <member name="P:Cloo.ComputeProgram.BuildOptions">
      <summary>
            Gets the <see cref="T:Cloo.ComputeProgram" /> build options as specified in <paramref name="options" /> argument of <see cref="M:Cloo.ComputeProgram.Build(System.Collections.Generic.ICollection{Cloo.ComputeDevice},System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeProgram" /> build options as specified in <paramref name="options" /> argument of <see cref="M:Cloo.ComputeProgram.Build(System.Collections.Generic.ICollection{Cloo.ComputeDevice},System.String,Cloo.Bindings.ComputeProgramBuildNotifier,System.IntPtr)" />. </value>
    </member>
    <member name="P:Cloo.ComputeProgram.Context">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeProgram" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeProgram" />. </value>
    </member>
    <member name="P:Cloo.ComputeProgram.Devices">
      <summary>
            Gets a read-only collection of <see cref="T:Cloo.ComputeDevice" />s associated with the <see cref="T:Cloo.ComputeProgram" />.
            </summary>
      <value> A read-only collection of <see cref="T:Cloo.ComputeDevice" />s associated with the <see cref="T:Cloo.ComputeProgram" />. </value>
      <remarks> This collection is a subset of <see cref="!:ComputeProgram.Context.Devices" />. </remarks>
    </member>
    <member name="P:Cloo.ComputeProgram.Source">
      <summary>
            Gets a read-only collection of program source code strings specified when creating the <see cref="T:Cloo.ComputeProgram" /> or <c>null</c> if <see cref="T:Cloo.ComputeProgram" /> was created using program binaries.
            </summary>
      <value> A read-only collection of program source code strings specified when creating the <see cref="T:Cloo.ComputeProgram" /> or <c>null</c> if <see cref="T:Cloo.ComputeProgram" /> was created using program binaries. </value>
    </member>
    <member name="T:Cloo.ComputeSampler">
      <summary>
            Represents an OpenCL sampler.
            </summary>
      <remarks> An object that describes how to sample an image when the image is read in the kernel. The image read functions take a sampler as an argument. The sampler specifies the image addressing-mode i.e. how out-of-range image coordinates are handled, the filtering mode, and whether the input image coordinate is a normalized or unnormalized value. </remarks>
      <seealso cref="T:Cloo.ComputeImage" />
    </member>
    <member name="M:Cloo.ComputeSampler.#ctor(Cloo.ComputeContext,System.Boolean,Cloo.ComputeImageAddressing,Cloo.ComputeImageFiltering)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeSampler" />.
            </summary>
      <param name="context"> A <see cref="T:Cloo.ComputeContext" />. </param>
      <param name="normalizedCoords"> The usage state of normalized coordinates when accessing a <see cref="T:Cloo.ComputeImage" /> in a <see cref="T:Cloo.ComputeKernel" />. </param>
      <param name="addressing"> The <see cref="T:Cloo.ComputeImageAddressing" /> mode of the <see cref="T:Cloo.ComputeSampler" />. Specifies how out-of-range image coordinates are handled while reading. </param>
      <param name="filtering"> The <see cref="T:Cloo.ComputeImageFiltering" /> mode of the <see cref="T:Cloo.ComputeSampler" />. Specifies the type of filter that must be applied when reading data from an image. </param>
    </member>
    <member name="M:Cloo.ComputeSampler.Dispose(System.Boolean)">
      <summary>
            Releases the associated OpenCL object.
            </summary>
      <param name="manual"> Specifies the operation mode of this method. </param>
      <remarks>
        <paramref name="manual" /> must be <c>true</c> if this method is invoked directly by the application. </remarks>
    </member>
    <member name="P:Cloo.ComputeSampler.Handle">
      <summary>
            The handle of the <see cref="T:Cloo.ComputeSampler" />.
            </summary>
    </member>
    <member name="P:Cloo.ComputeSampler.Context">
      <summary>
            Gets the <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeSampler" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeContext" /> of the <see cref="T:Cloo.ComputeSampler" />. </value>
    </member>
    <member name="P:Cloo.ComputeSampler.Addressing">
      <summary>
            Gets the <see cref="T:Cloo.ComputeImageAddressing" /> mode of the <see cref="T:Cloo.ComputeSampler" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeImageAddressing" /> mode of the <see cref="T:Cloo.ComputeSampler" />. </value>
    </member>
    <member name="P:Cloo.ComputeSampler.Filtering">
      <summary>
            Gets the <see cref="T:Cloo.ComputeImageFiltering" /> mode of the <see cref="T:Cloo.ComputeSampler" />.
            </summary>
      <value> The <see cref="T:Cloo.ComputeImageFiltering" /> mode of the <see cref="T:Cloo.ComputeSampler" />. </value>
    </member>
    <member name="P:Cloo.ComputeSampler.NormalizedCoords">
      <summary>
            Gets the state of usage of normalized x, y and z coordinates when accessing a <see cref="T:Cloo.ComputeImage" /> in a <see cref="T:Cloo.ComputeKernel" /> through the <see cref="T:Cloo.ComputeSampler" />.
            </summary>
      <value> The state of usage of normalized x, y and z coordinates when accessing a <see cref="T:Cloo.ComputeImage" /> in a <see cref="T:Cloo.ComputeKernel" /> through the <see cref="T:Cloo.ComputeSampler" />. </value>
    </member>
    <member name="T:Cloo.ComputeSubBuffer`1">
      <summary>
            Represents an OpenCL sub-buffer.
            </summary>
      <typeparam name="T"> The type of the elements of the <see cref="T:Cloo.ComputeSubBuffer`1" />. <typeparamref name="T" /> is restricted to value types and <c>struct</c>s containing such types. </typeparam>
      <remarks> A sub-buffer is created from a standard buffer and represents all or part of its data content. <br /> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeSubBuffer`1.#ctor(Cloo.ComputeBuffer{`0},Cloo.ComputeMemoryFlags,System.Int64,System.Int64)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeSubBuffer`1" /> from a specified <see cref="T:Cloo.ComputeBuffer`1" />.
            </summary>
      <param name="buffer"> The buffer to create the <see cref="T:Cloo.ComputeSubBuffer`1" /> from. </param>
      <param name="flags"> A bit-field that is used to specify allocation and usage information about the <see cref="T:Cloo.ComputeBuffer`1" />. </param>
      <param name="offset"> The index of the element of <paramref name="buffer" />, where the <see cref="T:Cloo.ComputeSubBuffer`1" /> starts. </param>
      <param name="count"> The number of elements of <paramref name="buffer" /> to include in the <see cref="T:Cloo.ComputeSubBuffer`1" />. </param>
    </member>
    <member name="T:Cloo.ComputeUserEvent">
      <summary>
            Represents an user created event.
            </summary>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeUserEvent.#ctor(Cloo.ComputeContext)">
      <summary>
            Creates a new <see cref="T:Cloo.ComputeUserEvent" />.
            </summary>
      <param name="context"> The <see cref="T:Cloo.ComputeContext" /> in which the <see cref="T:Cloo.ComputeUserEvent" /> is created. </param>
      <remarks> Requires OpenCL 1.1. </remarks>
    </member>
    <member name="M:Cloo.ComputeUserEvent.SetStatus(Cloo.ComputeCommandExecutionStatus)">
      <summary>
            Sets the new status of the <see cref="T:Cloo.ComputeUserEvent" />.
            </summary>
      <param name="status"> The new status of the <see cref="T:Cloo.ComputeUserEvent" />. Allowed value is <see cref="F:Cloo.ComputeCommandExecutionStatus.Complete" />. </param>
    </member>
    <member name="M:Cloo.ComputeUserEvent.SetStatus(System.Int32)">
      <summary>
            Sets the new status of the <see cref="T:Cloo.ComputeUserEvent" /> to an error value.
            </summary>
      <param name="status"> The error status of the <see cref="T:Cloo.ComputeUserEvent" />. This should be a negative value. </param>
    </member>
    <member name="M:Cloo.HDSPUtils.SizeOf(System.Type)">
      <summary>
            Gets the size of the type specified. Note that this differs from Marshal.SizeOf for System.Char (it returns 2 instead of 1).
            </summary>
      <param name="t">The type to get the size of.</param>
      <returns>Size of type in bytes.</returns>
    </member>
    <member name="T:Cloo.SysIntX2">
      <summary>
            A structure of two integers of platform specific size.
             </summary>
    </member>
    <member name="F:Cloo.SysIntX2.X">
      <summary>
            The first coordinate.
            </summary>
    </member>
    <member name="F:Cloo.SysIntX2.Y">
      <summary>
            The second coordinate.
            </summary>
    </member>
    <member name="M:Cloo.SysIntX2.#ctor(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
    </member>
    <member name="M:Cloo.SysIntX2.#ctor(System.Int64,System.Int64)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
    </member>
    <member name="M:Cloo.SysIntX2.#ctor(System.IntPtr,System.IntPtr)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
    </member>
    <member name="M:Cloo.SysIntX2.ToString">
      <summary>
            Gets the string representation of the SysIntX2.
            </summary>
      <returns> The string representation of the SysIntX2. </returns>
    </member>
    <member name="T:Cloo.SysIntX3">
      <summary>
            A structure of three integers of platform specific size.
            </summary>
    </member>
    <member name="F:Cloo.SysIntX3.X">
      <summary>
            The first coordinate.
            </summary>
    </member>
    <member name="F:Cloo.SysIntX3.Y">
      <summary>
            The second coordinate.
            </summary>
    </member>
    <member name="F:Cloo.SysIntX3.Z">
      <summary>
            The third coordinate.
            </summary>
    </member>
    <member name="M:Cloo.SysIntX3.#ctor(Cloo.SysIntX2,System.Int64)">
      <summary>
      </summary>
      <param name="x2">
      </param>
      <param name="z">
      </param>
    </member>
    <member name="M:Cloo.SysIntX3.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="z">
      </param>
    </member>
    <member name="M:Cloo.SysIntX3.#ctor(System.Int64,System.Int64,System.Int64)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="z">
      </param>
    </member>
    <member name="M:Cloo.SysIntX3.#ctor(System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="z">
      </param>
    </member>
    <member name="M:Cloo.SysIntX3.ToString">
      <summary>
            Gets the string representation of the SysIntX2.
            </summary>
      <returns> The string representation of the SysIntX2. </returns>
    </member>
    <member name="T:Cloo.ComputeTools">
      <summary>
            Contains various helper methods.
            </summary>
    </member>
    <member name="M:Cloo.ComputeTools.ParseVersionString(System.String,System.Int32)">
      <summary>
            Parses an OpenCL version string.
            </summary>
      <param name="versionString"> The version string to parse. Must be in the format: <c>Additional substrings[space][major_version].[minor_version][space]Additional substrings</c>. </param>
      <param name="substringIndex"> The index of the substring that specifies the OpenCL version. </param>
      <returns> A <c>Version</c> instance containing the major and minor version from <paramref name="versionString" />. </returns>
    </member>
    <member name="T:Cloo.ComputeErrorCode">
      <summary>
            The OpenCL error codes.
            </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.Success">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.DeviceNotFound">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.DeviceNotAvailable">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.CompilerNotAvailable">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.MemoryObjectAllocationFailure">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.OutOfResources">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.OutOfHostMemory">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.ProfilingInfoNotAvailable">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.MemoryCopyOverlap">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.ImageFormatMismatch">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.ImageFormatNotSupported">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.BuildProgramFailure">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.MapFailure">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.MisalignedSubBufferOffset">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.ExecutionStatusErrorForEventsInWaitList">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidValue">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidDeviceType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidPlatform">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidDevice">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidContext">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidCommandQueueFlags">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidCommandQueue">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidHostPointer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidMemoryObject">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidImageFormatDescriptor">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidImageSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidSampler">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidBinary">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidBuildOptions">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidProgram">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidProgramExecutable">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidKernelName">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidKernelDefinition">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidKernel">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidArgumentIndex">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidArgumentValue">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidArgumentSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidKernelArguments">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidWorkDimension">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidWorkGroupSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidWorkItemSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidGlobalOffset">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidEventWaitList">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidEvent">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidOperation">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidGLObject">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidBufferSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidMipLevel">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.InvalidGlobalWorkSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.CL_PLATFORM_NOT_FOUND_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.CL_DEVICE_PARTITION_FAILED_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.CL_INVALID_PARTITION_COUNT_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeErrorCode.CL_INVALID_PARTITION_NAME_EXT">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.OpenCLVersion">
      <summary>
            The OpenCL version.
            </summary>
    </member>
    <member name="F:Cloo.OpenCLVersion.Version_1_0">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.OpenCLVersion.Version_1_1">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeBoolean">
      <summary>
            The OpenCL boolean values expressed as integers.
            </summary>
    </member>
    <member name="F:Cloo.ComputeBoolean.False">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeBoolean.True">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputePlatformInfo">
      <summary>
            The platform info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputePlatformInfo.Profile">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputePlatformInfo.Version">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputePlatformInfo.Name">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputePlatformInfo.Vendor">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputePlatformInfo.Extensions">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputePlatformInfo.CL_PLATFORM_ICD_SUFFIX_KHR">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeDeviceTypes">
      <summary>
            The types of devices.
            </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceTypes.Default">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceTypes.Cpu">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceTypes.Gpu">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceTypes.Accelerator">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceTypes.All">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeDeviceInfo">
      <summary>
            The device info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Type">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.VendorId">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxComputeUnits">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxWorkItemDimensions">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxWorkGroupSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxWorkItemSizes">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthChar">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthShort">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthInt">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthLong">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthFloat">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthDouble">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxClockFrequency">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.AddressBits">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxReadImageArguments">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxWriteImageArguments">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxMemoryAllocationSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Image2DMaxWidth">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Image2DMaxHeight">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Image3DMaxWidth">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Image3DMaxHeight">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Image3DMaxDepth">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.ImageSupport">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxParameterSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxSamplers">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MemoryBaseAddressAlignment">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MinDataTypeAlignmentSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.SingleFPConfig">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.GlobalMemoryCacheType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.GlobalMemoryCachelineSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.GlobalMemoryCacheSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.GlobalMemorySize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxConstantBufferSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.MaxConstantArguments">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.LocalMemoryType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.LocalMemorySize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.ErrorCorrectionSupport">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.ProfilingTimerResolution">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.EndianLittle">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Available">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CompilerAvailable">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.ExecutionCapabilities">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CommandQueueProperties">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Name">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Vendor">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.DriverVersion">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Profile">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Version">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Extensions">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.Platform">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_DOUBLE_FP_CONFIG">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_HALF_FP_CONFIG">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.PreferredVectorWidthHalf">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.HostUnifiedMemory">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthChar">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthShort">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthInt">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthLong">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthFloat">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthDouble">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.NativeVectorWidthHalf">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.OpenCLCVersion">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_PARENT_DEVICE_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_PARITION_TYPES_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_AFFINITY_DOMAINS_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_REFERENCE_COUNT_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceInfo.CL_DEVICE_PARTITION_STYLE_EXT">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeDeviceSingleCapabilities">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.Denorm">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.InfNan">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.RoundToNearest">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.RoundToZero">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.RoundToInf">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.Fma">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceSingleCapabilities.SoftFloat">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeDeviceMemoryCacheType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceMemoryCacheType.None">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceMemoryCacheType.ReadOnlyCache">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceMemoryCacheType.ReadWriteCache">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeDeviceLocalMemoryType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceLocalMemoryType.Local">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceLocalMemoryType.Global">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeDeviceExecutionCapabilities">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceExecutionCapabilities.OpenCLKernel">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeDeviceExecutionCapabilities.NativeKernel">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeCommandQueueFlags">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueFlags.None">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueFlags.OutOfOrderExecution">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueFlags.Profiling">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeContextInfo">
      <summary>
            The context info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeContextInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextInfo.Devices">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextInfo.Properties">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextInfo.NumDevices">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextInfo.Platform">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeContextPropertyName">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextPropertyName.Platform">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextPropertyName.CL_GL_CONTEXT_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextPropertyName.CL_EGL_DISPLAY_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextPropertyName.CL_GLX_DISPLAY_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextPropertyName.CL_WGL_HDC_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeContextPropertyName.CL_CGL_SHAREGROUP_KHR">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeCommandQueueInfo">
      <summary>
            The command queue info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueInfo.Context">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueInfo.Device">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandQueueInfo.Properties">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeMemoryFlags">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.None">
      <summary> Let the OpenCL choose the default flags. </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.ReadWrite">
      <summary> The <see cref="T:Cloo.ComputeMemory" /> will be accessible from the <see cref="T:Cloo.ComputeKernel" /> for read and write operations. </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.WriteOnly">
      <summary> The <see cref="T:Cloo.ComputeMemory" /> will be accessible from the <see cref="T:Cloo.ComputeKernel" /> for write operations only. </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.ReadOnly">
      <summary> The <see cref="T:Cloo.ComputeMemory" /> will be accessible from the <see cref="T:Cloo.ComputeKernel" /> for read operations only. </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.UseHostPointer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.AllocateHostPointer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryFlags.CopyHostPointer">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeImageChannelOrder">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.R">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.A">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.RG">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.RA">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Rgb">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Rgba">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Bgra">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Argb">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Intensity">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Luminance">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Rx">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Rgx">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelOrder.Rgbx">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeImageChannelType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.SNormInt8">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.SNormInt16">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UNormInt8">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UNormInt16">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UNormShort565">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UNormShort555">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UNormInt101010">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.SignedInt8">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.SignedInt16">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.SignedInt32">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UnsignedInt8">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UnsignedInt16">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.UnsignedInt32">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.HalfFloat">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageChannelType.Float">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeMemoryType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryType.Buffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryType.Image2D">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryType.Image3D">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeMemoryInfo">
      <summary>
            The memory info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.Type">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.Flags">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.Size">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.HostPointer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.MapppingCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.Context">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.AssociatedMemoryObject">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryInfo.Offset">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeImageInfo">
      <summary>
            The image info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.Format">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.ElementSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.RowPitch">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.SlicePitch">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.Width">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.Height">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageInfo.Depth">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeImageAddressing">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageAddressing.None">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageAddressing.ClampToEdge">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageAddressing.Clamp">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageAddressing.Repeat">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageAddressing.MirroredRepeat">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeImageFiltering">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageFiltering.Nearest">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeImageFiltering.Linear">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeSamplerInfo">
      <summary>
            The sampler info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeSamplerInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeSamplerInfo.Context">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeSamplerInfo.NormalizedCoords">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeSamplerInfo.Addressing">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeSamplerInfo.Filtering">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeMemoryMappingFlags">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryMappingFlags.Read">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeMemoryMappingFlags.Write">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeProgramInfo">
      <summary>
            The program info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.Context">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.DeviceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.Devices">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.Source">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.BinarySizes">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramInfo.Binaries">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeProgramBuildInfo">
      <summary>
            The program build info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildInfo.Status">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildInfo.Options">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildInfo.BuildLog">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeProgramBuildStatus">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildStatus.Success">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildStatus.None">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildStatus.Error">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeProgramBuildStatus.InProgress">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeKernelInfo">
      <summary>
            The kernel info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeKernelInfo.FunctionName">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelInfo.ArgumentCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelInfo.Context">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelInfo.Program">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeKernelWorkGroupInfo">
      <summary>
            The kernel work-group info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeKernelWorkGroupInfo.WorkGroupSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelWorkGroupInfo.CompileWorkGroupSize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelWorkGroupInfo.LocalMemorySize">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelWorkGroupInfo.PreferredWorkGroupSizeMultiple">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeKernelWorkGroupInfo.PrivateMemorySize">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeEventInfo">
      <summary>
            The event info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeEventInfo.CommandQueue">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeEventInfo.CommandType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeEventInfo.ReferenceCount">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeEventInfo.ExecutionStatus">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeEventInfo.Context">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeCommandType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.NDRangeKernel">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.Task">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.NativeKernel">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.ReadBuffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.WriteBuffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.CopyBuffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.ReadImage">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.WriteImage">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.CopyImage">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.CopyImageToBuffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.CopyBufferToImage">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.MapBuffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.MapImage">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.UnmapMemory">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.Marker">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.AcquireGLObjects">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.ReleaseGLObjects">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.ReadBufferRectangle">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.WriteBufferRectangle">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.CopyBufferRectangle">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.User">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandType.CL_COMMAND_MIGRATE_MEM_OBJECT_EXT">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeCommandExecutionStatus">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandExecutionStatus.Complete">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandExecutionStatus.Running">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandExecutionStatus.Submitted">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandExecutionStatus.Queued">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeBufferCreateType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeBufferCreateType.Region">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeCommandProfilingInfo">
      <summary>
            The command profiling info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeCommandProfilingInfo.Queued">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandProfilingInfo.Submitted">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandProfilingInfo.Started">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeCommandProfilingInfo.Ended">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeGLObjectType">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeGLObjectType.Buffer">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeGLObjectType.Texture2D">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeGLObjectType.Texture3D">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeGLObjectType.Renderbuffer">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeGLTextureInfo">
      <summary>
            The shared CL/GL image/texture info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeGLTextureInfo.TextureTarget">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeGLTextureInfo.MipMapLevel">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.ComputeGLContextInfo">
      <summary>
            The shared CL/GL context info query symbols.
            </summary>
    </member>
    <member name="F:Cloo.ComputeGLContextInfo.CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.ComputeGLContextInfo.CL_DEVICES_FOR_GL_CONTEXT_KHR">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.cl_device_partition_property_ext">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_DEVICE_PARTITION_EQUALLY_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_DEVICE_PARTITION_BY_COUNTS_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_DEVICE_PARTITION_BY_NAMES_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_AFFINITY_DOMAIN_L1_CACHE_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_AFFINITY_DOMAIN_L2_CACHE_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_AFFINITY_DOMAIN_L3_CACHE_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_AFFINITY_DOMAIN_L4_CACHE_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_AFFINITY_DOMAIN_NUMA_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_AFFINITY_DOMAIN_NEXT_FISSIONABLE_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_PROPERTIES_LIST_END_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_PARTITION_BY_COUNTS_LIST_END_EXT">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_device_partition_property_ext.CL_PARTITION_BY_NAMES_LIST_END_EXT">
      <summary>
      </summary>
    </member>
    <member name="T:Cloo.cl_mem_migration_flags_ext">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_mem_migration_flags_ext.None">
      <summary>
      </summary>
    </member>
    <member name="F:Cloo.cl_mem_migration_flags_ext.CL_MIGRATE_MEM_OBJECT_HOST_EXT">
      <summary>
      </summary>
    </member>
    <member name="T:Cudafy.CudafyAttribute">
      <summary>
            Static methods, static fields and structures to be converted to CUDA C should be decorated with this attribute.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyAttribute" /> class with type set to eCudafyType.Auto.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyAttribute.#ctor(Cudafy.eCudafyType)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="P:Cudafy.CudafyAttribute.CudafyType">
      <summary>
            Gets the type of the cudafy attribute.
            </summary>
      <value>
            The type of the cudafy.
            </value>
    </member>
    <member name="T:Cudafy.CudafyDummyAttribute">
      <summary>
            Methods, structures and fields that already have an equivalent in Cuda C should be decorated with this attribute.
            The item should have the same name and be in a CUDA C (.cu) file of the same name unless specified.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyDummyAttribute.#ctor(Cudafy.eCudafyType,Cudafy.eCudafyDummyBehaviour)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyDummyAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="behaviour">If set to Suppress then do not include CUDA C file of the same name.</param>
    </member>
    <member name="M:Cudafy.CudafyDummyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyDummyAttribute" /> class.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyDummyAttribute.CudafyType">
      <summary>
            Gets the type of the cudafy attribute.
            </summary>
      <value>
            The type of the cudafy.
            </value>
    </member>
    <member name="P:Cudafy.CudafyDummyAttribute.Behaviour">
      <summary>
            Gets the behaviour.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyDummyAttribute.SupportsEmulation">
      <summary>
            Gets a value indicating whether supports emulation.
            </summary>
      <value>
        <c>true</c> if supports emulation; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.CudafyIgnoreAttribute">
      <summary>
            Informs the CudafyTranslator to ignore the member of a struct.
            </summary>
    </member>
    <member name="T:Cudafy.CudafyAddressSpaceAttribute">
      <summary>
            Placed on parameters to indicate the OpenCL address space. Note that if not specified then arrays will
            automatically be marked global. Ignored when translating to CUDA.
            </summary>
    </member>
    <member name="T:Cudafy.CudafyInlineAttribute">
      <summary>
            Optionally placed on methods to indicate whether the method should be inlined or not.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyInlineAttribute.#ctor(Cudafy.eCudafyInlineMode)">
      <summary>
            Constructor.
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="P:Cudafy.CudafyInlineAttribute.Mode">
      <summary>
            Gets the inline mode.
            </summary>
    </member>
    <member name="T:Cudafy.Compilers.ICompilerOptions">
      <summary>
            Interface for options.
            </summary>
    </member>
    <member name="T:Cudafy.Compilers.CompilerOptions">
      <summary>
            Abstract base class for options.
            </summary>
    </member>
    <member name="F:Cudafy.Compilers.CompilerOptions._canEdit">
      <summary>
            Can edit.
            </summary>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.#ctor(System.String,System.String,System.String,System.Version,Cudafy.ePlatform)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Compilers.CompilerOptions" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="compilerPath">The compiler path.</param>
      <param name="includeDirectory">The include directory.</param>
      <param name="compilerVersion">Compiler/toolkit version (e.g. CUDA V5.0).</param>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.GetFileName">
      <summary>
            Gets the name of the compiler file.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.AddOption(System.String)">
      <summary>
            Adds an option.
            </summary>
      <param name="opt">The opt.</param>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.ClearOptions">
      <summary>
            Clears the options.
            </summary>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.AddSource(System.String)">
      <summary>
            Adds a source.
            </summary>
      <param name="src">The source file.</param>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.ClearSources">
      <summary>
            Clears the sources.
            </summary>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.AddOutput(System.String)">
      <summary>
            Adds an output.
            </summary>
      <param name="output">The output file.</param>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.ClearOutputs">
      <summary>
            Clears the outputs.
            </summary>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.GetArguments">
      <summary>
            Gets the arguments.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.TryTest">
      <summary>
            Checks if include directory exists.
            </summary>
      <returns>True if exists, else false.</returns>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.Test">
      <summary>
            Checks if include directory exists.
            </summary>
      <exception cref="T:Cudafy.CudafyCompileException">File or directory not found.</exception>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Cudafy.Compilers.CompilerOptions.GetSummary">
      <summary>
            Gets the summary.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Name">
      <summary>
            Gets the name.
            </summary>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.CompilerPath">
      <summary>
            Gets or sets the compiler path.
            </summary>
      <value>
            The compiler path.
            </value>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Platform">
      <summary>
            Gets the platform.
            </summary>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Architecture">
      <summary>
            Gets the architecture.
            </summary>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.GenerateDebugInfo">
      <summary>
            Gets or sets a value indicating whether to generate debug info.
            </summary>
      <value>
        <c>true</c> if generate debug info; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Include">
      <summary>
            Gets or sets the include path.
            </summary>
      <value>
            The include path.
            </value>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Version">
      <summary>
            Gets the version of the compiler.
            </summary>
      <value>
            The version.
            </value>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Options">
      <summary>
            Gets the options.
            </summary>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Sources">
      <summary>
            Gets the sources.
            </summary>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.Outputs">
      <summary>
            Gets the outputs.
            </summary>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.CanEdit">
      <summary>
            Gets or sets a value indicating whether this instance can edit.
            </summary>
      <value>
        <c>true</c> if this instance can edit; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.TimeOut">
      <summary>
            Gets or sets the time out for compilation.
            </summary>
      <value>
            The time out in milliseconds.
            </value>
    </member>
    <member name="P:Cudafy.Compilers.CompilerOptions.CompileMode">
      <summary>
            Gets a flag indicating whether the compiler generates binary.
            </summary>
    </member>
    <member name="T:Cudafy.Compilers.NvccCompilerOptions">
      <summary>
            Compiler options.
            </summary>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Compilers.NvccCompilerOptions" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.#ctor(System.String,System.String,System.String,System.Version,Cudafy.ePlatform)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Compilers.NvccCompilerOptions" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="compiler">The compiler.</param>
      <param name="includeDirectory">The include directory.</param>
      <param name="compilerVersion">Compiler/toolkit version (e.g. CUDA V5.0).</param>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.GetArguments">
      <summary>
            Gets the arguments.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Create">
      <summary>
            Creates a default x86 instance. Architecture is 1.2.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Createx86">
      <summary>
            Creates a default x86 instance. Architecture is 1.2.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Createx86(Cudafy.eArchitecture)">
      <summary>
            Creates a default x86 instance for specified architecture.
            </summary>
      <param name="arch">The architecture.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Createx86(System.Version,Cudafy.eArchitecture)">
      <summary>
            Creates a compiler instance for creating 32-bit apps.
            </summary>
      <param name="cudaVersion">The cuda version.</param>
      <param name="arch">Architecture.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Createx64">
      <summary>
            Creates a default x64 instance. Architecture is 1.2.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Createx64(Cudafy.eArchitecture)">
      <summary>
            Creates a default x64 instance for specified architecture.
            </summary>
      <param name="arch">The architecture.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Compilers.NvccCompilerOptions.Createx64(System.Version,Cudafy.eArchitecture)">
      <summary>
            Creates a compiler instance for creating 64-bit apps.
            </summary>
      <param name="cudaVersion">The cuda version or null for auto.</param>
      <param name="arch">Architecture.</param>
      <returns>
      </returns>
      <exception cref="T:System.NotSupportedException">ProgramFilesx64 not found.</exception>
    </member>
    <member name="P:Cudafy.CompileProperties.TimeOut">
      <summary>
            Gets or sets the time out for compilation.
            </summary>
      <value>
            The time out in milliseconds.
            </value>
    </member>
    <member name="P:Cudafy.ProgramModule.TimeOut">
      <summary>
            Gets or sets the time out for compilation.
            </summary>
      <value>
            The time out in milliseconds.
            </value>
    </member>
    <member name="T:Cudafy.dim3">
      <summary>
            Cudafy equivalent of Cuda dim3.
            </summary>
    </member>
    <member name="M:Cudafy.dim3.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.dim3" /> class. Y and z will be 1.
            </summary>
      <param name="x">The x value.</param>
    </member>
    <member name="M:Cudafy.dim3.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.dim3" /> class. Z will be 1.
            </summary>
      <param name="x">The x value.</param>
      <param name="y">The y value.</param>
    </member>
    <member name="M:Cudafy.dim3.#ctor(System.Int64[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.dim3" /> class.
            </summary>
      <param name="dimensions">The dimensions.</param>
    </member>
    <member name="M:Cudafy.dim3.#ctor(System.Int64,System.Int64,System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.dim3" /> class.
            </summary>
      <param name="x">The x value.</param>
      <param name="y">The y value.</param>
      <param name="z">The z value.</param>
    </member>
    <member name="M:Cudafy.dim3.ToArray">
      <summary>
            Helper method to transform into an array of dimension sizes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.dim3.op_Implicit(System.Int32)~Cudafy.dim3">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Cudafy.dim3" />.
            </summary>
      <param name="dimX">The dim X.</param>
      <returns>
            The result of the conversion.
            </returns>
    </member>
    <member name="P:Cudafy.dim3.x">
      <summary>
            Gets the x.
            </summary>
    </member>
    <member name="P:Cudafy.dim3.y">
      <summary>
            Gets the y.
            </summary>
    </member>
    <member name="P:Cudafy.dim3.z">
      <summary>
            Gets the z.
            </summary>
    </member>
    <member name="T:Cudafy.eGPUType">
      <summary>
            GPU target type.
            </summary>
    </member>
    <member name="F:Cudafy.eGPUType.Emulator">
      <summary>
            Target GPU kernel emulator.
            </summary>
    </member>
    <member name="F:Cudafy.eGPUType.Cuda">
      <summary>
            Target a Cuda GPU.
            </summary>
    </member>
    <member name="F:Cudafy.eGPUType.OpenCL">
      <summary>
            Target an OpenCL Device
            </summary>
    </member>
    <member name="T:Cudafy.eLanguage">
      <summary>
            Language type.
            </summary>
    </member>
    <member name="F:Cudafy.eLanguage.Cuda">
      <summary>
            NVIDIA CUDA C
            </summary>
    </member>
    <member name="F:Cudafy.eLanguage.OpenCL">
      <summary>
            OpenCL C
            </summary>
    </member>
    <member name="T:Cudafy.eCudafyQuickMode">
      <summary>
            High level enumerator encapsulation eGPUType and eGPUCodeGenerator.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyQuickMode.CudaEmulate">
      <summary>
            Cuda emulator.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyQuickMode.Cuda">
      <summary>
            Cuda.
            </summary>
    </member>
    <member name="T:Cudafy.CudafyModes">
      <summary>
            Convenience class for storing device settings.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyModes.Target">
      <summary>
            Target GPU.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyModes.Compiler">
      <summary>
            Target compiler.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyModes.Architecture">
      <summary>
            Target architecture.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyModes.Language">
      <summary>
            Language
            </summary>
    </member>
    <member name="F:Cudafy.CudafyModes.Mode">
      <summary>
            Quick mode.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyModes.csCRCWARNING">
      <summary>
            Warning message if CRC check fails.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModes.DeviceId">
      <summary>
            Gets or sets the device id.
            </summary>
      <value>
            The device id.
            </value>
    </member>
    <member name="T:Cudafy.eCudafyType">
      <summary>
            Enumerator for the type of CudafyAttribute.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyType.Auto">
      <summary>
            Auto. The code generator will determine it.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyType.Device">
      <summary>
            Used to indicate a method that should be made into a Cuda C device function.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyType.Global">
      <summary>
            Used to indicate a method that should be made into a Cuda C global function.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyType.Struct">
      <summary>
            Used to indicate a structure that should be converted to Cuda C.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyType.Constant">
      <summary>
            Used to indicate a static field that should be converted to Cuda C.
            </summary>
    </member>
    <member name="T:Cudafy.ePlatform">
      <summary>
            Target platform.
            </summary>
    </member>
    <member name="F:Cudafy.ePlatform.Auto">
      <summary>
            None selected.
            </summary>
    </member>
    <member name="F:Cudafy.ePlatform.x86">
      <summary>
            x86
            </summary>
    </member>
    <member name="F:Cudafy.ePlatform.x64">
      <summary>
            x64
            </summary>
    </member>
    <member name="F:Cudafy.ePlatform.All">
      <summary>
            Both x86 and x64
            </summary>
    </member>
    <member name="T:Cudafy.eArchitecture">
      <summary>
            CUDA or OpenCL Architecture
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.Unknown">
      <summary>
            Unspecified architecture.
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.Emulator">
      <summary>
            CUDA Emulator
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_10">
      <summary>
            CUDA sm_10
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_11">
      <summary>
            CUDA sm_11
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_12">
      <summary>
            CUDA sm_12
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_13">
      <summary>
            CUDA sm_13
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_20">
      <summary>
            CUDA sm_20
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_21">
      <summary>
            CUDA sm_21
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_30">
      <summary>
            CUDA sm_30
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_35">
      <summary>
            CUDA sm_35
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_37">
      <summary>
            CUDA sm_37
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_50">
      <summary>
            CUDA sm_50
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.sm_52">
      <summary>
            CUDA sm_52
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.OpenCL">
      <summary>
            OpenCL 1.0
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.OpenCL11">
      <summary>
            OpenCL 1.1
            </summary>
    </member>
    <member name="F:Cudafy.eArchitecture.OpenCL12">
      <summary>
            OpenCL 1.2
            </summary>
    </member>
    <member name="T:Cudafy.eCudafyAddressSpace">
      <summary>
            OpenCL address space 
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyAddressSpace.None">
      <summary>
            Prevent automatic placement of an address space qualifier.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyAddressSpace.Global">
      <summary>
            Variable is in global memory.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyAddressSpace.Constant">
      <summary>
            Variable is in constant memory.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyAddressSpace.Shared">
      <summary>
            Variable is in shared (local) memory.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyAddressSpace.Private">
      <summary>
            Variable is in private/register memory.
            </summary>
    </member>
    <member name="T:Cudafy.eCudafyDummyBehaviour">
      <summary>
            Use to specify the behaviour of the CudafyDummyAttribute.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyDummyBehaviour.Default">
      <summary>
            Default
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyDummyBehaviour.SuppressInclude">
      <summary>
            Do not write the include statements for dummy types in the generated CUDA C file.
            </summary>
    </member>
    <member name="T:Cudafy.eCudafyCompileMode">
      <summary>
            Controls the type of compilation.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyCompileMode.Default">
      <summary>
            Default (PTX for CUDA). You will get a module for a minimum architecture.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyCompileMode.Binary">
      <summary>
            Binary (cubin for CUDA). You will get a module for a specific architecture.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyCompileMode.DynamicParallelism">
      <summary>
            Binary (cubin for CUDA) and includes relevant library files.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyCompileMode.TranslateOnly">
      <summary>
            Translate but do not compile.
            </summary>
    </member>
    <member name="T:Cudafy.eCudafyInlineMode">
      <summary>
            Controls the inline type.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyInlineMode.Auto">
      <summary>
            Default - let the compiler choose.
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyInlineMode.No">
      <summary>
            __noinline__
            </summary>
    </member>
    <member name="F:Cudafy.eCudafyInlineMode.Force">
      <summary>
            __forceinline__
            </summary>
    </member>
    <member name="T:Cudafy.GES">
      <summary>
            General Error Strings (GES).
            </summary>
    </member>
    <member name="F:Cudafy.GES.csELEMENT_X_NOT_FOUND">
      <summary>
            Element '{0}' not found.
            </summary>
    </member>
    <member name="F:Cudafy.GES.csATTRIBUTE_X_NOT_FOUND">
      <summary>
            Attribute '{0}' not found.
            </summary>
    </member>
    <member name="F:Cudafy.GES.NOT_IMPLEMENTED">
      <summary>
            {0} is not yet implemented!
            </summary>
    </member>
    <member name="F:Cudafy.GES.BINARY_STRING_LEN_ERR">
      <summary>
            Binary input string must be 32 characters long.
            </summary>
    </member>
    <member name="F:Cudafy.GES.BINARY_STRING_FORMAT_ERR">
      <summary>
            Unexpected character '{0}' found in binary input string.
            </summary>
    </member>
    <member name="F:Cudafy.GES.COULD_NOT_FIND_REQ_PARAM">
      <summary>
            Could not find required parameter '{0}'.
            </summary>
    </member>
    <member name="F:Cudafy.GES.ILLEGAL_VALUE_FOR_PARAM">
      <summary>
            Illegal value '{0}' for parameter '{1}'.
            </summary>
    </member>
    <member name="F:Cudafy.GES.EXCEP_CAUGHT_BY">
      <summary>
            Exception '{0}' caught by '{1}'.
            </summary>
    </member>
    <member name="F:Cudafy.GES.BASESTREAM_NOT_SET_FOR_X">
      <summary>
            Basestream not set for '{0}'.
            </summary>
    </member>
    <member name="F:Cudafy.GES.FILE_X_NOT_FOUND_FOR_X">
      <summary>
            File '{0}' not found for '{1}'.
            </summary>
    </member>
    <member name="F:Cudafy.GES.csATTRIBUTE_X_NOT_FOUND_FOR_NODE_X">
      <summary>
            Attribute '{0}' not found for node '{1}'.
            </summary>
    </member>
    <member name="F:Cudafy.GES.csFAILED_TO_CONVERT_ATTRIBUTE_X_TO_INT32_ERROR_X">
      <summary>
            Failed to convert attribute '{0}' to Int32. Error: '{1}'.
            </summary>
    </member>
    <member name="T:Cudafy.CudafyException">
      <summary>
            Base exception for all exceptions except for CudafyFatalException.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.CudafyException.#ctor(System.Exception,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyException" /> class.
            </summary>
      <param name="inner">The inner.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.CudafyException.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyException" /> class.
            </summary>
      <param name="errMsg">The err MSG.</param>
      <param name="args">The args.</param>
    </member>
    <member name="M:Cudafy.CudafyException.#ctor(System.Exception,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyException" /> class.
            </summary>
      <param name="inner">The inner exception.</param>
      <param name="errMsg">The err message.</param>
      <param name="args">The parameters.</param>
    </member>
    <member name="T:Cudafy.CudafyCompileException">
      <summary>
            CudafyCompileException.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyCompileException.csNO_SOURCES">
      <summary>
            No source code files specified.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyCompileException.csCOMPILATION_ERROR_X">
      <summary>
            Compilation error: {0}.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyCompileException.csCUDA_DIR_NOT_FOUND">
      <summary>
            CUDA directory not found.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyCompileException.csNO_X_SOURCE_CODE_PRESENT_IN_CUDAFY_MODULE">
      <summary>
            No {0} source code present in Cudafy module.
            </summary>
    </member>
    <member name="F:Cudafy.CudafyCompileException.csNO_X_SOURCE_CODE_PRESENT_IN_CUDAFY_MODULE_FOR_X">
      <summary>
            No {0} source code present in Cudafy module for {1}.
            </summary>
    </member>
    <member name="T:Cudafy.CudafyFatalException">
      <summary>
            An error mostly likely resulting from a programming error within the Cudafy library.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyFatalException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyFatalException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.CudafyFatalException.#ctor(System.Exception,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyFatalException" /> class.
            </summary>
      <param name="inner">The inner.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.CudafyFatalException.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyFatalException" /> class.
            </summary>
      <param name="errMsg">The err MSG.</param>
      <param name="args">The args.</param>
    </member>
    <member name="T:Cudafy.CudafyLanguageException">
      <summary>
            Base exception for all dataflow exceptions except for DataflowFatalException.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyLanguageException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyLanguageException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.CudafyLanguageException.#ctor(System.Exception,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyLanguageException" /> class.
            </summary>
      <param name="inner">The inner.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.CudafyLanguageException.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyLanguageException" /> class.
            </summary>
      <param name="errMsg">The err MSG.</param>
      <param name="args">The args.</param>
    </member>
    <member name="M:Cudafy.CudafyLanguageException.#ctor(System.Exception,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyLanguageException" /> class.
            </summary>
      <param name="inner">The inner.</param>
      <param name="errMsg">The err MSG.</param>
      <param name="args">The args.</param>
    </member>
    <member name="T:Cudafy.AssemblyExtensions">
      <summary>
            Extensions to the Assembly class for handling related Cudafy Modules
            </summary>
    </member>
    <member name="M:Cudafy.AssemblyExtensions.HasCudafyModule(System.Reflection.Assembly)">
      <summary>
            Determines whether the assembly has a cudafy module embedded.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>
        <c>true</c> if it has cudafy module; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.AssemblyExtensions.GetCudafyModule(System.Reflection.Assembly)">
      <summary>
            Gets the embedded cudafy module from the assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>Cudafy module.</returns>
    </member>
    <member name="M:Cudafy.AssemblyExtensions.Cudafy(System.Reflection.Assembly,Cudafy.eArchitecture)">
      <summary>
            Cudafies the assembly producing a *.cdfy file with same name as assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <param name="arch">The architecture.</param>
      <returns>Output messages of the cudafycl.exe process.</returns>
    </member>
    <member name="M:Cudafy.AssemblyExtensions.TryCudafy(System.Reflection.Assembly,Cudafy.eArchitecture)">
      <summary>
            Tries cudafying the assembly producing a *.cdfy file with same name as assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <param name="arch">The architecture.</param>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.AssemblyExtensions.TryCudafy(System.Reflection.Assembly,System.String@,Cudafy.eArchitecture)">
      <summary>
            Tries cudafying the assembly producing a *.cdfy file with same name as assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <param name="messages">Output messages of the cudafycl.exe process.</param>
      <param name="arch">The architecture.</param>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Cudafy.Atomics.AtomicFunctions">
      <summary>
            Extension class containing atomic functions. See the NVIDIA CUDA documentation for more information.
            </summary>
    </member>
    <member name="M:Cudafy.Atomics.AtomicFunctions.atomicAdd(Cudafy.GThread,System.Single@,System.Single)">
      <summary>
            Not supported by OpenCL.
            </summary>
      <param name="thread">The thread.</param>
      <param name="address">The address.</param>
      <param name="val">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Atomics.AtomicFunctions.atomicIncEx(Cudafy.GThread,System.UInt32@)">
      <summary>
            Supported by both CUDA and OpenCL.
            </summary>
      <param name="thread">The thread.</param>
      <param name="address">The address.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Atomics.AtomicFunctions.atomicDecEx(Cudafy.GThread,System.UInt32@)">
      <summary>
            Supported by both CUDA and OpenCL.
            </summary>
      <param name="thread">The thread.</param>
      <param name="address">The address.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Atomics.AtomicFunctions.atomicInc(Cudafy.GThread,System.UInt32@,System.UInt32)">
      <summary>
            Not supported by OpenCL.
            </summary>
      <param name="thread">The thread.</param>
      <param name="address">The address.</param>
      <param name="val">The val.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Atomics.AtomicFunctions.atomicDec(Cudafy.GThread,System.UInt32@,System.UInt32)">
      <summary>
            Not supported by OpenCL.
            </summary>
      <param name="thread">The thread.</param>
      <param name="address">The address.</param>
      <param name="val">The val.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Cudafy.DynamicParallelism.DynamicParallelismFunctions">
      <summary>
            Extension methods for dynamic parallelism.  Compute 3.5 or higher.
            </summary>
    </member>
    <member name="M:Cudafy.DynamicParallelism.DynamicParallelismFunctions.Launch(Cudafy.GThread,Cudafy.dim3,Cudafy.dim3,System.String,System.Object[])">
      <summary>
             NOTE: Compute Capability 3.5 and later only. Dynamic parallelism. Call from a single thread.
             Not supported by emulator.
            </summary>
      <param name="gridSize">Size of grid.</param>
      <param name="blockSize">Size of block.</param>
      <param name="functionName">Name of function to launch.</param>
      <param name="args">Arguments.</param>
    </member>
    <member name="M:Cudafy.DynamicParallelism.DynamicParallelismFunctions.SynchronizeDevice(Cudafy.GThread)">
      <summary>
            Synchronizes threads.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.DynamicParallelism.DynamicParallelismFunctions.GetLastError(Cudafy.GThread)">
      <summary>
            Gets the last error.
            </summary>
      <param name="thread">
      </param>
      <returns>Int32 representation of last error.</returns>
    </member>
    <member name="M:Cudafy.DynamicParallelism.DynamicParallelismFunctions.GetDeviceCount(Cudafy.GThread,System.Int32@)">
      <summary>
            Gets the number of devices.
            </summary>
      <param name="thread">
      </param>
      <param name="count">Number of devices.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.DynamicParallelism.DynamicParallelismFunctions.GetDeviceID(Cudafy.GThread,System.Int32@)">
      <summary>
            Gets the current device ID.
            </summary>
      <param name="thread">
      </param>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions">
      <summary>
            Extension class containing Integer Intrinsics functions. 
            </summary>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.popcount(Cudafy.GThread,System.UInt32)">
      <summary>
            Count the number of bits that are set to 1 in x.
            </summary>
      <param name="thread">The thread.</param>
      <param name="val">The value.</param>
      <returns>Returns a value between 0 and 32 inclusive representing the number of set bits.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.popcountll(Cudafy.GThread,System.UInt64)">
      <summary>
            Count the number of bits that are set to 1 in x.
            </summary>
      <param name="thread">The thread.</param>
      <param name="val">The value.</param>
      <returns>Returns a value between 0 and 64 inclusive representing the number of set bits.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.clz(Cudafy.GThread,System.Int32)">
      <summary>
            Count the number of consecutive leading zero bits, starting at the most significant bit (bit 31) of x.
            </summary>
      <param name="thread">The thread.</param>
      <param name="val">The value.</param>
      <returns>Returns a value between 0 and 32 inclusive representing the number of zero bits.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.clzll(Cudafy.GThread,System.Int64)">
      <summary>
            Count the number of consecutive leading zero bits, starting at the most significant bit (bit 63) of x.
            </summary>
      <param name="thread">The thread.</param>
      <param name="val">The value.</param>
      <returns>Returns a value between 0 and 64 inclusive representing the number of zero bits.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.mul24(Cudafy.GThread,System.Int32,System.Int32)">
      <summary>
            Calculate the least significant 32 bits of the product of the least significant 24 bits of x and y. The high order 8 bits of x and y are ignored.
            </summary>
      <param name="thread">The thread.</param>
      <param name="val">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.umul24(Cudafy.GThread,System.UInt32,System.UInt32)">
      <summary>
            Calculate the least significant 32 bits of the product of the least significant 24 bits of x and y. The high order 8 bits of x and y are ignored.
            </summary>
      <param name="thread">The thread.</param>
      <param name="val">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.mul64hi(Cudafy.GThread,System.Int64,System.Int64)">
      <summary>
            Calculate the most significant 64 bits of the 128-bit product x * y, where x and y are 64-bit integers.
            </summary>
      <param name="thread">The thread.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>Returns the most significant 64 bits of the product x * y.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.mulhi(Cudafy.GThread,System.Int32,System.Int32)">
      <summary>
            Calculate the most significant 32 bits of the 64-bit product x * y, where x and y are 32-bit integers.
            </summary>
      <param name="thread">The thread.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>Returns the most significant 32 bits of the product x * y.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.umul64hi(Cudafy.GThread,System.UInt64,System.UInt64)">
      <summary>
            Calculate the most significant 64 bits of the 128-bit product x * y, where x and y are 64-bit integers.
            </summary>
      <param name="thread">The thread.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>Returns the most significant 64 bits of the product x * y.</returns>
    </member>
    <member name="M:Cudafy.IntegerIntrinsics.IntegerIntrinsicsFunctions.umulhi(Cudafy.GThread,System.UInt32,System.UInt32)">
      <summary>
            Calculate the most significant 32 bits of the 64-bit product x * y, where x and y are 32-bit integers.
            </summary>
      <param name="thread">The thread.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>Returns the most significant 32 bits of the product x * y.</returns>
    </member>
    <member name="M:Cudafy.SIMDFunctions.SIMDFuncs.ProcessHalfWords(System.String,System.UInt32)">
      <summary>
            Break the 32-bit input word into two 16-bit halfwords and pass them off to be processed separately.
            </summary>
      <param name="fnName">function name to be passed along to method ProcessHalfWord</param>
      <param name="a">32-bit word to be broken into two halfwords</param>
      <returns>32-bit word assembled from two halfwords</returns>
    </member>
    <member name="M:Cudafy.SIMDFunctions.SIMDFuncs.ProcessHalfWords(System.String,System.UInt32,System.UInt32)">
      <summary>
            Break each 32-bit input word into two 16-bit halfwords and pass them off to be processed separately.
            </summary>
      <param name="fnName">function name to be passed along to method ProcessHalfWord</param>
      <param name="a">32-bit word to be broken into two halfwords</param>
      <param name="b">32-bit word to be broken into two halfwords</param>
      <returns>32-bit word assembled from two halfwords</returns>
    </member>
    <member name="M:Cudafy.SIMDFunctions.SIMDFuncs.SumHalfWords(System.String,System.UInt32,System.UInt32)">
      <summary>
            Break each 32-bit input word into two 16-bit halfwords and pass them off to be processed separately.
            Sum the results.
            </summary>
      <param name="fnName">function name to be passed along to method ProcessHalfWord</param>
      <param name="a">32-bit word to be broken into two halfwords</param>
      <param name="b">32-bit word to be broken into two halfwords</param>
      <returns>32-bit word -- sum of two halfwords</returns>
    </member>
    <member name="M:Cudafy.SIMDFunctions.SIMDFuncs.ProcessBytes(System.String,System.UInt32)">
      <summary>
            Break the 32-bit input word into four bytes and pass them off to be processed separately.
            </summary>
      <param name="fnName">function name to be passed along to method ProcessByte</param>
      <param name="a">32-bit word to be broken into four bytes</param>
      <returns>32-bit word assembled from four bytes</returns>
    </member>
    <member name="M:Cudafy.SIMDFunctions.SIMDFuncs.ProcessBytes(System.String,System.UInt32,System.UInt32)">
      <summary>
            Break each 32-bit input word into four bytes and pass them off to be processed separately.
            </summary>
      <param name="fnName">function name to be passed along to method ProcessByte</param>
      <param name="a">32-bit word to be broken into four bytes</param>
      <param name="b">32-bit word to be broken into four bytes</param>
      <returns>32-bit word assembled from four bytes</returns>
    </member>
    <member name="M:Cudafy.SIMDFunctions.SIMDFuncs.SumBytes(System.String,System.UInt32,System.UInt32)">
      <summary>
            Break each 32-bit input word into four bytes and pass them off to be processed separately.
            Sum the results.
            </summary>
      <param name="fnName">function name to be passed along to method ProcessByte</param>
      <param name="a">32-bit word to be broken into four bytes</param>
      <param name="b">32-bit word to be broken into four bytes</param>
      <returns>32-bit word -- sum of four bytes</returns>
    </member>
    <member name="T:Cudafy.GBlock">
      <summary>
            Represents an Cuda block.
            </summary>
    </member>
    <member name="M:Cudafy.GBlock.#ctor(Cudafy.GGrid,Cudafy.dim3,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.GBlock" /> class.
            </summary>
      <param name="grid">The parent grid.</param>
      <param name="size">The size.</param>
      <param name="x">The x value.</param>
      <param name="y">The y value.</param>
    </member>
    <member name="M:Cudafy.GBlock.AllocateShared``1(System.String,System.Int32)">
      <summary>
            Allocates a 1D array in shared memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="varName">Key of the variable.</param>
      <param name="x">The x size.</param>
      <returns>Pointer to the shared memory.</returns>
    </member>
    <member name="M:Cudafy.GBlock.AllocateShared``1(System.String,System.Int32,System.Int32)">
      <summary>
            Allocates a 2D array in shared memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="varName">Key of the variable.</param>
      <param name="x">The x size.</param>
      <param name="y">The y size.</param>
      <returns>Pointer to the shared memory.</returns>
    </member>
    <member name="M:Cudafy.GBlock.AllocateShared``1(System.String,System.Int32,System.Int32,System.Int32)">
      <summary>
            Allocates a 2D array in shared memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="varName">Key of the variable.</param>
      <param name="x">The x size.</param>
      <param name="y">The y size.</param>
      <param name="z">The z size.</param>
      <returns>Pointer to the shared memory.</returns>
    </member>
    <member name="M:Cudafy.GBlock.SyncThreads">
      <summary>
            Syncs the threads in this block.
            </summary>
    </member>
    <member name="M:Cudafy.GBlock.SyncThreadsCount(System.Boolean)">
      <summary>
            Syncs the threads in this block, returns number of threads that have true predicate in block
            </summary>
    </member>
    <member name="M:Cudafy.GBlock.Any(System.Boolean,System.Int32)">
      <summary>
            Syncs the threads in the warp, returns true is any have true prediate
            </summary>
    </member>
    <member name="M:Cudafy.GBlock.All(System.Boolean,System.Int32)">
      <summary>
            Syncs the threads in the warp, returns true iff all threads in warp are have true predicate;
            </summary>
    </member>
    <member name="M:Cudafy.GBlock.Ballot(System.Boolean,System.Int32)">
      <summary>
            Syncs the threads in the warp, returns number of threads with true predicate, in warp
            </summary>
    </member>
    <member name="P:Cudafy.GBlock.Idx">
      <summary>
            Gets the id of this block.
            </summary>
    </member>
    <member name="P:Cudafy.GBlock.Dim">
      <summary>
            Gets the dimensions of this block.
            </summary>
    </member>
    <member name="P:Cudafy.GBlock.Grid">
      <summary>
            Gets the parent grid.
            </summary>
    </member>
    <member name="P:Cudafy.GBlock.Barrier">
      <summary>
            Gets or sets the barrier used to synchronize threads in a block.
            </summary>
      <value>
            The barrier.
            </value>
    </member>
    <member name="T:Cudafy.GGrid">
      <summary>
            Represents a Cuda grid.
            </summary>
    </member>
    <member name="M:Cudafy.GGrid.#ctor(Cudafy.dim3)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.GGrid" /> class.
            </summary>
      <param name="size">The size.</param>
    </member>
    <member name="P:Cudafy.GGrid.Dim">
      <summary>
            Gets or sets the dimensions of the grid.
            </summary>
      <value>
            The dim.
            </value>
    </member>
    <member name="T:Cudafy.GMath">
      <summary>
            Many of the .NET math methods are double only.  When single point (float) is used 
            this results in an unwanted cast to double. 
            </summary>
    </member>
    <member name="F:Cudafy.GMath.PI">
      <summary>
            Represents the ratio of the circumference of a circle to its diameter, specified by the constant, .
            </summary>
    </member>
    <member name="F:Cudafy.GMath.E">
      <summary>
            Represents the natural logarithmic base, specified by the constant, e.
            </summary>
    </member>
    <member name="M:Cudafy.GMath.Abs(System.Single)">
      <summary>
            Returns the absolute value of a single precision floating point number. For OpenCL compatibility, first cast
            value to an integer.
            </summary>
      <param name="value">The value to find absolute value of.</param>
      <returns>Absolute of specified value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Abs(System.Int32)">
      <summary>
            Returns the absolute value of a single precision floating point number.  For OpenCL compatibility, first cast
            value to an integer.
            </summary>
      <param name="value">The value to find absolute value of.</param>
      <returns>Absolute of specified value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Abs(System.Int64)">
      <summary>
            Returns the absolute value of a single precision floating point number.  For OpenCL compatibility, first cast
            value to an integer.
            </summary>
      <param name="value">The value to find absolute value of.</param>
      <returns>Absolute of specified value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Sqrt(System.Single)">
      <summary>
            Returns the square root of a specified number.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.GMath.Cos(System.Single)">
      <summary>
            Returns the cosine of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The cosine of value. If value is equal to NaN, NegativeInfinity, or PositiveInfinity, this method returns NaN.</returns>
    </member>
    <member name="M:Cudafy.GMath.Acos(System.Single)">
      <summary>
            Acoses the specified value.
            </summary>
      <param name="value">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.GMath.Cosh(System.Single)">
      <summary>
            Returns the hyperbolic cosine of the specified angle.
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The hyperbolic cosine of value. If value is equal to NegativeInfinity or PositiveInfinity, PositiveInfinity is returned. If value is equal to NaN, NaN is returned.</returns>
    </member>
    <member name="M:Cudafy.GMath.Sin(System.Single)">
      <summary>
            Returns the sine of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The sine of value. If value is equal to NaN, NegativeInfinity, or PositiveInfinity, this method returns NaN.</returns>
    </member>
    <member name="M:Cudafy.GMath.Asin(System.Single)">
      <summary>
            Returns the sine of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The sine of value. If value is equal to NaN, NegativeInfinity, or PositiveInfinity, this method returns NaN.</returns>
    </member>
    <member name="M:Cudafy.GMath.Sinh(System.Single)">
      <summary>
            Returns the hyperbolic sine of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The hyperbolic sine of value. If value is equal to NaN, NegativeInfinity, or PositiveInfinity, this method returns NaN.</returns>
    </member>
    <member name="M:Cudafy.GMath.Tan(System.Single)">
      <summary>
            Returns the tan of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The tan of value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Atan(System.Single)">
      <summary>
            Returns the tan of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The tan of value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Atan2(System.Single,System.Single)">
      <summary>
            Returns the angle whose tangent is the quotient of two specified numbers.
            </summary>
      <param name="y">The y coordinate of a point.</param>
      <param name="x">The x coordinate of a point.</param>
      <returns>Type: System.Double</returns>
    </member>
    <member name="M:Cudafy.GMath.Tanh(System.Single)">
      <summary>
            Returns hyperbolic the tangent of the specified angle. 
            </summary>
      <param name="value">An angle, measured in radians.</param>
      <returns>The hyperbolic the tangent of value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Round(System.Single)">
      <summary>
            Rounds the specified value.
            </summary>
      <param name="value">The value.</param>
      <returns>Rounded value.</returns>
    </member>
    <member name="M:Cudafy.GMath.Ceiling(System.Single)">
      <summary>
            Ceilings the specified value.
            </summary>
      <param name="value">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.GMath.Floor(System.Single)">
      <summary>
            Floors the specified value.
            </summary>
      <param name="value">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.GMath.Pow(System.Single,System.Single)">
      <summary>
            Returns the specified number raised to the specified power.
            </summary>
      <param name="x">Number to be raised to a power.</param>
      <param name="y">Number that specifies the power.</param>
      <returns>X to the power of y.</returns>
    </member>
    <member name="M:Cudafy.GMath.Log10(System.Single)">
      <summary>
            Returns the base 10 log of the specified number.
            </summary>
      <param name="value">A number whose logarithm is to be found.</param>
      <returns>Result.</returns>
    </member>
    <member name="M:Cudafy.GMath.Log(System.Single)">
      <summary>
            Returns the natural (base e) logarithm of a specified number.
            </summary>
      <param name="value">A number whose logarithm is to be found.</param>
      <returns>Result.</returns>
    </member>
    <member name="M:Cudafy.GMath.Exp(System.Single)">
      <summary>
            Returns e raised to the specified power.
            </summary>
      <param name="value">A number specifying a power. </param>
      <returns>The number e raised to the power d. If d equals NaN or PositiveInfinity, that value is returned. If d equals NegativeInfinity, 0 is returned.</returns>
    </member>
    <member name="M:Cudafy.GMath.Truncate(System.Single)">
      <summary>
            Truncates the specified value.
            </summary>
      <param name="value">The value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.GMath.Max(System.Single,System.Single)">
      <summary>
            Returns the larger of two single float precision numbers.
            </summary>
      <param name="x">The first number to compare.</param>
      <param name="y">The second number to compare.</param>
      <returns>The larger of the two numbers.</returns>
    </member>
    <member name="M:Cudafy.GMath.Min(System.Single,System.Single)">
      <summary>
            Returns the smaller of two single float precision numbers.
            </summary>
      <param name="x">The first number to compare.</param>
      <param name="y">The second number to compare.</param>
      <returns>The smaller of the two numbers.</returns>
    </member>
    <member name="T:Cudafy.GThread">
      <summary>
            Represents a CUDA thread.
            </summary>
    </member>
    <member name="M:Cudafy.GThread.#ctor(System.Int32,System.Int32,Cudafy.GBlock)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.GThread" /> class.
            </summary>
      <param name="xId">The x id.</param>
      <param name="yId">The y id.</param>
      <param name="parent">The parent block.</param>
    </member>
    <member name="M:Cudafy.GThread.SyncThreads">
      <summary>
            Syncs the threads in the block.
            </summary>
    </member>
    <member name="M:Cudafy.GThread.AllocateShared``1(System.String,System.Int32)">
      <summary>
            Allocates a 1D array in shared memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="varName">Key of the variable.</param>
      <param name="x">The x size.</param>
      <returns>Pointer to the shared memory.</returns>
    </member>
    <member name="M:Cudafy.GThread.AllocateShared``1(System.String,System.Int32,System.Int32)">
      <summary>
            Allocates a 2D array in shared memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="varName">Key of the variable.</param>
      <param name="x">The x size.</param>
      <param name="y">The y size.</param>
      <returns>Pointer to the shared memory.</returns>
    </member>
    <member name="M:Cudafy.GThread.AllocateShared``1(System.String,System.Int32,System.Int32,System.Int32)">
      <summary>
            Allocates a 3D array in shared memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="varName">Key of the variable.</param>
      <param name="x">The x size.</param>
      <param name="y">The y size.</param>
      <param name="z">The z size.</param>
      <returns>Pointer to the shared memory.</returns>
    </member>
    <member name="M:Cudafy.GThread.WarpId">
      <summary>
            Gets the warp id this thread belongs too
            </summary>
      <value>
            The warp id
            </value>
    </member>
    <member name="M:Cudafy.GThread.SyncThreadsCount(System.Boolean)">
      <summary>
            NOTE Compute Capability 2.x and later only. Syncs the threads in the block.
            </summary>
    </member>
    <member name="M:Cudafy.GThread.Any(System.Boolean)">
      <summary>
            Syncs threads in warp, returns true if any had true predicate 
            </summary>
    </member>
    <member name="M:Cudafy.GThread.All(System.Boolean)">
      <summary>
            Syncs threads in warp, returns true if any had true predicate 
            </summary>
    </member>
    <member name="M:Cudafy.GThread.Ballot(System.Boolean)">
      <summary>
            NOTE Compute Capability 2.x and later only. Syncs threads in warp, returns true if any had true predicate. 
            </summary>
    </member>
    <member name="M:Cudafy.GThread.InsertCode(System.String)">
      <summary>
            Inserts CUDA C code directly into kernel. Example: thread.InsertCode("#pragma unroll 5");
            </summary>
      <param name="text">The code to be inserted.</param>
      <exception cref="T:Cudafy.CudafyException">Attempt to run code through emulator made.</exception>
    </member>
    <member name="M:Cudafy.GThread.InsertCode(System.String,System.Boolean)">
      <summary>
            Inserts CUDA C code directly into kernel. Example: thread.InsertCode("#pragma unroll 5", false);
            </summary>
      <param name="text">The code to be inserted.</param>
      <param name="throwIfNotSupported">If true (default) then throw an exception if emulation is attempted.</param>
      <exception cref="T:Cudafy.CudafyException">Attempt to run code through emulator made while throwIfNotSupported is true.</exception>
    </member>
    <member name="M:Cudafy.GThread.InsertCode(System.String,System.Object[])">
      <summary>
            Inserts CUDA C code directly into kernel. Example: thread.InsertCode("{0}[{2}] = {1}[{2}];", results, data, index); 
            </summary>
      <param name="text">The code to be inserted.</param>
      <param name="args">Replaces place holders with names of one or more arguments.</param>
      <exception cref="T:Cudafy.CudafyException">Attempt to run code through emulator made.</exception>
    </member>
    <member name="M:Cudafy.GThread.InsertCode(System.String,System.Boolean,System.Object[])">
      <summary>
            Inserts CUDA C code directly into kernel. Example: thread.InsertCode("{0}[{2}] = {1}[{2}];", results, data, index); 
            </summary>
      <param name="text">The code to be inserted.</param>
      <param name="throwIfNotSupported">If true (default) then throw an exception if emulation is attempted.</param>
      <param name="args">Replaces place holders with names of one or more arguments.</param>
      <exception cref="T:Cudafy.CudafyException">Attempt to run code through emulator made while throwIfNotSupported is true.</exception>
    </member>
    <member name="P:Cudafy.GThread.block">
      <summary>
            Gets the parent block.
            </summary>
    </member>
    <member name="P:Cudafy.GThread.warpSize">
      <summary>
            Gets the size of the warp.
            </summary>
      <value>
            The size of the warp.
            </value>
    </member>
    <member name="P:Cudafy.GThread.blockIdx">
      <summary>
            Gets the parent block id.
            </summary>
    </member>
    <member name="P:Cudafy.GThread.blockDim">
      <summary>
            Gets the parent block dimension.
            </summary>
    </member>
    <member name="P:Cudafy.GThread.gridDim">
      <summary>
            Gets the parent grid dim.
            </summary>
    </member>
    <member name="P:Cudafy.GThread.threadIdx">
      <summary>
            Gets the thread id.
            </summary>
    </member>
    <member name="T:Cudafy.KernelMemberInfo">
      <summary>
            Base class for kernel constants, methods and types.
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csNAME">
      <summary>
            Name
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csTYPE">
      <summary>
            Type
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csCHECKSUM">
      <summary>
            Checksum
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csASSEMBLY">
      <summary>
            Assembly
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csASSEMBLYNAME">
      <summary>
            AssemblyName
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csASSEMBLYPATH">
      <summary>
            AssemblyPath
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csISDUMMY">
      <summary>
            IsDummy
            </summary>
    </member>
    <member name="F:Cudafy.KernelMemberInfo.csDUMMYBEHAVIOUR">
      <summary>
            DummyBehaviour
            </summary>
    </member>
    <member name="M:Cudafy.KernelMemberInfo.GetAssemblyChecksum">
      <summary>
            Gets the checksum of the assembly on which this member was based.
            </summary>
      <returns>Crc32 check sum.</returns>
    </member>
    <member name="M:Cudafy.KernelMemberInfo.TryVerifyChecksums">
      <summary>
            Checks if the assembly checksum and deserialized checksum are the same.
            </summary>
      <returns>True if the same, else false.</returns>
    </member>
    <member name="M:Cudafy.KernelMemberInfo.VerifyChecksums">
      <summary>
            Checks if the assembly checksum and deserialized checksum are the same.
            </summary>
      <exception cref="T:Cudafy.CudafyException">Checksums do not match.</exception>
    </member>
    <member name="M:Cudafy.KernelMemberInfo.ToString">
      <summary>
            Returns the Name.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Cudafy.KernelMemberInfo.DeserializedChecksum">
      <summary>
            Gets or sets the deserialized checksum.
            </summary>
      <value>
            The deserialized checksum.
            </value>
    </member>
    <member name="P:Cudafy.KernelMemberInfo.Type">
      <summary>
            Gets or sets the type.
            </summary>
      <value>
            The type.
            </value>
    </member>
    <member name="P:Cudafy.KernelMemberInfo.IsDummy">
      <summary>
            Gets a value indicating whether this instance is dummy.
            </summary>
      <value>
        <c>true</c> if this instance is dummy; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.KernelMemberInfo.Behaviour">
      <summary>
            Gets a value indicating whether to include header file for dummy or not.
            </summary>
    </member>
    <member name="P:Cudafy.KernelMemberInfo.Name">
      <summary>
            Gets the name.
            </summary>
    </member>
    <member name="T:Cudafy.KernelConstantInfo">
      <summary>
            Describes a .NET static that was translated to Cuda constant.
            </summary>
    </member>
    <member name="M:Cudafy.KernelConstantInfo.#ctor(System.String,System.Reflection.FieldInfo,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.KernelConstantInfo" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="fi">The field information.</param>
      <param name="isDummy">if set to <c>true</c> is dummy.</param>
    </member>
    <member name="M:Cudafy.KernelConstantInfo.GetDeclaration">
      <summary>
            Gets the Cuda C declaration string generated by this constant.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.KernelConstantInfo.GetTotalLength">
      <summary>
            Gets the total length.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.KernelConstantInfo.Handle">
      <summary>
            Gets or sets a handle that can be arbitrarily used to prevent garbage collection.
            </summary>
      <value>
            The handle.
            </value>
    </member>
    <member name="P:Cudafy.KernelConstantInfo.CudaPointer">
      <summary>
            Gets or sets the cuda pointer.
            </summary>
      <value>
            The cuda pointer.
            </value>
    </member>
    <member name="P:Cudafy.KernelConstantInfo.Name">
      <summary>
            Gets the name.
            </summary>
    </member>
    <member name="P:Cudafy.KernelConstantInfo.Information">
      <summary>
            Gets the information.
            </summary>
    </member>
    <member name="P:Cudafy.KernelConstantInfo.Type">
      <summary>
            Gets the type.
            </summary>
    </member>
    <member name="T:Cudafy.eKernelMethodType">
      <summary>
            The method type is either Global or Device.
            </summary>
    </member>
    <member name="F:Cudafy.eKernelMethodType.Global">
      <summary>
            Global function can be launched.
            </summary>
    </member>
    <member name="F:Cudafy.eKernelMethodType.Device">
      <summary>
            Device function can be called from global functions or other device function.
            </summary>
    </member>
    <member name="T:Cudafy.KernelMethodInfo">
      <summary>
            Describes a .NET method that was translated to Cuda function.
            </summary>
    </member>
    <member name="M:Cudafy.KernelMethodInfo.#ctor(System.Type,System.Reflection.MethodInfo,Cudafy.eKernelMethodType,System.Boolean,Cudafy.eCudafyDummyBehaviour,Cudafy.CudafyModule)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.KernelMethodInfo" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="method">The method.</param>
      <param name="gpuMethodType">Type of the gpu method.</param>
      <param name="isDummy">if set to <c>true</c> is dummy.</param>
      <param name="behaviour">
      </param>
      <param name="parentModule">Module of which this is a part.</param>
    </member>
    <member name="M:Cudafy.KernelMethodInfo.GetParametersString">
      <summary>
            Gets the parameters as a comma seperated string.
            </summary>
      <returns>Paramter string.</returns>
    </member>
    <member name="P:Cudafy.KernelMethodInfo.Method">
      <summary>
            Gets the method.
            </summary>
    </member>
    <member name="P:Cudafy.KernelMethodInfo.MethodType">
      <summary>
            Gets the type of the method.
            </summary>
      <value>
            The type of the method.
            </value>
    </member>
    <member name="P:Cudafy.KernelMethodInfo.KernelFunction">
      <summary>
            Gets the kernel function.
            </summary>
    </member>
    <member name="P:Cudafy.KernelMethodInfo.Name">
      <summary>
            Gets the name.
            </summary>
    </member>
    <member name="T:Cudafy.eGPUCompiler">
      <summary>
            Flags for compilers.
            </summary>
    </member>
    <member name="F:Cudafy.eGPUCompiler.None">
      <summary>
            None.
            </summary>
    </member>
    <member name="F:Cudafy.eGPUCompiler.CudaNvcc">
      <summary>
            Nvcc Cuda compiler.
            </summary>
    </member>
    <member name="F:Cudafy.eGPUCompiler.All">
      <summary>
            Compile for all targets.
            </summary>
    </member>
    <member name="P:Cudafy.ProgramModuleBase.Platform">
      <summary>
            Gets the platform.
            </summary>
    </member>
    <member name="P:Cudafy.ProgramModuleBase.Architecture">
      <summary>
            Gets the architecture.
            </summary>
    </member>
    <member name="T:Cudafy.PTXModule">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:Cudafy.PTXModule.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Cudafy.PTXModule.PTX">
      <summary>
            Gets the PTX.
            </summary>
    </member>
    <member name="T:Cudafy.BinaryModule">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:Cudafy.BinaryModule.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Cudafy.BinaryModule.Binary">
      <summary>
            Gets the binary (e.g. cubin)
            </summary>
    </member>
    <member name="T:Cudafy.CudafyModule">
      <summary>
            Cudafy module.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.CudafyModule" /> class.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.GetMemberNames">
      <summary>
            Gets the member names.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.RemovePTXModules">
      <summary>
            Removes the PTX modules.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.RemoveBinaryModules">
      <summary>
            Removes the binary modules.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.HasPTXForPlatform(Cudafy.ePlatform,Cudafy.eArchitecture)">
      <summary>
            Determines whether module has binary for the specified platform and architecture.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The architecture.</param>
      <returns>
        <c>true</c> if module has binary for the specified platform and an architecture equal or less than that specified; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasPTXForPlatform(Cudafy.ePlatform)">
      <summary>
            Determines whether module has PTX for the specified platform.
            </summary>
      <param name="platform">The platform.</param>
      <returns>
        <c>true</c> if module has PTX for the specified platform; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasProgramModuleForPlatform(Cudafy.ePlatform,Cudafy.eArchitecture)">
      <summary>
            Determines whether module has PTX or binary for the specified platform.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The architecture.</param>
      <returns>
        <c>true</c> if module has module for the specified values; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasProgramModuleForPlatform(Cudafy.ePlatform)">
      <summary>
            Determines whether module has PTX or binary for the specified platform.
            </summary>
      <param name="platform">The platform.</param>
      <returns>
        <c>true</c> if module has module for the specified value; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasBinaryForPlatform(Cudafy.ePlatform,Cudafy.eArchitecture)">
      <summary>
            Determines whether module has binary for the specified platform and architecture.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The architecture.</param>
      <returns>
        <c>true</c> if module has binary for the specified platform and architecture; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasBinaryForPlatform(Cudafy.ePlatform)">
      <summary>
            Determines whether module has binary for the specified platform and architecture.
            </summary>
      <param name="platform">The platform.</param>
      <returns>
        <c>true</c> if module has binary for the specified platform; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.Reset">
      <summary>
            Resets this instance.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.TrySerialize">
      <summary>
            Trues to serialize this instance to file based on Name.
            </summary>
      <returns>True if successful, else false.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.Serialize">
      <summary>
            Serializes this instance to file based on Name.
            </summary>
    </member>
    <member name="M:Cudafy.CudafyModule.Serialize(System.String)">
      <summary>
            Serializes the module to the specified filename.
            </summary>
      <param name="filename">The filename.</param>
    </member>
    <member name="M:Cudafy.CudafyModule.Serialize(System.IO.Stream)">
      <summary>
            Serializes the module to the specified stream.
            </summary>
      <param name="stream">The stream to write to.</param>
    </member>
    <member name="M:Cudafy.CudafyModule.Clean(System.String)">
      <summary>
            Deletes the specified filename (with or without default .cdfy extension).
            </summary>
      <param name="filename">The filename.</param>
      <returns>True if file was deleted else false.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.GetDummyStructIncludes">
      <summary>
            Gets the dummy struct includes.
            </summary>
      <returns>Strings representing the Cuda include files.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.GetDummyIncludes">
      <summary>
            Gets the dummy function includes.
            </summary>
      <returns>Strings representing the Cuda include files.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.GetDummyDefines">
      <summary>
            Gets the dummy defines.
            </summary>
      <returns>Strings representing the Cuda defines files.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.TryDeserialize">
      <summary>
            Tries to deserialize from a file with the same name as the calling type.
            </summary>
      <returns>Cudafy module or null if failed.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.TryDeserialize(System.String)">
      <summary>
            Tries to deserialize from the specified file.
            </summary>
      <param name="filename">The filename.</param>
      <returns>Cudafy module or null if failed.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.TryDeserialize(System.String,System.String@)">
      <summary>
            Tries to deserialize from the specified file.
            </summary>
      <param name="filename">The filename.</param>
      <param name="errorMsg">The error message if fails, else empty string.</param>
      <returns>Cudafy module or null if failed.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasCudafyModuleInAssembly">
      <summary>
            Determines whether there is a cudafy module in the calling assembly.
            </summary>
      <returns>
        <c>true</c> if calling assembly has cudafy module; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.HasCudafyModule(System.Reflection.Assembly)">
      <summary>
            Determines whether there is a cudafy module in the specified assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>
        <c>true</c> if assembly has a cudafy module; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.CudafyModule.GetFromAssembly">
      <summary>
            Gets a cudafy module that was stored as a resource in the calling assembly.
            </summary>
      <returns>The stored cudafy module.</returns>
      <exception cref="T:Cudafy.CudafyException">Resource not found.</exception>
    </member>
    <member name="M:Cudafy.CudafyModule.GetFromAssembly(System.Reflection.Assembly)">
      <summary>
            Gets a cudafy module that was stored as a resource in the specified assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>The stored cudafy module.</returns>
      <exception cref="T:Cudafy.CudafyException">Resource not found.</exception>
    </member>
    <member name="M:Cudafy.CudafyModule.TryGetFromAssembly">
      <summary>
            Tries to get a cudafy module that was stored as a resource in the calling assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>The stored cudafy module, or null if not present.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.TryGetFromAssembly(System.Reflection.Assembly)">
      <summary>
            Tries to get a cudafy module that was stored as a resource in the specified assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>The stored cudafy module, or null if not present.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.Deserialize">
      <summary>
            Deserializes from a file with the same name as the calling type.
            </summary>
      <returns>Cudafy module.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.Deserialize(System.String)">
      <summary>
            Deserializes the specified file.
            </summary>
      <param name="filename">The filename.</param>
      <returns>Cudafy module.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.VerifyChecksums">
      <summary>
            Verifies the checksums of all functions, constants and types.
            </summary>
      <exception cref="T:Cudafy.CudafyException">Check sums don't match or total number of members is less than one, .</exception>
    </member>
    <member name="M:Cudafy.CudafyModule.TryVerifyChecksums">
      <summary>
            Verifies the checksums of all functions, constants and types.
            </summary>
      <returns>True if checksums match and total number of members is greater than one, else false.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.TryVerifyChecksums(Cudafy.ePlatform,Cudafy.eArchitecture)">
      <summary>
            Verifies the checksums of all functions, constants and types.
            </summary>
      <param name="platform">Platform.</param>
      <param name="arch">Architecture.</param>
      <returns>True if checksums match and total number of members is greater than one, else false.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.Clone">
      <summary>
            Clones the module. Useful for loading the same module to multiple GPUs.
            </summary>
      <returns>Cloned module.</returns>
    </member>
    <member name="M:Cudafy.CudafyModule.Compile(Cudafy.eGPUCompiler,System.Boolean,Cudafy.eCudafyCompileMode)">
      <summary>
            Compiles the module based on current Cuda source code and options.
            </summary>
      <param name="mode">The mode.</param>
      <param name="deleteGeneratedCode">if set to <c>true</c> delete generated code on success.</param>
      <param name="binary">Compile to binary if true.</param>
      <returns>The compile arguments.</returns>
      <exception cref="T:Cudafy.CudafyCompileException">No source code or compilation error.</exception>
    </member>
    <member name="P:Cudafy.CudafyModule.Name">
      <summary>
            Gets or sets the name.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.Tag">
      <summary>
            Gets or sets optional extra data (CUmodule).
            </summary>
      <value>
            The data.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.Functions">
      <summary>
            Gets the functions.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.Constants">
      <summary>
            Gets the constants.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.Types">
      <summary>
            Gets the types.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.CanPrint">
      <summary>
            NOT IMPLEMENTED YET. Gets or sets a value indicating whether this instance can print to console.
            </summary>
      <value>
        <c>true</c> if this instance can print; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.PTXModules">
      <summary>
            Gets the PTX modules.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.CurrentPlatform">
      <summary>
            Gets the current platform.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.PTX">
      <summary>
            Gets the first PTX suitable for the current platform.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.Binary">
      <summary>
            Gets the first PTX suitable for the current platform.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.HasSuitablePTX">
      <summary>
            Gets a value indicating whether this instance has suitable PTX.
            </summary>
      <value>
        <c>true</c> if this instance has PTX; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.HasPTX">
      <summary>
            Gets a value indicating whether this instance has one or more PTX.
            </summary>
      <value>
        <c>true</c> if this instance has PTX; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.HasBinary">
      <summary>
            Gets a value indicating whether this instance has one or more binary modules.
            </summary>
      <value>
        <c>true</c> if this instance has a binary module; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.CudaSourceCode">
      <summary>
            Gets or sets the CUDA or OpenCL source code.
            </summary>
      <value>
            The cuda source code.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.SourceCode">
      <summary>
            Gets or sets the CUDA or OpenCL source code.
            </summary>
      <value>
            The source code.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.HasCudaSourceCode">
      <summary>
            Gets a value indicating whether this instance has cuda source code.
            </summary>
      <value>
        <c>true</c> if this instance has cuda source code; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.HasSourceCode">
      <summary>
            Gets a value indicating whether this instance has source code.
            </summary>
      <value>
        <c>true</c> if this instance has source code; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.CompilerOptionsList">
      <summary>
            Gets the compiler options.
            </summary>
      <value>
            The compiler options.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.CompilerOutput">
      <summary>
            Gets or sets the compiler output.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.CompilerArguments">
      <summary>
            Gets the last arguments passed to compiler.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.WorkingDirectory">
      <summary>
            Gets or sets the working directory for the compiler.
            </summary>
    </member>
    <member name="P:Cudafy.CudafyModule.GenerateDebug">
      <summary>
            Gets or sets a value indicating whether to compile for debug.
            </summary>
      <value>
        <c>true</c> if compile for debug; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.TimeOut">
      <summary>
            Gets or sets the time out for compilation.
            </summary>
      <value>
            The time out in milliseconds.
            </value>
    </member>
    <member name="P:Cudafy.CudafyModule.SuppressWindow">
      <summary>
            Gets or sets a value indicating whether to start the compilation in a new window.
            </summary>
      <value>
        <c>true</c> if suppress a new window; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.KernelTypeInfo">
      <summary>
            Describes a .NET type (structure) that was translated to Cuda function.
            </summary>
    </member>
    <member name="M:Cudafy.KernelTypeInfo.#ctor(System.Type,System.Boolean,Cudafy.eCudafyDummyBehaviour)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.KernelTypeInfo" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="isDummy">if set to <c>true</c> is dummy.</param>
      <param name="noDummyInclude">
      </param>
    </member>
    <member name="P:Cudafy.KernelTypeInfo.Name">
      <summary>
            Gets the name.
            </summary>
    </member>
    <member name="T:info.jhpc.thread.SimpleBarrier">
            
            	 * Allows multiple threads to gather at a point before proceeding.
            
            	 *
            
            	 * @author Thomas W. Christopher (Tools of Computing LLC)
            
            	 * @version 0.2 Beta
            
        </member>
    <member name="F:info.jhpc.thread.SimpleBarrier.count">
            
            		 * Number of threads that still must gather.
            
        </member>
    <member name="F:info.jhpc.thread.SimpleBarrier.predicate_sum">
            
            		 * Number of threads that still must gather.
            
        </member>
    <member name="F:info.jhpc.thread.SimpleBarrier.initCount">
            
            		 * Total number of threads that must gather.
            
        </member>
    <member name="M:info.jhpc.thread.SimpleBarrier.#ctor(System.Int32)">
            
            		 * Creates a Barrier at which n threads may repeatedly gather.
            
            		 *
            
            		 * @param n total number of threads that must gather.
            
        </member>
    <member name="M:info.jhpc.thread.SimpleBarrier.gather(System.Boolean)">
            
            		 * Is called by a thread to wait for the rest of the n threads to gather
            
            		 * before the set of threads may continue executing.
            
            		 *
            
            		 * @throws InterruptedException If interrupted while waiting.
            
        </member>
    <member name="M:info.jhpc.thread.SimpleBarrier.SignalAndWait">
      <summary>
            Calls gather();
            </summary>
    </member>
    <member name="M:info.jhpc.thread.SimpleBarrier.SignalAndWaitAndCountPredicate(System.Boolean)">
      <summary>
            Calls gather(predicate); Returns sum of true predicates within block
            </summary>
    </member>
    <member name="M:info.jhpc.warp.SimpleWarpBarrier.SignalAnyPredicateAndWait(System.Boolean,System.Int32)">
      <summary>
            Calls gather();
            </summary>
    </member>
    <member name="M:info.jhpc.warp.SimpleWarpBarrier.SignalAllPredicateAndWait(System.Boolean,System.Int32)">
      <summary>
            Calls gather();
            </summary>
    </member>
    <member name="M:info.jhpc.warp.SimpleWarpBarrier.SignalBallotPredicateAndWait(System.Boolean,System.Int32)">
      <summary>
            Calls gather();
            </summary>
    </member>
    <member name="T:Cudafy.Types.ComplexF">
      <summary>
            Represents a complex single floating point number that is mapped to the native GPU equivalent.
            </summary>
    </member>
    <member name="F:Cudafy.Types.ComplexF.x">
      <summary>
            Real part.
            </summary>
    </member>
    <member name="F:Cudafy.Types.ComplexF.y">
      <summary>
            Imaginary part.
            </summary>
    </member>
    <member name="M:Cudafy.Types.ComplexF.#ctor(System.Single,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Types.ComplexF" /> struct.
            </summary>
      <param name="real">The real part.</param>
      <param name="imaginary">The imaginary part.</param>
    </member>
    <member name="M:Cudafy.Types.ComplexF.Conj(Cudafy.Types.ComplexF)">
      <summary>
            Conjugates the specified value.
            </summary>
      <param name="x">The value.</param>
      <returns>Conjugated value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexF.Add(Cudafy.Types.ComplexF,Cudafy.Types.ComplexF)">
      <summary>
            Adds value y to value x.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value to be added.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexF.Subtract(Cudafy.Types.ComplexF,Cudafy.Types.ComplexF)">
      <summary>
            Subtracts value y from value x.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value to be subtracted.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexF.Multiply(Cudafy.Types.ComplexF,Cudafy.Types.ComplexF)">
      <summary>
            Multiplies value x and y.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value two.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexF.Divide(Cudafy.Types.ComplexF,Cudafy.Types.ComplexF)">
      <summary>
            Divides value x by y.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value two.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexF.Abs(Cudafy.Types.ComplexF)">
      <summary>
            Gets the absolute of the specified value.
            </summary>
      <param name="x">The value.</param>
      <returns>Absolute.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexF.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="T:Cudafy.Types.ComplexD">
      <summary>
            Represents a complex single floating point number that is mapped to the native GPU equivalent.
            </summary>
    </member>
    <member name="F:Cudafy.Types.ComplexD.x">
      <summary>
            Real part.
            </summary>
    </member>
    <member name="F:Cudafy.Types.ComplexD.y">
      <summary>
            Imaginary part.
            </summary>
    </member>
    <member name="M:Cudafy.Types.ComplexD.#ctor(System.Double,System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Types.ComplexD" /> struct.
            </summary>
      <param name="real">The real part.</param>
      <param name="imaginary">The imaginary part.</param>
    </member>
    <member name="M:Cudafy.Types.ComplexD.Conj(Cudafy.Types.ComplexD)">
      <summary>
            Conjugates the specified value.
            </summary>
      <param name="x">The value.</param>
      <returns>Conjugated value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexD.Add(Cudafy.Types.ComplexD,Cudafy.Types.ComplexD)">
      <summary>
            Adds value y to value x.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value to be added.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexD.Subtract(Cudafy.Types.ComplexD,Cudafy.Types.ComplexD)">
      <summary>
            Subtracts value y from value x.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value to be subtracted.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexD.Multiply(Cudafy.Types.ComplexD,Cudafy.Types.ComplexD)">
      <summary>
            Multiplies value x and y.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value two.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexD.Divide(Cudafy.Types.ComplexD,Cudafy.Types.ComplexD)">
      <summary>
            Divides value x by y.
            </summary>
      <param name="x">Value one.</param>
      <param name="y">Value two.</param>
      <returns>New value.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexD.Abs(Cudafy.Types.ComplexD)">
      <summary>
            Gets the absolute of the specified value.
            </summary>
      <param name="x">The value.</param>
      <returns>Absolute.</returns>
    </member>
    <member name="M:Cudafy.Types.ComplexD.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="T:Cudafy.CV">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="F:Cudafy.CV.csVERSION">
      <summary>
            Version 1.28.*
            </summary>
    </member>
    <member name="T:Cudafy.Crc32">
      <summary>
            Class used for performing checksum.
            </summary>
    </member>
    <member name="M:Cudafy.Crc32.ComputeChecksum(System.String)">
      <summary>
            Computes the checksum.
            </summary>
      <param name="location">The file.</param>
      <returns>Checksum.</returns>
    </member>
    <member name="M:Cudafy.Crc32.ComputeChecksum(System.Byte[])">
      <summary>
            Computes the checksum.
            </summary>
      <param name="bytes">The bytes.</param>
      <returns>Checksum.</returns>
    </member>
    <member name="M:Cudafy.Crc32.ComputeChecksumBytes(System.Byte[])">
      <summary>
            Computes the checksum.
            </summary>
      <param name="bytes">The byte array.</param>
      <returns>Checksum.</returns>
    </member>
    <member name="M:Cudafy.Crc32.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Crc32" /> class.
            </summary>
    </member>
    <member name="T:Cudafy.Utility">
      <summary>
            Utility methods.
            </summary>
    </member>
    <member name="M:Cudafy.Utility.DumpToFile(System.String,System.String)">
      <summary>
            Dumps supplied text to file.
            </summary>
      <param name="text">The text.</param>
      <param name="filename">The file.</param>
      <returns>The text.</returns>
    </member>
    <member name="M:Cudafy.Utility.ProgramFilesx86">
      <summary>
            Gets the x86 program files directory.
            </summary>
      <returns>x86 program files directory.</returns>
    </member>
    <member name="M:Cudafy.Utility.ProgramFilesx64">
      <summary>
            Gets the x64 program files directory.
            </summary>
      <returns>x64 program files directory or empty string if does not exist.</returns>
    </member>
    <member name="M:Cudafy.Utility.Convert(Cudafy.Types.ComplexF[])">
      <summary>
            Converts the specified values to an array of floats.
            </summary>
      <param name="cplx">The values.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Utility.Convert(Cudafy.Types.ComplexD[])">
      <summary>
            Converts the specified values to an array of doubles.
            </summary>
      <param name="cplx">The values.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Utility.IsLinux">
      <summary>
            Gets a value indicating whether the OS is Linux.
            </summary>
      <value>
        <c>true</c> if OS is Linux; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.XmlExtensions">
      <summary>
            Xml extension class.
            </summary>
    </member>
    <member name="M:Cudafy.XmlExtensions.GetXElement(System.Xml.XmlNode)">
      <summary>
            Converts an XmlNode to XElement. 
            </summary>
      <param name="node">The node.</param>
      <returns>XElement</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.GetXmlNode(System.Xml.Linq.XElement)">
      <summary>
            Converts an XElement to XmlNode. 
            </summary>
      <param name="element">The element.</param>
      <returns>XmlNode</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.TryGetElementValue(System.Xml.Linq.XElement,System.String)">
      <summary>
            Tries to get element value.
            </summary>
      <param name="element">The element.</param>
      <param name="elementName">Name of the element.</param>
      <returns>Value of element or null if element does not exist.</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.GetAttributeValue(System.Xml.Linq.XElement,System.String)">
      <summary>
            Gets the attribute value.
            </summary>
      <param name="element">The element.</param>
      <param name="attributeName">Name of the attribute.</param>
      <returns>String value.</returns>
      <exception cref="T:System.Xml.XmlException">Attribute not found.</exception>
    </member>
    <member name="M:Cudafy.XmlExtensions.TryGetAttributeValue(System.Xml.Linq.XElement,System.String)">
      <summary>
            Tries to get attribute value.
            </summary>
      <param name="element">The element.</param>
      <param name="attributeName">Name of the attribute.</param>
      <returns>String value, or null if not found.</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.GetAttributeInt32Value(System.Xml.Linq.XElement,System.String)">
      <summary>
            Gets the attribute as Int32 value.
            </summary>
      <param name="element">The element.</param>
      <param name="attributeName">Name of the attribute.</param>
      <returns>Int32 value.</returns>
      <exception cref="T:System.Xml.XmlException">Attribute not found.</exception>
    </member>
    <member name="M:Cudafy.XmlExtensions.TryGetAttributeInt32Value(System.Xml.Linq.XElement,System.String)">
      <summary>
            Tries to get attribute as Int32 value.
            </summary>
      <param name="element">The element.</param>
      <param name="attributeName">Name of the attribute.</param>
      <returns>Int32 value, or null if not found.</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.TryGetAttributeBoolValue(System.Xml.Linq.XElement,System.String)">
      <summary>
            Tries the get attribute as bool value.
            </summary>
      <param name="element">The element.</param>
      <param name="attributeName">Name of the attribute.</param>
      <returns>Boolean value, or null if not found.</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.LoadStream(System.IO.Stream)">
      <summary>
            Loads an XDocument from the specified stream.
            </summary>
      <param name="inStream">The input stream.</param>
      <returns>XDocument</returns>
    </member>
    <member name="M:Cudafy.XmlExtensions.SaveStream(System.Xml.Linq.XDocument,System.IO.Stream)">
      <summary>
            Saves the stream to XDocument supplied.
            </summary>
      <param name="xmlDoc">The XML doc.</param>
      <param name="outStream">The out stream.</param>
    </member>
    <member name="T:Cudafy.Host.CudafyHost">
      <summary>
            CudafyHost contains high level management operations.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.GetDeviceProperties(Cudafy.eGPUType,System.Boolean)">
      <summary>
            Gets the device properties.
            </summary>
      <param name="type">The type of GPU.</param>
      <param name="useAdvanced">Whether to get the additional device settings via the cudart dll.</param>
      <returns>Device properties for all devices of the specified type.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.GetDeviceCount(Cudafy.eGPUType)">
      <summary>
            Gets the device count.
            </summary>
      <param name="type">The type of device.</param>
      <returns>Number of devices of type specified.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.GetDevice(Cudafy.eGPUType,System.Int32)">
      <summary>
            Gets device of type specified from the cache. Creates one if it does not already exist.
            Sets the current context to the returned device.
            </summary>
      <param name="type">The target type.</param>
      <param name="deviceId">The device id.</param>
      <returns>GPGPU instance.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.GetDevice(Cudafy.eArchitecture,System.Int32)">
      <summary>
            Gets the GPU from cache of type implied by specified architecture. Creates one if it does not already exist.
            Sets the current context to the returned device.
            </summary>
      <param name="arch">Architecture type.</param>
      <param name="deviceId">The device id.</param>
      <returns>GPGPU instance.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.DeviceCreated(Cudafy.eGPUType,System.Int32)">
      <summary>
            Checks if the specified device has already been created and added to the cache.
            </summary>
      <param name="type">The type.</param>
      <param name="deviceId">The device id.</param>
      <returns>True if created, else false.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.GetGPGPU(Cudafy.eGPUType,System.Int32)">
      <summary>
            Obsolete. Use GetDevice instead.
            </summary>
      <param name="type">The target type.</param>
      <param name="deviceId">The device id.</param>
      <returns>GPGPU instance.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.CreateDevice(Cudafy.eGPUType,System.Int32)">
      <summary>
            Creates a new GPGPU and adds to cache. If GPGPU already exists then it is first destroyed and removed from cache.
            </summary>
      <param name="type">The target type.</param>
      <param name="deviceId">The device id.</param>
      <returns>GPGPU instance.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.RemoveDevice(Cudafy.Host.GPGPU)">
      <summary>
            Removes the specified GPGPU from the cache.
            </summary>
      <param name="gpu">The gpu.</param>
      <returns>True if gpu was removed, else false.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.ClearDevices">
      <summary>
            Clears all gpus from the cache.
            </summary>
      <returns>The number of gpus removed.</returns>
    </member>
    <member name="M:Cudafy.Host.CudafyHost.ClearAllDeviceMemories">
      <summary>
            Clears all created device memories.
            </summary>
    </member>
    <member name="T:Cudafy.Host.GPGPU">
      <summary>
            Abstract base class for General Purpose GPUs.
            </summary>
    </member>
    <member name="F:Cudafy.Host.GPGPU._lock">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="F:Cudafy.Host.GPGPU._deviceMemory">
      <summary>
            Stores pointers to data on the device.
            </summary>
    </member>
    <member name="F:Cudafy.Host.GPGPU._streams">
      <summary>
            Stores streams.
            </summary>
    </member>
    <member name="F:Cudafy.Host.GPGPU._modules">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="F:Cudafy.Host.GPGPU._module">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.GPGPU" /> class.
            </summary>
      <param name="deviceId">The device id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Host.GPGPU" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Lock">
      <summary>
            Locks this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Unlock">
      <summary>
            Unlocks this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.EnableMultithreading">
      <summary>
            Allows multiple threads to access this GPU.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DisableMultithreading">
      <summary>
            Called once multiple threads have completed work.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.EnablePeerAccess(Cudafy.Host.GPGPU)">
      <summary>
            Enables peer access from within a kernel. 
            </summary>
      <param name="peer">Peer to access. This is a one-way relationship.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DisablePeerAccess(Cudafy.Host.GPGPU)">
      <summary>
            Disables peer access.
            </summary>
      <param name="peer">Accessible peer to disable access to.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CanAccessPeer(Cudafy.Host.GPGPU)">
      <summary>
            Use this to check if device supports direct access from kernel to another device.
            </summary>
      <param name="peer">Peer to access.</param>
      <returns>True if access is possible, else false.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyDeviceToDevice``1(``0[],System.Int32,Cudafy.Host.GPGPU,``0[],System.Int32,System.Int32)">
      <summary>
            Copies from one device to another device. Depending on whether RDMA is supported the transfer may or may not be via CPU and system memory.
            </summary>
      <typeparam name="T">Data </typeparam>
      <param name="src">
      </param>
      <param name="srcOffset">
      </param>
      <param name="peer">
      </param>
      <param name="dst">
      </param>
      <param name="dstOffset">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyDeviceToDeviceAsync``1(``0[],System.Int32,Cudafy.Host.GPGPU,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies from one device to another device. Depending on whether RDMA is supported the transfer may or may not be via CPU and system memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="src">Source data.</param>
      <param name="srcOffset">Source array.</param>
      <param name="peer">Target device.</param>
      <param name="dst">Destination array.</param>
      <param name="dstOffset">Destination offset.</param>
      <param name="count">Number of samples.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyDeviceToDevice``1(System.Array,System.Int32,Cudafy.Host.GPGPU,System.Array,System.Int32,System.Int32)">
      <summary>
            Does copy to peer asynchronously.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The SRC dev array.</param>
      <param name="srcOffset">The SRC offset.</param>
      <param name="peer">The peer.</param>
      <param name="dstDevArray">The DST dev array.</param>
      <param name="dstOffet">The DST offet.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyDeviceToDeviceAsync``1(System.Array,System.Int32,Cudafy.Host.GPGPU,System.Array,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does copy to peer asynchronously.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The SRC dev array.</param>
      <param name="srcOffset">The SRC offset.</param>
      <param name="peer">The peer.</param>
      <param name="dstDevArray">The DST dev array.</param>
      <param name="dstOffet">The DST offet.</param>
      <param name="count">The count.</param>
      <param name="stream">Stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.SetCurrentContext">
      <summary>
            Sets the current context to the context associated with this device when it was created.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CreateStream(System.Int32)">
      <summary>
            Explicitly creates a stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch">
      <summary>
            Gets the dynamic launcher with grid and block sizes equal to 1.
            Allows GPU functions to be called using dynamic language run-time. For example:
            gpgpu.Launch().myGPUFunction(x, y, res)         
            </summary>
      <returns>Dynamic launcher</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch(Cudafy.dim3,Cudafy.dim3,System.Int32)">
      <summary>
            Gets the dynamic launcher.
            Allows GPU functions to be called using dynamic language run-time. For example:
            gpgpu.Launch(new dim3(8,8), new dim3(8,8)).myGPUFunction(x, y, res)   
            </summary>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">The stream id or -1 for synchronous.</param>
      <returns>Dynamic launcher</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.AddToDeviceMemory(System.Object,Cudafy.Host.DevicePtrEx)">
      <summary>
            Adds to device memory.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceMemoryPointers">
      <summary>
            Gets the device memory pointers.
            </summary>
      <returns>All data pointers currently on device.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceMemoryPointer(Cudafy.Host.DevicePtrEx)">
      <summary>
            Gets the device memory pointer.
            </summary>
      <param name="ptrEx">The pointer.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceMemoryFromIntPtr(System.IntPtr)">
      <summary>
            Gets the device memory from IntPtr.
            </summary>
      <param name="ptr">The PTR.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceMemory(System.Object)">
      <summary>
            Gets the device memory for key specified.
            </summary>
      <param name="devArray">The dev array.</param>
      <returns>Device memory</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.TryGetDeviceMemory(System.Object)">
      <summary>
            Tries to get the device memory.
            </summary>
      <param name="devArray">The dev array.</param>
      <returns>Device memory or null if not found.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DeviceMemoryValueExists(System.Object)">
      <summary>
            Checks if specified device memory value exists.
            </summary>
      <param name="val">The device memory instance.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceMemories">
      <summary>
            Gets the device memories.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.ClearDeviceMemory">
      <summary>
            Clears the device memory.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.RemoveFromDeviceMemory(System.Object)">
      <summary>
            Removes from device memory.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.RemoveFromDeviceMemoryEx(Cudafy.Host.DevicePtrEx)">
      <summary>
            Removes from device memory based on specified pointer.
            </summary>
      <param name="ptrEx">The PTR ex.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceProperties(System.Boolean)">
      <summary>
            Gets the device properties.
            </summary>
      <param name="useAdvanced">States whether to get advanced properties.</param>
      <returns>Device properties.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetFunctionNames">
      <summary>
            Gets the names of all global functions.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetStream(System.Int32)">
      <summary>
            Gets the stream object.
            </summary>
      <param name="streamId">The stream id.</param>
      <returns>Stream object.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToConstantMemory``1(``0[],``0[])">
      <summary>
            Copies to constant memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="devArray">The device array.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToConstantMemory``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies to constant memory.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="count">The number of element to copy.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToConstantMemoryAsync``1(System.IntPtr,System.Int32,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies to constant memory async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToConstantMemoryAsync``1(``0[],System.Int32,``0[],System.Int32,System.Int32,System.Int32,System.IntPtr)">
      <summary>
            Copies to constant memory asynchronously using smart copy.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
      <param name="stagingPost">The staging post.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.InitializeCopyToConstantMemory(System.Array,System.Int32,System.Array,System.Int32,System.Int32@)">
      <summary>
            Initializes the copy to constant memory.
            </summary>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDeviceCount">
      <summary>
            Gets the device count.
            </summary>
      <returns>Number of devices of this type.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Synchronize">
      <summary>
            Synchronizes context.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.StartTimer">
      <summary>
            Starts the timer.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.StopTimer">
      <summary>
            Stops the timer.
            </summary>
      <returns>Elapsed time.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LoadModule(System.String)">
      <summary>
            Loads module from file.
            </summary>
      <param name="filename">The filename.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetMemberNames">
      <summary>
            Gets the names of all members in all loaded modules.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.IsModuleLoaded(System.String)">
      <summary>
            Determines whether a module is loaded with the specified name.
            </summary>
      <param name="moduleName">Name of the module.</param>
      <returns>
        <c>true</c> if module loaded; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CheckForDuplicateMembers(Cudafy.CudafyModule)">
      <summary>
            Internal use. Checks for duplicate members.
            </summary>
      <param name="module">The module.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LoadModule(Cudafy.CudafyModule,System.Boolean)">
      <summary>
            Loads module from module instance optionally unloading all already loaded modules. To load the same module to different GPUs you need
            to first Clone the module with cudafyModuleInstance.Clone().
            </summary>
      <param name="module">The module.</param>
      <param name="unload">If true then unload any currently loaded modules first.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.UnloadModule(Cudafy.CudafyModule)">
      <summary>
            Unloads the specified module.
            </summary>
      <param name="module">Module to unload.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.UnloadModule">
      <summary>
            Unloads the current module.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.UnloadModules">
      <summary>
            Unloads all modules.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``1(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0},``0)">
      <summary>
            Safe launches the specified action.
            </summary>
      <typeparam name="T1">The type.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">First argument.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``2(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1},``0,``1)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``3(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2},``0,``1,``2)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``4(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3},``0,``1,``2,``3)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``5(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4},``0,``1,``2,``3,``4)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``6(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4,``5)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``7(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``8(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6,``7)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``9(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``10(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``11(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``12(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">The stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``13(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <typeparam name="T13">The type of the 13.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
      <param name="t13">The T13.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``14(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <typeparam name="T13">The type of the 13.</typeparam>
      <typeparam name="T14">The type of the 14.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
      <param name="t13">The T13.</param>
      <param name="t14">The T14.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync``15(Cudafy.dim3,Cudafy.dim3,System.Int32,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <typeparam name="T13">The type of the 13.</typeparam>
      <typeparam name="T14">The type of the 14.</typeparam>
      <typeparam name="T15">The type of the 15.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="action">The action.</param>
      <param name="streamId">Stream number.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
      <param name="t13">The T13.</param>
      <param name="t14">The T14.</param>
      <param name="t15">The T15.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``1(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0},``0)">
      <summary>
            Safe launches the specified action.
            </summary>
      <typeparam name="T1">The type.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">First argument.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``2(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1},``0,``1)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``3(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2},``0,``1,``2)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``4(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3},``0,``1,``2,``3)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``5(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4},``0,``1,``2,``3,``4)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``6(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4,``5)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``7(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``8(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6,``7)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``9(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``10(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``11(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``13(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <typeparam name="T13">The type of the 13.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
      <param name="t13">The T13.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``14(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <typeparam name="T13">The type of the 13.</typeparam>
      <typeparam name="T14">The type of the 14.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
      <param name="t13">The T13.</param>
      <param name="t14">The T14.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch``15(Cudafy.dim3,Cudafy.dim3,System.Action{Cudafy.GThread,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
      <summary>
            Launches the specified grid size.
            </summary>
      <typeparam name="T1">The type of the 1.</typeparam>
      <typeparam name="T2">The type of the 2.</typeparam>
      <typeparam name="T3">The type of the 3.</typeparam>
      <typeparam name="T4">The type of the 4.</typeparam>
      <typeparam name="T5">The type of the 5.</typeparam>
      <typeparam name="T6">The type of the 6.</typeparam>
      <typeparam name="T7">The type of the 7.</typeparam>
      <typeparam name="T8">The type of the 8.</typeparam>
      <typeparam name="T9">The type of the 9.</typeparam>
      <typeparam name="T10">The type of the 10.</typeparam>
      <typeparam name="T11">The type of the 11.</typeparam>
      <typeparam name="T12">The type of the 12.</typeparam>
      <typeparam name="T13">The type of the 13.</typeparam>
      <typeparam name="T14">The type of the 14.</typeparam>
      <typeparam name="T15">The type of the 15.</typeparam>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="action">The action.</param>
      <param name="t1">The t1.</param>
      <param name="t2">The t2.</param>
      <param name="t3">The t3.</param>
      <param name="t4">The t4.</param>
      <param name="t5">The t5.</param>
      <param name="t6">The t6.</param>
      <param name="t7">The t7.</param>
      <param name="t8">The t8.</param>
      <param name="t9">The t9.</param>
      <param name="t10">The T10.</param>
      <param name="t11">The T11.</param>
      <param name="t12">The T12.</param>
      <param name="t13">The T13.</param>
      <param name="t14">The T14.</param>
      <param name="t15">The T15.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Launch(Cudafy.dim3,Cudafy.dim3,System.String,System.Object[])">
      <summary>
            Launches the specified kernel.
            </summary>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="methodName">Name of the method.</param>
      <param name="arguments">The arguments.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.LaunchAsync(Cudafy.dim3,Cudafy.dim3,System.Int32,System.String,System.Object[])">
      <summary>
            Launches the specified kernel.
            </summary>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id.</param>
      <param name="methodName">Name of the method.</param>
      <param name="arguments">The arguments.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoLaunch(Cudafy.dim3,Cudafy.dim3,System.Int32,Cudafy.KernelMethodInfo,System.Object[])">
      <summary>
            Does the launch.
            </summary>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id, or -1 for non-async.</param>
      <param name="gpuMI">The gpu MI.</param>
      <param name="arguments">The arguments.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyToConstantMemory``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32,Cudafy.KernelConstantInfo)">
      <summary>
            Does the copy to constant memory.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="ci">The ci.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyToConstantMemoryAsync``1(System.IntPtr,System.Int32,System.Array,System.Int32,System.Int32,Cudafy.KernelConstantInfo,System.Int32)">
      <summary>
            Does the copy to constant memory async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="ci">The ci.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyToDevice``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the copy to device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyFromDevice``1(System.Array,System.Array)">
      <summary>
            Does the copy from device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="hostArray">The host array.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyFromDevice``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the copy from device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyToDeviceAsync``1(System.IntPtr,System.Int32,System.Array,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does the copy to device async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyToDeviceAsync``1(System.IntPtr,System.Int32,Cudafy.Host.DevicePtrEx,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does the copy to device async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyToDeviceAsync``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Boolean)">
      <summary>
            Does the copy to device async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
      <param name="stagingPost">The staging post.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyFromDeviceAsync``1(System.Array,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs an asynchronous data transfer.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyFromDeviceAsync``1(Cudafy.Host.DevicePtrEx,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs an asynchronous data transfer.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyFromDeviceAsync``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32,System.Int32,System.IntPtr)">
      <summary>
            Performs an asynchronous data transfer.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
      <param name="stagingPost">The staging post.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDevice``1(``0[],``0[])">
      <summary>
            Copies to preallocated array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="devArray">The device array.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDevice``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies to preallocated array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDevice``1(System.IntPtr,System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies to preallocated array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDeviceAsync``1(``0[],System.Int32,``0[],System.Int32,System.Int32,System.Int32,System.IntPtr)">
      <summary>
            Copies to device asynchronously making use of the previously allocated staging post.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="count">Number of elements.</param>
      <param name="streamId">The stream id.</param>
      <param name="stagingPost">The staging post of equal or greater size to count. Use HostAllocate to create.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDeviceAsync``1(``0[],System.Int32,``0[],System.Int32,System.Int32,System.Int32,System.IntPtr)">
      <summary>
            Copies from device asynchronously making use of the previously allocated staging post.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">Number of elements.</param>
      <param name="streamId">The stream id.</param>
      <param name="stagingPost">The staging post of equal or greater size to count. Use HostAllocate to create.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDeviceAsync``1(System.IntPtr,System.Int32,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies asynchronously to preallocated array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="count">The number of elements.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDeviceAsync``1(System.IntPtr,System.Int32,Cudafy.Host.DevicePtrEx,System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies asynchronously to preallocated array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="count">The number of elements.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDevice``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies from device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The device array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDevice``1(``0[],System.Int32,System.IntPtr,System.Int32,System.Int32)">
      <summary>
            Copies from device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDeviceAsync``1(``0[],System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies from device asynchronously.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The number of elements.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDeviceAsync``1(Cudafy.Host.DevicePtrEx,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies from device asynchronously.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The device offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The number of elements.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.SynchronizeStream(System.Int32)">
      <summary>
            Synchronizes the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.HostAllocate``1(System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs a default host memory allocation.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="x">The x size.</param>
      <param name="y">The y size.</param>
      <param name="z">The z size.</param>
      <returns>Pointer to allocated memory.</returns>
      <remarks>Remember to free this memory with HostFree.</remarks>
    </member>
    <member name="M:Cudafy.Host.GPGPU.HostAllocate``1(System.Int32,System.Int32)">
      <summary>
            Performs a default host memory allocation.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x size.</param>
      <param name="y">The y size.</param>
      <returns>Pointer to allocated memory.</returns>
      <remarks>Remember to free this memory with HostFree.</remarks>
    </member>
    <member name="M:Cudafy.Host.GPGPU.HostAllocate``1(System.Int32)">
      <summary>
            Performs a default host memory allocation.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x size.</param>
      <returns>
            Pointer to allocated memory.
            </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.HostFree(System.IntPtr)">
      <summary>
            Frees memory allocated by HostAllocate.
            </summary>
      <param name="ptr">The pointer.</param>
      <exception cref="T:Cudafy.Host.CudafyHostException">Pointer not found.</exception>
    </member>
    <member name="M:Cudafy.Host.GPGPU.HostFreeAll">
      <summary>
            Frees all memory allocated by HostAllocate.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyMemory(System.IntPtr,System.IntPtr,System.UInt32)">
      <summary>
            Copies memory on host using native CopyMemory function from kernel32.dll.
            </summary>
      <param name="Destination">The destination.</param>
      <param name="Source">The source.</param>
      <param name="Length">The length.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetValue``1(``0[],System.Int32)">
      <summary>
            Gets the value at specified index.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <returns>Value at index.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``2(``0[],System.Int32)">
      <summary>
            Casts the specified dev array.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <typeparam name="U">Type to cast to.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="n">The number of samples.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``1(``0[],System.Int32,System.Int32)">
      <summary>
            Casts the specified dev array to 2D.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``2(``0[],System.Int32,System.Int32)">
      <summary>
            Casts the specified dev array.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <typeparam name="U">Type to cast to.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``1(``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Casts the specified dev array to 3D.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <param name="z">The z.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``2(``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Casts the specified dev array.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <typeparam name="U">Type to cast to.</typeparam>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <param name="z">The z.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``1(System.Int32,``0[],System.Int32)">
      <summary>
            Casts the specified offset.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <param name="offset">The offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="n">The n.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``2(System.Int32,``0[],System.Int32)">
      <summary>
            Casts the specified offset.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <typeparam name="U">Type to cast to.</typeparam>
      <param name="offset">The offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="n">The n.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``1(System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Casts the specified dev array to 2D.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="offset">Offset into dev array.</param>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``2(System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Casts the specified offset.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <typeparam name="U">Type to cast to.</typeparam>
      <param name="offset">The offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``1(System.Int32,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Casts the specified dev array to 3D.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="offset">Offset into dev array.</param>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <param name="z">The z.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Cast``2(System.Int32,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Casts the specified offset.
            </summary>
      <typeparam name="T">Type of dev array.</typeparam>
      <typeparam name="U">Type to cast to.</typeparam>
      <param name="offset">The offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <param name="z">The z.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCast``2(System.Int32,System.Array,System.Int32)">
      <summary>
            Does the cast.
            </summary>
      <typeparam name="T">Type of source array.</typeparam>
      <typeparam name="U">Type of result array.</typeparam>
      <param name="offset">Offset into dev array.</param>
      <param name="devArray">The dev array.</param>
      <param name="n">The n.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCast``2(System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the cast.
            </summary>
      <typeparam name="T">Type of source array.</typeparam>
      <typeparam name="U">Type of result array.</typeparam>
      <param name="offset">Offset into dev array.</param>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCast``2(System.Int32,System.Array,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does the cast.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="U">
      </typeparam>
      <param name="offset">Offset into dev array.</param>
      <param name="devArray">The dev array.</param>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <param name="z">The z.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnHost``1(``0[],System.Int32,System.IntPtr,System.Int32,System.Int32)">
      <summary>
            Copies data on host.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="nativeHostArraySrc">The source native host array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="hostAllocatedMemory">The destination host allocated memory.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyOnHost``1(System.Array,System.Int32,System.IntPtr,System.Int32,System.Int32)">
      <summary>
            Does the copy on host.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="nativeHostArraySrc">The native host array SRC.</param>
      <param name="srcOffset">The SRC offset.</param>
      <param name="hostAllocatedMemory">The host allocated memory.</param>
      <param name="dstOffset">The DST offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnHost``1(System.IntPtr,System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies data on host.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostAllocatedMemory">The source host allocated memory.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="nativeHostArrayDst">The destination native host array.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyOnHost``1(System.IntPtr,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the copy on host.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostAllocatedMemory">The host allocated memory.</param>
      <param name="srcOffset">The SRC offset.</param>
      <param name="nativeHostArrayDst">The native host array DST.</param>
      <param name="dstOffset">The DST offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does the copy.
            </summary>
      <param name="srcArray">The source array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstArray">The destination array.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The count.</param>
      <param name="size">The size.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopy``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the copy.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="srcArray">The source array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstArray">The destination array.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32,System.Type)">
      <summary>
            Does the copy.
            </summary>
      <param name="srcArray">The source array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstArray">The destination array.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The count.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DestroyStream(System.Int32)">
      <summary>
            Destroys the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DestroyStreams">
      <summary>
            Destroys all streams.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDevice(System.String)">
      <summary>
            Allocates Unicode character array on device, copies to device and returns pointer.
            </summary>
      <param name="text">The text.</param>
      <returns>The device array.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyToDevice``1(``0[])">
      <summary>
            Allocates array on device, copies to device and returns pointer.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <returns>The device array.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDevice``1(``0[],``0@)">
      <summary>
            Copies from device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The device array.</param>
      <param name="hostData">The host data.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyFromDevice``1(``0[],``0[])">
      <summary>
            Copies the complete device array to the host array.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The device array.</param>
      <param name="hostArray">The host array.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnDevice``1(``0[],``0[])">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="dstDevArray">The destination device array.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnDevice``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffset">The destination offet.</param>
      <param name="count">The number of element.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnDevice``1(Cudafy.Host.DevicePtrEx,System.Int32,Cudafy.Host.DevicePtrEx,System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffset">The destination offet.</param>
      <param name="count">The number of element.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnDeviceAsync``1(``0[],System.Int32,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffset">The destination offet.</param>
      <param name="count">The number of element.</param>
      <param name="streamId">Stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.CopyOnDeviceAsync``1(Cudafy.Host.DevicePtrEx,System.Int32,Cudafy.Host.DevicePtrEx,System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffset">The destination offet.</param>
      <param name="count">The number of element.</param>
      <param name="streamId">Stream id.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoCopyOnDevice``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffet">The destination offet.</param>
      <param name="count">The number of element.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.EnableSmartCopy">
      <summary>
            Enables smart copy. The overloads of CopyToDeviceAsync and CopyFromDeviceAsync using pinned memory staging posts
            is now possible. If multithreading is not enabled this will be done automatically.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DisableSmartCopy">
      <summary>
            Disables smart copy and multithreading if this was set automatically during smart copy enable.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Allocate``1">
      <summary>
            Allocates on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <returns>Device array of length 1.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Allocate``1(System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">Length of 1D array.</param>
      <returns>Device array of length x.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Allocate``1(System.Int32,System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x dimension.</param>
      <param name="y">The y dimension.</param>
      <returns>2D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Allocate``1(System.Int32,System.Int32,System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x dimension.</param>
      <param name="y">The y dimension.</param>
      <param name="z">The z dimension.</param>
      <returns>3D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Allocate``1(``0[])">
      <summary>
            Allocates array on device of same size as supplied host array.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <returns>1D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Set``1(``0[])">
      <summary>
            Sets the specified device array to zero.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The device array.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Set``1(``0[],System.Int32,System.Int32)">
      <summary>
            Sets the specified device array to zero.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="devArray">The device array.</param>
      <param name="offset">The offset.</param>
      <param name="count">The number of elements.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.DoSet``1(System.Array,System.Int32,System.Int32)">
      <summary>
            Does the set.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="offset">The offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.Free(System.Object)">
      <summary>
            Frees the specified data array on device.
            </summary>
      <param name="devArray">The device array to free.</param>
    </member>
    <member name="M:Cudafy.Host.GPGPU.FreeAll">
      <summary>
            Frees all data arrays on device.
            </summary>
    </member>
    <member name="M:Cudafy.Host.GPGPU.VerifyMembersAreOnGPU(System.Object[])">
      <summary>
            Verifies launch arguments are on GPU and are supported.
            </summary>
      <param name="args">The arguments.</param>
      <exception cref="T:System.ArgumentException">Argument is either not on GPU or not supported.</exception>
    </member>
    <member name="M:Cudafy.Host.GPGPU.VerifyOnGPU(System.Object)">
      <summary>
            Verifies the specified data is on GPU.
            </summary>
      <param name="data">The data.</param>
      <exception cref="T:Cudafy.Host.CudafyHostException">Data is not on GPU.</exception>
    </member>
    <member name="M:Cudafy.Host.GPGPU.IsOnGPU(System.Object)">
      <summary>
            Determines whether the specified data is on GPU.
            </summary>
      <param name="data">The data.</param>
      <returns>
        <c>true</c> if the specified data is on GPU; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetGPUData(System.Object)">
      <summary>
            Gets the pointer to the native GPU data.
            </summary>
      <param name="data">The data.</param>
      <returns>Pointer to the actual data.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.MSizeOf(System.Type)">
      <summary>
            Gets the size of the type specified. Note that this differs from Marshal.SizeOf for System.Char (it returns 2 instead of 1).
            </summary>
      <param name="t">The type to get the size of.</param>
      <returns>Size of type in bytes.</returns>
    </member>
    <member name="M:Cudafy.Host.GPGPU.GetDriverVersion">
      <summary>
            Gets the version.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Host.GPGPU.DeviceId">
      <summary>
            Gets the device id.
            </summary>
    </member>
    <member name="P:Cudafy.Host.GPGPU.IsDisposed">
      <summary>
            Gets a value indicating whether this instance is disposed.
            </summary>
      <value>
        <c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.IsLocked">
      <summary>
            Gets a value indicating whether this instance is locked.
            </summary>
      <value>
        <c>true</c> if this instance is locked; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.IsMultithreadingEnabled">
      <summary>
            Gets a value indicating whether this instance has multithreading enabled.
            </summary>
      <value>
        <c>true</c> if this instance is multithreading enabled; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.IsCurrentContext">
      <summary>
            Gets a value indicating whether this instance is current context. You must ensure this is true before 
            attempting communication with device.
            </summary>
      <value>
        <c>true</c> if this instance is current context; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.FreeMemory">
      <summary>
            Gets the free memory.
            </summary>
      <value>The free memory.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.TotalMemory">
      <summary>
            Gets the total memory.
            </summary>
      <value>The total memory.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.Modules">
      <summary>
            Gets the modules.
            </summary>
    </member>
    <member name="P:Cudafy.Host.GPGPU.CurrentModule">
      <summary>
            Gets the current module.
            </summary>
      <value>The current module.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.IsSmartCopyEnabled">
      <summary>
            Gets a value indicating whether this instance is smart copy enabled.
            </summary>
      <value>
        <c>true</c> if this instance is smart copy enabled; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPU.SupportsSmartCopy">
      <summary>
            Gets or sets a value indicating whether device supports smart copy.
            </summary>
      <value>
        <c>true</c> if supports smart copy; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.Host.CudaGPU">
      <summary>
            Represents a Cuda GPU.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CudaGPU" /> class.
            </summary>
      <param name="deviceId">The device id.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.EnablePeerAccess(Cudafy.Host.GPGPU)">
      <summary>
            Enables peer access from within a kernel. Only supported on Tesla devices and Linux or Windows TCC.
            </summary>
      <param name="peer">Peer to access. This is a one-way relationship.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.DisablePeerAccess(Cudafy.Host.GPGPU)">
      <summary>
            Disables peer access.
            </summary>
      <param name="peer">Accessible peer to disable access to.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.CanAccessPeer(Cudafy.Host.GPGPU)">
      <summary>
            Use this to check if device supports direct access from kernel to another device.
            Only supported on Tesla devices and Linux or Windows TCC.
            </summary>
      <param name="peer">Peer to access.</param>
      <returns>
            True if access is possible, else false.
            </returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.GetStream(System.Int32)">
      <summary>
            Gets the CUstream object identified by streamId.
            </summary>
      <param name="streamId">The stream id.</param>
      <returns>CUstream object.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Lock">
      <summary>
            Locks this instance.
            </summary>
      <exception cref="T:Cudafy.Host.CudafyHostException">Multithreading is not enabled.</exception>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Unlock">
      <summary>
            Unlocks this instance.
            </summary>
      <exception cref="T:Cudafy.Host.CudafyHostException">Device is not locked.</exception>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.EnableMultithreading">
      <summary>
            Allows multiple threads to access this GPU.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.DisableMultithreading">
      <summary>
            Called once multiple threads have completed work.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.SetCurrentContext">
      <summary>
            Sets the current context to the context associated with this device when it was created.
            Use of this method is vitally important when working with multiple GPUs.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.GetDeviceProperties(System.Boolean)">
      <summary>
            Gets the device properties.
            </summary>
      <param name="useAdvanced">If true then also get properties via cudart.dll (e.g. MultiProcessorCount).</param>
      <returns>Device properties instance.</returns>
      <exception cref="T:Cudafy.Host.CudafyHostException">Failed to get properties.</exception>
      <exception cref="T:System.DllNotFoundException">Library named cudart.dll is needed for advanced properties and was not found.</exception>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Synchronize">
      <summary>
            Synchronizes context.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.StartTimer">
      <summary>
            Starts the timer.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.StopTimer">
      <summary>
            Stops the timer.
            </summary>
      <returns>Elapsed time.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.CreateStream(System.Int32)">
      <summary>
            Explicitly creates a stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.DoLaunch(Cudafy.dim3,Cudafy.dim3,System.Int32,Cudafy.KernelMethodInfo,System.Object[])">
      <summary>
            Does the launch.
            </summary>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id, or -1 for non-async.</param>
      <param name="gpuMethodInfo">The gpu method info.</param>
      <param name="arguments">The arguments.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.SynchronizeStream(System.Int32)">
      <summary>
            Synchronizes the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.DestroyStream(System.Int32)">
      <summary>
            Destroys the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.DestroyStreams">
      <summary>
            Destroys all streams.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.HostAllocate``1(System.Int32)">
      <summary>
            Performs a default host memory allocation.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x size.</param>
      <returns>
            Pointer to allocated memory.
            </returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.HostFree(System.IntPtr)">
      <summary>
            Frees memory allocated by HostAllocate.
            </summary>
      <param name="ptr">The pointer.</param>
      <exception cref="T:Cudafy.Host.CudafyHostException">Pointer not found.</exception>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.HostFreeAll">
      <summary>
            Frees all memory allocated by HostAllocate. Disables smart copy.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.CopyToDevice``1(``0[])">
      <summary>
            Allocates array on device, copies to device and returns pointer.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <returns>The device array.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.CopyOnDevice``1(``0[],``0[])">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="dstDevArray">The destination device array.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.DoCopyOnDevice``1(Cudafy.Host.DevicePtrEx,System.Int32,Cudafy.Host.DevicePtrEx,System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffet">The destination offet.</param>
      <param name="count">The number of element.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Allocate``1">
      <summary>
            Allocates on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <returns>Device array of length 1.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Allocate``1(System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">Length of 1D array.</param>
      <returns>Device array of length x.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Allocate``1(System.Int32,System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x dimension.</param>
      <param name="y">The y dimension.</param>
      <returns>2D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Allocate``1(System.Int32,System.Int32,System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x dimension.</param>
      <param name="y">The y dimension.</param>
      <param name="z">The z dimension.</param>
      <returns>3D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Allocate``1(``0[])">
      <summary>
            Allocates array on device of same size as supplied host array.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <returns>1D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.Free(System.Object)">
      <summary>
            Frees the specified data array on device.
            </summary>
      <param name="devArray">The device array to free.</param>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.FreeAll">
      <summary>
            Frees all data arrays on device.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.GetDeviceCount">
      <summary>
            Gets the device count.
            </summary>
      <returns>Number of Cuda devices in system.</returns>
    </member>
    <member name="M:Cudafy.Host.CudaGPU.GetGPUData(System.Object)">
      <summary>
            Gets the pointer to the native GPU data.
            </summary>
      <param name="data">The data.</param>
      <returns>
            Pointer to the actual data. This can be cast to GASS.CUDA.Types.CUdeviceptr.
            </returns>
    </member>
    <member name="P:Cudafy.Host.CudaGPU.IsLocked">
      <summary>
            Gets a value indicating whether this instance is locked.
            </summary>
      <value>
        <c>true</c> if this instance is locked; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.CudaGPU.IsMultithreadingEnabled">
      <summary>
            Gets a value indicating whether this instance has multithreading enabled.
            </summary>
      <value>
        <c>true</c> if this instance is multithreading enabled; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.CudaGPU.IsCurrentContext">
      <summary>
            Gets a value indicating whether this instance is current context. You must ensure this is true before
            attempting communication with device.
            </summary>
      <value>
        <c>true</c> if this instance is current context; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.CudaGPU.CudaDotNet">
      <summary>
            Gets the CUDA.NET handle. You can cast this to CUDA in the GASS.CUDA namespace.
            See http://www.hoopoe-cloud.com/Solutions/CUDA.NET/Default.aspx
            </summary>
    </member>
    <member name="P:Cudafy.Host.CudaGPU.FreeMemory">
      <summary>
            Gets the free memory.
            </summary>
      <value>The free memory.</value>
    </member>
    <member name="P:Cudafy.Host.CudaGPU.TotalMemory">
      <summary>
            Gets the total memory.
            </summary>
      <value>
            The total memory.
            </value>
    </member>
    <member name="T:Cudafy.Host.DevicePtrEx">
      <summary>
            Base class for Device data pointers
            </summary>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.DevicePtrEx" /> class.
            </summary>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.GetOffset1D(System.Int32)">
      <summary>
            Gets the offset1 D.
            </summary>
      <param name="x">The x.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.GetOffset1D(System.Int32,System.Int32)">
      <summary>
            Gets the offset1 D.
            </summary>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.GetOffset1D(System.Int32,System.Int32,System.Int32)">
      <summary>
            Gets the offset1 D.
            </summary>
      <param name="x">The x.</param>
      <param name="y">The y.</param>
      <param name="z">The z.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.GetDimensions">
      <summary>
            Gets the dimensions.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.AddChild(Cudafy.Host.DevicePtrEx)">
      <summary>
            Adds the child.
            </summary>
      <param name="ptrEx">The PTR ex.</param>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.RemoveChildren">
      <summary>
            Removes the children.
            </summary>
    </member>
    <member name="M:Cudafy.Host.DevicePtrEx.GetAllChildren">
      <summary>
            Gets all children.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.XSize">
      <summary>
            Gets the size of the X.
            </summary>
      <value>
            The size of the X.
            </value>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.YSize">
      <summary>
            Gets the size of the Y.
            </summary>
      <value>
            The size of the Y.
            </value>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.ZSize">
      <summary>
            Gets the size of the Z.
            </summary>
      <value>
            The size of the Z.
            </value>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.Dimensions">
      <summary>
            Gets the number of dimensions (rank).
            </summary>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.TotalSize">
      <summary>
            Gets the total size.
            </summary>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.Pointer">
      <summary>
            Gets the pointer when overridden.
            </summary>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.Offset">
      <summary>
            Gets or sets the offset.
            </summary>
      <value>
            The offset.
            </value>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.Disposed">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Cudafy.Host.DevicePtrEx" /> is disposed.
            </summary>
      <value>
        <c>true</c> if disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.Children">
      <summary>
            Gets the level 1 children.
            </summary>
    </member>
    <member name="P:Cudafy.Host.DevicePtrEx.CreatedFromCast">
      <summary>
            Gets a value indicating whether created from cast.
            </summary>
      <value>
        <c>true</c> if created from cast; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.Host.CUDevicePtrEx">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.#ctor(GASS.CUDA.Types.CUdeviceptr,System.Nullable{GASS.CUDA.Types.CUcontext})">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.#ctor(GASS.CUDA.Types.CUdeviceptr,System.Int32,System.Nullable{GASS.CUDA.Types.CUcontext})">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="xSize">Size of the x.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.Cast``1(Cudafy.Host.CUDevicePtrEx,System.Int32,System.Int32)">
      <summary>
            Casts the specified pointer.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="ptrEx">The pointer.</param>
      <param name="offset">The offset.</param>
      <param name="xSize">Size of the x.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.#ctor(GASS.CUDA.Types.CUdeviceptr,System.Int32,System.Int32,System.Nullable{GASS.CUDA.Types.CUcontext})">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="xSize">Size of the x.</param>
      <param name="ySize">Size of the y.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.Cast``1(Cudafy.Host.CUDevicePtrEx,System.Int32,System.Int32,System.Int32)">
      <summary>
            Casts the specified pointer.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="ptrEx">The pointer.</param>
      <param name="offset">The offset.</param>
      <param name="xSize">Size of the x.</param>
      <param name="ySize">Size of the y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.#ctor(GASS.CUDA.Types.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Nullable{GASS.CUDA.Types.CUcontext})">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="xSize">Size of the x.</param>
      <param name="ySize">Size of the y.</param>
      <param name="zSize">Size of the z.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CUDevicePtrEx.Cast``1(Cudafy.Host.CUDevicePtrEx,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Casts the specified pointer.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="ptrEx">The pointer.</param>
      <param name="offset">The offset.</param>
      <param name="xSize">Size of the x.</param>
      <param name="ySize">Size of the y.</param>
      <param name="zSize">Size of the z.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Host.CUDevicePtrEx.DevPtr">
      <summary>
            Gets the dev PTR.
            </summary>
    </member>
    <member name="P:Cudafy.Host.CUDevicePtrEx.Pointer">
      <summary>
            Gets the IntPtr in DevPtr.
            </summary>
    </member>
    <member name="P:Cudafy.Host.CUDevicePtrEx.Context">
      <summary>
            Gets the context.
            </summary>
    </member>
    <member name="T:Cudafy.Host.DeviceTypeInfo">
      <summary>
            For a class, and instance of which we want to move onto the Device, we create a new representation of the instance on the device.
            This is the DeviceType, which basically has reference type fields replaced by IntPtrs to device memory.
            </summary>
    </member>
    <member name="T:Cudafy.Host.DeviceClassHelper">
      <summary>
            Helper that can create an instance of a class or struct on the device, given an instance of
            a Cudafyable class on the CPU.
            Any reference type members of the class become pointers to the member (in device memory). 
            Any value type members must be blittable.
            A one-to-one map of objects on the host and objects on the device is maintained so that instances that share an array on
            the host share the same array on the device.
            </summary>
    </member>
    <member name="F:Cudafy.Host.DeviceClassHelper.deviceObjectFromHostObject">
      <summary>
            This provides a mapping of the host object to the object that encapsulates the device pointer (via _deviceMemory).
            </summary>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.TryGetDeviceObjectFromHostObject(Cudafy.Host.GPGPU,System.Object)">
      <summary>
            Returns the device object that is mapped to the host object.
            </summary>
      <param name="gpu">
      </param>
      <param name="hostObject">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.TryGetDeviceMemoryFromHostObject(Cudafy.Host.GPGPU,System.Object)">
      <summary>
            Returns the device pointer for the device object that is mapped to the host object.
            </summary>
      <param name="gpu">
      </param>
      <param name="hostObject">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.CreateDeviceObject``1(Cudafy.Host.GPGPU,``0)">
      <summary>
            Creates a version of hostObject on the device with any fields which are reference types converted
            to pointers to device memory (IntPtrs) and any arrays copied to the device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="gpu">
      </param>
      <param name="hostObject">
      </param>
      <returns>THe device object (that can then be used in kernal calls).</returns>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.UpdateFromDevice``1(Cudafy.Host.GPGPU,``0)">
      <summary>
            Update any array fields of an object where the arrays are on the device. 
            </summary>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.CopyReferenceTypeFieldsToDevice``1(Cudafy.Host.GPGPU,``0)">
      <summary>
            Copies any reference type fields (e.g. arrays) of the object to the device.
            </summary>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.CreateDeviceType(System.Type)">
      <summary>
            Create type that contains pointers to device arrays.
            </summary>
    </member>
    <member name="M:Cudafy.Host.DeviceClassHelper.GetFieldsStandardLayout(System.Type)">
      <summary>
            Get fields in the same order in which these would appear in memory for the device object (i.e. standard layout rules).
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Cudafy.Host.DynamicLauncher">
      <summary>
            Allows GPU functions to be called using dynamic language run-time. For example:
            gpgpu.Launch(16, 16).myGPUFunction(x, y, res)
            </summary>
    </member>
    <member name="M:Cudafy.Host.DynamicLauncher.#ctor(Cudafy.Host.GPGPU)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.DynamicLauncher" /> class.
            </summary>
      <param name="gpu">The gpu.</param>
    </member>
    <member name="M:Cudafy.Host.DynamicLauncher.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>
            Provides the implementation for operations that invoke a member. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as calling a method.
            </summary>
      <param name="binder">Provides information about the dynamic operation. The binder.Name property provides the name of the member on which the dynamic operation is performed. For example, for the statement sampleObject.SampleMethod(100), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, binder.Name returns "SampleMethod". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
      <param name="args">The arguments that are passed to the object member during the invoke operation. For example, for the statement sampleObject.SampleMethod(100), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <paramref name="args" /> is equal to 100.</param>
      <param name="result">The result of the member invocation.</param>
      <returns>
            true if the operation is successful; otherwise, false. If this method returns false, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)
            </returns>
    </member>
    <member name="M:Cudafy.Host.DynamicLauncher.GetDynamicMemberNames">
      <summary>
            Returns the enumeration of all global functions.
            </summary>
      <returns>
            A sequence that contains global function names.
            </returns>
    </member>
    <member name="P:Cudafy.Host.DynamicLauncher.GPU">
      <summary>
            Gets the GPU.
            </summary>
    </member>
    <member name="P:Cudafy.Host.DynamicLauncher.GridSize">
      <summary>
            Gets or sets the size of the grid.
            </summary>
      <value>
            The size of the grid.
            </value>
    </member>
    <member name="P:Cudafy.Host.DynamicLauncher.BlockSize">
      <summary>
            Gets or sets the size of the block.
            </summary>
      <value>
            The size of the block.
            </value>
    </member>
    <member name="P:Cudafy.Host.DynamicLauncher.StreamId">
      <summary>
            Gets or sets the stream id.
            </summary>
      <value>
            The stream id.
            </value>
    </member>
    <member name="T:Cudafy.Host.EmulatedGPU">
      <summary>
            Represents an emulated Cuda GPU.
            </summary>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.EmulatedGPU" /> class.
            </summary>
      <param name="deviceId">The device id.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.GetDeviceProperties(System.Boolean)">
      <summary>
            Gets the device properties.
            </summary>
      <returns>Device properties instance.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.GetDeviceCount">
      <summary>
            Gets the device count.
            </summary>
      <returns>Number of devices of this type.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.Synchronize">
      <summary>
            Synchronizes context.
            </summary>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoLaunch(Cudafy.dim3,Cudafy.dim3,System.Int32,Cudafy.KernelMethodInfo,System.Object[])">
      <summary>
            Does the launch.
            </summary>
      <param name="gridSize">Size of the grid.</param>
      <param name="blockSize">Size of the block.</param>
      <param name="streamId">Stream id, or -1 for non-async.</param>
      <param name="gpuMethodInfo">The gpu method info.</param>
      <param name="arguments">The arguments.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyToConstantMemory``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32,Cudafy.KernelConstantInfo)">
      <summary>
            Does the copy to constant memory.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="ci">The ci.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyToDevice``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the copy to device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyFromDevice``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Does the copy from device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyToDeviceAsync``1(System.IntPtr,System.Int32,Cudafy.Host.DevicePtrEx,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does the copy to device async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyFromDeviceAsync``1(Cudafy.Host.DevicePtrEx,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)">
      <summary>
            Does the copy from device async.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="devOffset">The dev offset.</param>
      <param name="hostArray">The host array.</param>
      <param name="hostOffset">The host offset.</param>
      <param name="count">The count.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyFromDevice``1(System.Array,System.Array)">
      <summary>
            Does the copy from device.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="hostArray">The host array.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.CopyToDevice``1(``0[])">
      <summary>
            Allocates array on device, copies to device and returns pointer.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <returns>The device array.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.Allocate``1(System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">Length of 1D array.</param>
      <returns>Device array of length x.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.Allocate``1(System.Int32,System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x dimension.</param>
      <param name="y">The y dimension.</param>
      <returns>2D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.Allocate``1(System.Int32,System.Int32,System.Int32)">
      <summary>
            Allocates array on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x dimension.</param>
      <param name="y">The y dimension.</param>
      <param name="z">The z dimension.</param>
      <returns>3D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.Allocate``1(``0[])">
      <summary>
            Allocates array on device of same size as supplied host array.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="hostArray">The host array.</param>
      <returns>1D device array.</returns>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoSet``1(System.Array,System.Int32,System.Int32)">
      <summary>
            Does the set.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="devArray">The dev array.</param>
      <param name="offset">The offset.</param>
      <param name="count">The count.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.Free(System.Object)">
      <summary>
            Frees the specified data array on device.
            </summary>
      <param name="devArray">The device array to free.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.CopyOnDevice``1(``0[],``0[])">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="dstDevArray">The destination device array.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DoCopyOnDevice``1(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
      <summary>
            Copies between preallocated arrays on device.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="srcDevArray">The source device array.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstDevArray">The destination device array.</param>
      <param name="dstOffet">The destination offet.</param>
      <param name="count">The number of element.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.SynchronizeStream(System.Int32)">
      <summary>
            Synchronizes the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DestroyStream(System.Int32)">
      <summary>
            Destroys the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.EmulatedGPU.DestroyStreams">
      <summary>
            Destroys all streams.
            </summary>
    </member>
    <member name="P:Cudafy.Host.EmulatedGPU.FreeMemory">
      <summary>
            Gets the free memory.
            </summary>
      <value>The free memory.</value>
    </member>
    <member name="P:Cudafy.Host.EmulatedGPU.TotalMemory">
      <summary>
            Gets the total memory.
            </summary>
      <value>
            The total memory.
            </value>
    </member>
    <member name="T:Cudafy.Host.EmuDevicePtrEx">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:Cudafy.Host.EmuDevicePtrEx.#ctor(System.Int32,System.Array,System.Int32[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.EmuDevicePtrEx" /> class.
            </summary>
      <param name="offset">Offset in samples.</param>
      <param name="devPtr">The dev pointer.</param>
      <param name="dimensions">The dimensions.</param>
    </member>
    <member name="M:Cudafy.Host.EmuDevicePtrEx.GetDevPtrPtr(System.Int64)">
      <summary>
            Gets the native pointer to the data. FreeHandle() must be called afterwards.
            </summary>
      <param name="offset">Offset in bytes.</param>
      <returns>Pointer</returns>
    </member>
    <member name="M:Cudafy.Host.EmuDevicePtrEx.FreeHandle">
      <summary>
            Frees the handle allocated by GetDevPtrPtr
            </summary>
    </member>
    <member name="P:Cudafy.Host.EmuDevicePtrEx.DevPtr">
      <summary>
            Gets the dev PTR.
            </summary>
    </member>
    <member name="P:Cudafy.Host.EmuDevicePtrEx.OffsetBytes">
      <summary>
            Gets the offset in bytes.
            </summary>
    </member>
    <member name="P:Cudafy.Host.EmuDevicePtrEx.Pointer">
      <summary>
            Gets the native pointer.
            </summary>
    </member>
    <member name="T:Cudafy.Host.CudafyHostException">
      <summary>
            Exceptions for host.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CudafyHostException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CudafyHostException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.Host.CudafyHostException.#ctor(System.Exception,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CudafyHostException" /> class.
            </summary>
      <param name="inner">The inner.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.Host.CudafyHostException.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CudafyHostException" /> class.
            </summary>
      <param name="errMsg">The err MSG.</param>
      <param name="args">The args.</param>
    </member>
    <member name="M:Cudafy.Host.CudafyHostException.#ctor(System.Exception,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CudafyHostException" /> class.
            </summary>
      <param name="inner">The inner exception.</param>
      <param name="errMsg">The err message.</param>
      <param name="args">The parameters.</param>
    </member>
    <member name="T:Cudafy.Host.IntPtrEx">
      <summary>
            Extension methods for IntPtr to allow easy access to values. Typically used with HostAllocated memory.
            </summary>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.AddOffset``1(System.IntPtr,System.Int64)">
      <summary>
            Allows for x86 AND x64 pointer arithmetic
            </summary>
      <typeparam name="T">type pointed to</typeparam>
      <param name="pt">
      </param>
      <param name="offset">Offsets the prt by a number of bytes equal to offset+sizeof(T)</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Set(System.IntPtr,System.Int32,System.Int32)">
      <summary>
            Sets the specified value.
            </summary>
      <param name="ptr">The host allocated memory.</param>
      <param name="offset">The offset.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Set(System.IntPtr,System.Int32,System.UInt32)">
      <summary>
            Sets the specified value.
            </summary>
      <param name="ptr">The host allocated memory.</param>
      <param name="offset">The offset.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Set(System.IntPtr,System.Int32,System.Int64)">
      <summary>
            Sets the specified host allocated memory.
            </summary>
      <param name="ptr">The host allocated memory.</param>
      <param name="offset">The offset.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Set(System.IntPtr,System.Int32,System.UInt64)">
      <summary>
            Sets the specified value.
            </summary>
      <param name="ptr">The host allocated memory.</param>
      <param name="offset">The offset.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Set(System.IntPtr,System.Int32,System.Single)">
      <summary>
            Sets the specified value.
            </summary>
      <param name="ptr">The host allocated memory.</param>
      <param name="offset">The offset.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Set(System.IntPtr,System.Int32,System.Double)">
      <summary>
            Sets the specified value.
            </summary>
      <param name="ptr">The host allocated memory.</param>
      <param name="offset">The offset.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Write``1(System.IntPtr,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Writes the specified data array to the IntPtr.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="ptr">The host allocated memory.</param>
      <param name="srcData">The source data.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The number of elements (set to zero for automatic).</param>
    </member>
    <member name="M:Cudafy.Host.IntPtrEx.Read``1(System.IntPtr,``0[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Reads from the IntPtr to the specified data array.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="ptr">The host allocated memory.</param>
      <param name="dstData">The destination data.</param>
      <param name="srcOffset">The source offset.</param>
      <param name="dstOffset">The destination offset.</param>
      <param name="count">The number of elements (set to zero for automatic).</param>
    </member>
    <member name="T:Cudafy.Host.GPGPUProperties">
      <summary>
            Represents the generic properties of a GPGPU device. Not all properties will be relevant
            to a particular GPGPU device.
            </summary>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.SupportsDoublePrecision">
      <summary>
            Gets a value indicating whether device supports code containing double precision.
            Although early CUDA devices do not support double, it is still possible to write code containing doubles.
            For many AMD GPUs this is not the case.
            </summary>
      <value>
        <c>true</c> if supports double precision; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.IsSimulated">
      <summary>
            Gets a value indicating whether this instance is simulated or emulated.
            </summary>
      <value>
        <c>true</c> if this instance is simulated or emulated; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.Capability">
      <summary>
            Gets the capability.
            </summary>
      <value>The capability.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.Name">
      <summary>
            Gets the name.
            </summary>
      <value>The name.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.PlatformName">
      <summary>
            Gets the name of the platform.
            </summary>
      <value>
            The name of the platform.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.DeviceId">
      <summary>
            Gets the device id.
            </summary>
      <value>The device id.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.TotalMemory">
      <summary>
            Gets the total memory.
            </summary>
      <value>The total memory.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.ClockRate">
      <summary>
            Gets the clock rate.
            </summary>
      <value>The clock rate.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.MaxGridSize">
      <summary>
            Gets the max size of the grid.
            </summary>
      <value>The max size of the grid.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.MaxThreadsSize">
      <summary>
            Gets the max number of threads.
            </summary>
      <value>The max number of threads.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.MaxThreadsPerBlock">
      <summary>
            Gets the max number of threads per block.
            </summary>
      <value>The max number of threads per block.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.MemoryPitch">
      <summary>
            Gets the memory pitch.
            </summary>
      <value>The memory pitch.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.RegistersPerBlock">
      <summary>
            Gets the registers per block.
            </summary>
      <value>The registers per block.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.SharedMemoryPerBlock">
      <summary>
            Gets the shared memory per block.
            </summary>
      <value>The shared memory per block.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.WarpSize">
      <summary>
            Gets the size of the warp.
            </summary>
      <value>The size of the warp.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.TotalConstantMemory">
      <summary>
            Gets the total constant memory.
            </summary>
      <value>The total constant memory.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.TextureAlignment">
      <summary>
            Gets the texture alignment.
            </summary>
      <value>The texture alignment.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.UseAdvanced">
      <summary>
            Gets a value indicating whether advanced was used.
            </summary>
      <value>
        <c>true</c> if advanced used; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.MultiProcessorCount">
      <summary>
            Gets the multi processor count. UseAdvanced must be set to true.
            </summary>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.MaxThreadsPerMultiProcessor">
      <summary>
            Gets the max number of threads per multi processor. UseAdvanced must be set to true.
            </summary>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.CanMapHostMemory">
      <summary>
            Gets a value indicating whether this instance can map host memory.
            </summary>
      <value>
        <c>true</c> if this instance can map host memory; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.ConcurrentKernels">
      <summary>
            Gets the number of concurrent kernels.
            </summary>
      <value>The concurrent kernels.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.ComputeMode">
      <summary>
            Gets the compute mode.
            </summary>
      <value>The compute mode.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.DeviceOverlap">
      <summary>
            Gets a value indicating whether device overlap supported.
            </summary>
      <value>
        <c>true</c> if device overlap supported; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.ECCEnabled">
      <summary>
            Gets a value indicating whether ECC enabled.
            </summary>
      <value>
        <c>true</c> if ECC enabled; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.Integrated">
      <summary>
            Gets a value indicating whether GPU is integrated.
            </summary>
      <value>
        <c>true</c> if integrated; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.KernelExecTimeoutEnabled">
      <summary>
            Gets a value indicating whether kernel execution timeout enabled.
            </summary>
      <value>
        <c>true</c> if kernel execution timeout enabled; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.PciBusID">
      <summary>
            Gets the pci bus ID.
            </summary>
      <value>The pci bus ID.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.PciDeviceID">
      <summary>
            Gets the pci device ID.
            </summary>
      <value>The pci device ID.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.TotalGlobalMem">
      <summary>
            Gets the total global memory.
            </summary>
      <value>The total global memory.</value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.HighPerformanceDriver">
      <summary>
            Gets a value indicating whether device is using HighPerformanceDriver driver (tcc in Windows).
            </summary>
      <value>
        <c>true</c> if performance driver; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.GPGPUProperties.AsynchEngineCount">
      <summary>
            Gets the number of asynchronous engines.
            </summary>
      <value>The number of asynchronous engines.</value>
    </member>
    <member name="M:Cudafy.Host.CL11_ex.EnqueueFillBuffer(Cloo.Bindings.CLCommandQueueHandle,Cloo.Bindings.CLMemoryHandle,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Cloo.Bindings.CLEventHandle[],Cloo.Bindings.CLEventHandle[])">
      <summary>
            See the OpenCL specification.
            </summary>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CudaGPU" /> class.
            </summary>
      <param name="deviceId">The device id.</param>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.GetDeviceCount">
      <summary>
            Gets the device count.
            </summary>
      <returns>Number of Cuda devices in system.</returns>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.GetStream(System.Int32,Cloo.ComputeCommandQueueFlags)">
      <summary>
            Gets the ComputeCommandQueue object identified by streamId.
            </summary>
      <param name="streamId">The stream id.</param>
      <param name="flags">Extra flags for queue creation.</param>
      <returns>ComputeCommandQueue object.</returns>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.GetStream(System.Int32)">
      <summary>
            Gets the ComputeCommandQueue object identified by streamId.
            </summary>
      <param name="streamId">The stream id.</param>
      <returns>ComputeCommandQueue object.</returns>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.CreateStream(System.Int32)">
      <summary>
            Explicitly creates a stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.CreateStream(System.Int32,Cloo.ComputeCommandQueueFlags)">
      <summary>
            Explicitly creates a stream.
            </summary>
      <param name="streamId">The stream id.</param>
      <param name="flags">Extra flags for queue creation.</param>
      <returns>Command queue.</returns>
    </member>
    <member name="M:Cudafy.Host.OpenCLDevice.HostAllocate``1(System.Int32)">
      <summary>
            Performs an aligned host memory allocation.
            </summary>
      <typeparam name="T">Blittable type.</typeparam>
      <param name="x">The x size.</param>
      <returns>
            Pointer to allocated memory.
            </returns>
    </member>
    <member name="P:Cudafy.Host.OpenCLDevice.SupportsSmartCopy">
      <summary>
            Gets or sets a value indicating whether device supports smart copy.
            </summary>
      <value>
        <c>true</c> if supports smart copy; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Host.OpenCLDevice.FreeMemory">
      <summary>
            Gets the free memory available on device. Note that this is very approximate and does not
            take into account any other applications including OS graphics that may be using the device.
            It merely subtracts all allocated memory from the TotalMemory.
            </summary>
      <value>
            The free memory.
            </value>
    </member>
    <member name="P:Cudafy.Host.OpenCLDevice.MemsetArraySize">
      <summary>
            Gets or sets the size of the array used for Set operations in OpenCL 1.0 and 1.1 devices.
            </summary>
      <value>
            The size of the memset array.
            </value>
    </member>
    <member name="P:Cudafy.Host.CLDevicePtrExInter.DevPtr_base">
      <summary>
            stores the dev PTR in its base form without generic types.
            </summary>
    </member>
    <member name="P:Cudafy.Host.CLDevicePtrExInter.ElementSize">
      <summary>
            Gets or sets the size of the element.
            </summary>
      <value>
            The size of the element.
            </value>
    </member>
    <member name="T:Cudafy.Host.CLDevicePtrEx`1">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:Cudafy.Host.CLDevicePtrEx`1.#ctor(Cloo.ComputeBuffer{`0},Cloo.ComputeContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CLDevicePtrEx`1.#ctor(Cloo.ComputeBuffer{`0},System.Int32,Cloo.ComputeContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="xSize">Size of the x.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CLDevicePtrEx`1.#ctor(Cloo.ComputeBuffer{`0},System.Int32,System.Int32,Cloo.ComputeContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="xSize">Size of the x.</param>
      <param name="ySize">Size of the y.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:Cudafy.Host.CLDevicePtrEx`1.#ctor(Cloo.ComputeBuffer{`0},System.Int32,System.Int32,System.Int32,Cloo.ComputeContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Host.CUDevicePtrEx" /> class.
            </summary>
      <param name="devPtr">The dev PTR.</param>
      <param name="xSize">Size of the x.</param>
      <param name="ySize">Size of the y.</param>
      <param name="zSize">Size of the z.</param>
      <param name="context">The context.</param>
    </member>
    <member name="P:Cudafy.Host.CLDevicePtrEx`1.DevPtr">
      <summary>
            Gets the dev PTR.
            </summary>
    </member>
    <member name="P:Cudafy.Host.CLDevicePtrEx`1.Pointer">
      <summary>
            Gets the IntPtr in DevPtr.
            </summary>
    </member>
    <member name="P:Cudafy.Host.CLDevicePtrEx`1.Context">
      <summary>
            Gets the context.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.BLAS.GPGPUBLAS">
      <summary>
            Abstract base class for devices supporting BLAS.
            Warning: This code has received limited testing.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.Create(Cudafy.Host.GPGPU)">
      <summary>
            Creates a BLAS wrapper based on the specified gpu.
            </summary>
      <param name="gpu">The gpu.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.BLAS.GPGPUBLAS" /> class.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Maths.BLAS.GPGPUBLAS" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.Shutdown">
      <summary>
            Shutdowns this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMAX(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMAXs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMAX(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMAXs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMAX(Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMAXs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMAX(Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMAXs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMIN(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMINs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMIN(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMINs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMIN(Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMINs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.IAMIN(Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            IAMINs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ASUM(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            ASUMs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ASUM(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            ASUMs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ASUM(Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            ASUMs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ASUM(Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            ASUMs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(System.Single,System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(System.Double,System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(Cudafy.Types.ComplexF,Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(Cudafy.Types.ComplexD,Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.AXPY(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            AXPYs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.COPY(System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            COPYs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.COPY(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            COPYs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.COPY(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            COPYs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.COPY(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            COPYs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.DOT(System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            DOTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.DOT(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            DOTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.DOTU(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            DOTUs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.DOTC(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            DOTCs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.DOTU(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            DOTUs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.DOTC(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            DOTCs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.NRM2(System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            NRs the m2.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.NRM2(System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            NRs the m2.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.NRM2(Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            NRs the m2.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.NRM2(Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            NRs the m2.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(System.Single[],System.Single[],System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(System.Double[],System.Double[],System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Single,Cudafy.Types.ComplexF,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Double,Cudafy.Types.ComplexD,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(System.Single[],System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(System.Double[],System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Single[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Double[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROT(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTG(System.Single[],System.Single[],System.Single[],System.Single[])">
      <summary>
            ROTGs the specified a.
            </summary>
      <param name="a">A.</param>
      <param name="b">The b.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTG(System.Double[],System.Double[],System.Double[],System.Double[])">
      <summary>
            ROTGs the specified a.
            </summary>
      <param name="a">A.</param>
      <param name="b">The b.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTG(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Single[],Cudafy.Types.ComplexF[])">
      <summary>
            ROTGs the specified a.
            </summary>
      <param name="a">A.</param>
      <param name="b">The b.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTG(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Double[],Cudafy.Types.ComplexD[])">
      <summary>
            ROTGs the specified a.
            </summary>
      <param name="a">A.</param>
      <param name="b">The b.</param>
      <param name="c">The c.</param>
      <param name="s">The s.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTM(System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTMs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="param">The param.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTM(System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            ROTMs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="param">The param.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTMG(System.Single@,System.Single@,System.Single@,System.Single@,System.Single[])">
      <summary>
            ROTMGs the specified d1.
            </summary>
      <param name="d1">The d1.</param>
      <param name="d2">The d2.</param>
      <param name="x1">The x1.</param>
      <param name="y1">The y1.</param>
      <param name="param">The param.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTMG(System.Double@,System.Double@,System.Double@,System.Double@,System.Double[])">
      <summary>
            ROTMGs the specified d1.
            </summary>
      <param name="d1">The d1.</param>
      <param name="d2">The d2.</param>
      <param name="x1">The x1.</param>
      <param name="y1">The y1.</param>
      <param name="param">The param.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTMG(System.Single[],System.Single[],System.Single[],System.Single[],System.Single[])">
      <summary>
            ROTMGs the specified d1.
            </summary>
      <param name="d1">The d1.</param>
      <param name="d2">The d2.</param>
      <param name="x1">The x1.</param>
      <param name="y1">The y1.</param>
      <param name="param">The param.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.ROTMG(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
      <summary>
            ROTMGs the specified d1.
            </summary>
      <param name="d1">The d1.</param>
      <param name="d2">The d2.</param>
      <param name="x1">The x1.</param>
      <param name="y1">The y1.</param>
      <param name="param">The param.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Single,System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Double,System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(Cudafy.Types.ComplexF,Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Single,Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(Cudafy.Types.ComplexD,Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Double,Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Single[],System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Single[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SCAL(System.Double[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32)">
      <summary>
            SCALs the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="vectorx">The vectorx.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SWAP(System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            SWAPs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SWAP(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            SWAPs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SWAP(Cudafy.Types.ComplexF[],Cudafy.Types.ComplexF[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            SWAPs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SWAP(Cudafy.Types.ComplexD[],Cudafy.Types.ComplexD[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            SWAPs the specified vectorx.
            </summary>
      <param name="vectorx">The vectorx.</param>
      <param name="vectory">The vectory.</param>
      <param name="n">The n.</param>
      <param name="rowx">The rowx.</param>
      <param name="incx">The incx.</param>
      <param name="rowy">The rowy.</param>
      <param name="incy">The incy.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GBMV(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the banded matrix-vector multiplication.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">number of rows of matrix A.</param>
      <param name="n">number of columns of matrix A.</param>
      <param name="kl">number of subdiagonals of matrix A.</param>
      <param name="ku">number of superdiagonals of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimentions (kl + ku + 1) * n. This must be packed by column by column method.</param>
      <param name="x">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="beta">scalar used for multiplication, if beta = 0 then y does not have to be a valid input.</param>
      <param name="y">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="op">operation op(A) that is non- or(conj.) transpose.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. This typically be kl + ku + 1.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GBMV(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the banded matrix-vector multiplication.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">number of rows of matrix A.</param>
      <param name="n">number of columns of matrix A.</param>
      <param name="kl">number of subdiagonals of matrix A.</param>
      <param name="ku">number of superdiagonals of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimentions (kl + ku + 1) * n. This must be packed by column by column method.</param>
      <param name="x">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="beta">scalar used for multiplication, if beta = 0 then y does not have to be a valid input.</param>
      <param name="y">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="op">operation op(A) that is non- or(conj.) transpose.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be kl + ku + 1.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GEMV(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the matrix-vector multiplication.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">number of rows of matrix A.</param>
      <param name="n">number of columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">Array of dimension m * n.</param>
      <param name="x">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="beta">scalar used for multiplication, if beta = 0 then y does not have to be a valid input.</param>
      <param name="y">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="op">operation op(A) that is non- or(conj.) transpose.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically tuned.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GEMV(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the matrix-vector multiplication.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">number of rows of matrix A.</param>
      <param name="n">number of columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">Array of dimension m * n.</param>
      <param name="x">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="beta">scalar used for multiplication, if beta = 0 then y does not have to be a valid input.</param>
      <param name="y">vector with n elements if trans = N, m elements otherwise.</param>
      <param name="op">operation op(A) that is non- or(conj.) transpose.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically tuned.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GER(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the rank-1 update.
            A = alpha * x * transpose(y) + A
            </summary>
      <param name="m">number of rows of matrix A.</param>
      <param name="n">number of columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with m elements.</param>
      <param name="y">vector with n elements.</param>
      <param name="A">array of dimension m * n.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically tuned.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GER(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the rank-1 update.
            A = alpha * x * transpose(y) + A
            </summary>
      <param name="m">number of rows of matrix A.</param>
      <param name="n">number of columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with m elements.</param>
      <param name="y">vector with n elements.</param>
      <param name="A">array of dimension m * n.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically tuned.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SBMV(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric banded matrix-vector multiplication.
            y = alpha * A * x + beta * y
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="k">number of subdiagonals and superdiagonals of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimentions (k + 1) * n. This must be packed by column by column method.</param>
      <param name="x">vector with n elements.</param>
      <param name="beta">scalar used for multiplication, if beta = 0 then y does not have to be a valid input.</param>
      <param name="y">vector with n elements.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be k + 1.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SBMV(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric banded matrix-vector multiplication.
            y = alpha * A * x + beta * y
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="k">number of subdiagonals and superdiagonals of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimentions (k + 1) * n. This must be packed by column by column method.</param>
      <param name="x">vector with n elements.</param>
      <param name="beta">scalar used for multiplication, if beta = 0 then y does not have to be a valid input.</param>
      <param name="y">vector with n elements.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be k + 1.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SPMV(System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric packed matrix-vector multiplication.
            y = alpha * A * x + beta + y
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="Ap">array with A stored in packed format.</param>
      <param name="x">vector with n elements.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="y">vector with n elements.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SPMV(System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric packed matrix-vector multiplication.
            y = alpha * A * x + beta + y
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="Ap">array with A stored in packed format.</param>
      <param name="x">vector with n elements.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="y">vector with n elements.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SPR(System.Int32,System.Single,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32)">
      <summary>
            Performs the packed symmetric rank-1 update.
            A = alpha * x * transpose(x) + A
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="ap">array with A stored in packed format.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SPR(System.Int32,System.Double,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32)">
      <summary>
            Performs the packed symmetric rank-1 update.
            A = alpha * x * transpose(x) + A
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="ap">array with A stored in packed format.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SPR2(System.Int32,System.Single,System.Single[],System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the packed symmetric rank-2 update.
            A = alpha * (x * transpose(y) + y * transpose(x)) + A
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="y">vector with n elements.</param>
      <param name="ap">array with A stored in packed format.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SPR2(System.Int32,System.Double,System.Double[],System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the packed symmetric rank-2 update.
            A = alpha * (x * transpose(y) + y * transpose(x)) + A
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="y">vector with n elements.</param>
      <param name="ap">array with A stored in packed format.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYMV(System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric matrix-vector multiplication.
            y = alpha * A * x + beta * y
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension lda + n with lda &gt;= max(1, n).</param>
      <param name="x">vector with n elements.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="y">vector with n elements.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYMV(System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric matrix-vector multiplication.
            y = alpha * A * x + beta * y
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension lda + n with lda &gt;= max(1, n).</param>
      <param name="x">vector with n elements.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="y">vector with n elements.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYR(System.Int32,System.Single,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-1 update.
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="A">array of dimension lda + n with lda &gt;= max(1, n).</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYR(System.Int32,System.Double,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-1 update.
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="A">array of dimension lda + n with lda &gt;= max(1, n).</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYR2(System.Int32,System.Single,System.Single[],System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-2 update.
            A = alpha * (x * transpose(y) + y * transpose(x)) + A
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="y">vector with n elements.</param>
      <param name="A">array of dimension lda + n with lda &gt;= max(1, n).</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYR2(System.Int32,System.Double,System.Double[],System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-2 update.
            A = alpha * (x * transpose(y) + y * transpose(x)) + A
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="x">vector with n elements.</param>
      <param name="y">vector with n elements.</param>
      <param name="A">array of dimension lda + n with lda &gt;= max(1, n).</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other symmetric part is not referenced and is inferred frorm the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="incx">stride between consecutive elements of x.</param>
      <param name="incy">stride between consecutive elements of y.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TBMV(System.Int32,System.Int32,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Performs the triangular banded matrix-vector multiplication.
            x = op(A) * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="k">number of subdiagonals and superdiagonals of matrix A.</param>
      <param name="A">array of dimension lda * n with lda &gt;= k+1</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be k + 1.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TBMV(System.Int32,System.Int32,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Performs the triangular banded matrix-vector multiplication.
            x = op(A) * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="k">number of subdiagonals and superdiagonals of matrix A.</param>
      <param name="A">array of dimension lda * n with lda &gt;= k+1</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be k + 1.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TBSV(System.Int32,System.Int32,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Solves the triangular banded linear system with a single right-hand-side.
            x = op(A)^(-1) * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="k">number of subdiagonals and superdiagonals of matrix A.</param>
      <param name="A">array of dimension lda * n with lda &gt;= k+1</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be k + 1.</param>
      <param name="icx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TBSV(System.Int32,System.Int32,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Solves the triangular banded linear system with a single right-hand-side.
            x = op(A)^(-1) * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="k">number of subdiagonals and superdiagonals of matrix A.</param>
      <param name="A">array of dimension lda * n with lda &gt;= k+1</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be k + 1.</param>
      <param name="icx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TPMV(System.Int32,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32)">
      <summary>
            Performs the triangular packed matrix-vector multiplication.
            x = op(A) * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="AP">array with A stored in packed format.</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TPMV(System.Int32,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32)">
      <summary>
            Performs the triangular packed matrix-vector multiplication.
            x = op(A) * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="AP">array with A stored in packed format.</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TPSV(System.Int32,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32)">
      <summary>
            Solves the packed triangular linear system with a single right-hand-side.
            x = op(A)^-1 * x 
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="AP">array with A stored in packed format.</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TPSV(System.Int32,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32)">
      <summary>
            Solves the packed triangular linear system with a single right-hand-side.
            x = op(A)^-1 * x 
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="AP">array with A stored in packed format.</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRMV(System.Int32,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Performs the triangular matrix-vector multiplication.
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="a">array of dimensions lda * n with lda &gt;= max(1, n).</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be n.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRMV(System.Int32,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Performs the triangular matrix-vector multiplication.
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="a">array of dimensions lda * n with lda &gt;= max(1, n).</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be n.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRSV(System.Int32,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Solves the triangular linear system with a single right-hand-side.
            x = op(A)^-1 * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="A">array of dimensions lda * n with lda &gt;= max(1, n).</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be n.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRSV(System.Int32,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Solves the triangular linear system with a single right-hand-side.
            x = op(A)^-1 * x
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="A">array of dimensions lda * n with lda &gt;= max(1, n).</param>
      <param name="x">vector with n elements.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A. if lda = 0, lda is automatically be n.</param>
      <param name="incx">stride between consecutive elements of x.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GEMM(System.Int32,System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasOperation,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the matrix-matrix multiplication.
            C = alpha * op(A) * op(B) + beta * C
            </summary>
      <param name="m">number of rows of matrix op(A) and C.</param>
      <param name="k">number of columns of matix op(A) and rows of op(B).</param>
      <param name="n">number of columns of matix op(B) and C.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">arrasy of dimensions m * k.</param>
      <param name="B">array of dimension k * n.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension m * n.</param>
      <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
      <param name="lda">leading dimension of two-dimensional array used to store the matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store the matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store the matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.GEMM(System.Int32,System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasOperation,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the matrix-matrix multiplication.
            C = alpha * op(A) * op(B) + beta * C
            </summary>
      <param name="m">number of rows of matrix op(A) and C.</param>
      <param name="k">number of columns of matix op(A) and rows of op(B).</param>
      <param name="n">number of columns of matix op(B) and C.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">arrasy of dimensions m * k.</param>
      <param name="B">array of dimension k * n.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension m * n.</param>
      <param name="transa">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="transb">operation op(B) that is non- or (conj.) transpose.</param>
      <param name="lda">leading dimension of two-dimensional array used to store the matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store the matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store the matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYMM(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasSideMode,Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs symmetric matrix-matrix multiplication.
            C = alpha * A * B + beta * C (side left),
            C = alpha * B * A + beta * C (side right)
            </summary>
      <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
      <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension m * m with side left, and n * n otherwise.</param>
      <param name="B">array of dimension m * n.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension m * n.</param>
      <param name="side">indicates if matrix A is on the left or right of B.</param>
      <param name="uplo">indicates if matrix A lower of upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYMM(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasSideMode,Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs symmetric matrix-matrix multiplication.
            C = alpha * A * B + beta * C (side left),
            C = alpha * B * A + beta * C (side right)
            </summary>
      <param name="m">number of rows of matrix C and B, with matrix A sized accordingly.</param>
      <param name="n">number of columns of matrix C and B, with matrix A sized accordingly.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension m * m with side left, and n * n otherwise.</param>
      <param name="B">array of dimension m * n.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension m * n.</param>
      <param name="side">indicates if matrix A is on the left or right of B.</param>
      <param name="uplo">indicates if matrix A lower of upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYRK(System.Int32,System.Int32,System.Single,System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-k update.
            C = alpha * op(A) * transpose(op(A)) + beta * C
            </summary>
      <param name="n">number of rows of matrix op(A) and C.</param>
      <param name="k">number of columns of matrix op(A).</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension n * k.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension n * n.</param>
      <param name="trans">operation op(A) that is non- or transpose.</param>
      <param name="uplo">indicates if matrix A lower of upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYRK(System.Int32,System.Int32,System.Double,System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-k update.
            C = alpha * op(A) * transpose(op(A)) + beta * C
            </summary>
      <param name="n">number of rows of matrix op(A) and C.</param>
      <param name="k">number of columns of matrix op(A).</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension n * k.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension n * n.</param>
      <param name="trans">operation op(A) that is non- or transpose.</param>
      <param name="uplo">indicates if matrix C lower of upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYR2K(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single,System.Single[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-2k update.
            C = alpha * (op(A) * transpose(op(B)) + op(B) * transpose(op(A))) + beta * C
            </summary>
      <param name="n">number of rows of matrix op(A), op(B) and C.</param>
      <param name="k">number of columns of matrix op(A) and op(B).</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension n * k.</param>
      <param name="B">array of dimension n * k.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension n * n.</param>
      <param name="trans">operation op(A), op(B) that is non- or transpose.</param>
      <param name="uplo">indicates if matrix C lower of upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.SYR2K(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double,System.Double[],Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the symmetric rank-2k update.
            C = alpha * (op(A) * transpose(op(B)) + op(B) * transpose(op(A))) + beta * C
            </summary>
      <param name="n">number of rows of matrix op(A), op(B) and C.</param>
      <param name="k">number of columns of matrix op(A) and op(B).</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension n * k.</param>
      <param name="B">array of dimension n * k.</param>
      <param name="beta">scalar used for multiplication.</param>
      <param name="C">array of dimension n * n.</param>
      <param name="trans">operation op(A), op(B) that is non- or transpose.</param>
      <param name="uplo">indicates if matrix C lower of upper part is stored, the other symmetric part is not referenced and is inferred from the stored elements.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRMM(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasSideMode,Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the triangular matrix-matrix multiplication.
            C = alpha * op(A) * B (side left),
            C = alpha * B * op(A) (side right)
            </summary>
      <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
      <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension m * m.</param>
      <param name="B">array of dimension m * n.</param>
      <param name="C">array of dimension m * n.</param>
      <param name="side">indicates if matrix A is on the left or right of B.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not refernced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRMM(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasSideMode,Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Performs the triangular matrix-matrix multiplication.
            C = alpha * op(A) * B (side left),
            C = alpha * B * op(A) (side right)
            </summary>
      <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
      <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension m * m.</param>
      <param name="B">array of dimension m * n.</param>
      <param name="C">array of dimension m * n.</param>
      <param name="side">indicates if matrix A is on the left or right of B.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not refernced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
      <param name="ldc">leading dimension of two-dimensional array used to store matrix C.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRSM(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],Cudafy.Maths.BLAS.Types.cublasSideMode,Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Solves the triangular linear system with multiple right-hand-sides.
            B = alpha * (op(A))^-1 * B (left side),
            B = alpha * B * (op(A))^-1 (right side)
            </summary>
      <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
      <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension m * m (n * n right side).</param>
      <param name="B">array of dimension m * n.</param>
      <param name="side">indicates if matrix A is on the left or right of B.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not refernced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
    </member>
    <member name="M:Cudafy.Maths.BLAS.GPGPUBLAS.TRSM(System.Int32,System.Int32,System.Double,System.Double[],System.Double[],Cudafy.Maths.BLAS.Types.cublasSideMode,Cudafy.Maths.BLAS.Types.cublasOperation,Cudafy.Maths.BLAS.Types.cublasFillMode,Cudafy.Maths.BLAS.Types.cublasDiagType,System.Int32,System.Int32)">
      <summary>
            Solves the triangular linear system with multiple right-hand-sides.
            B = alpha * (op(A))^-1 * B (left side),
            B = alpha * B * (op(A))^-1 (right side)
            </summary>
      <param name="m">number of rows of matrix B, with matrix A sized accordingly.</param>
      <param name="n">number of columns of matrix B, with matrix A sized accordingly.</param>
      <param name="alpha">scalar used for multiplication.</param>
      <param name="A">array of dimension m * m (n * n right side).</param>
      <param name="B">array of dimension m * n.</param>
      <param name="side">indicates if matrix A is on the left or right of B.</param>
      <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
      <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not refernced and is inferred from the stored elements.</param>
      <param name="diag">indicates if the elements on the main diagonal of matrix A are unity and should not be accessed.</param>
      <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
      <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
    </member>
    <member name="P:Cudafy.Maths.BLAS.GPGPUBLAS.IsDisposed">
      <summary>
            Gets a value indicating whether this instance is disposed.
            </summary>
      <value>
        <c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.Maths.BLAS.CudaBLAS">
      <summary>
            Wrapper around CUBLAS.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.BLAS.HostBLAS">
      <summary>
            Not implemented.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.LA.ISolver">
      <summary>
            Common interface for linear system solver. (for future)
            </summary>
    </member>
    <member name="T:Cudafy.Maths.LA.Solver">
      <summary>
            Linear solver class. (Not implemented. Do not use yet.)
            </summary>
    </member>
    <member name="M:Cudafy.Maths.LA.Solver.CG(System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single[],System.Single[],System.Single[],System.Single,System.Int32)">
      <summary>
            Solves symmetric linear system with conjugate gradient solver.
            A * x = b
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowA">array of n+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="dx">vector of n elements.</param>
      <param name="db">vector of n elements.</param>
      <param name="dp">vector of n elements. (temporary vector)</param>
      <param name="dAx">vector of n elements. (temporary vector)</param>
      <param name="tolerence">iterate tolerence of conjugate gradient solver.</param>
      <param name="maxIterate">max iterate count of conjugate gradient solver.</param>
      <returns>if A has singulrarity or failure in max iterate count, returns false. return true otherwise.</returns>
    </member>
    <member name="M:Cudafy.Maths.LA.Solver.BiCGSTAB(System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double,System.Int32)">
      <summary>
            Solve linear system with Biconjugate gradient stabilized method (BiCGSTAB).
            </summary>
      <param name="n">number of rows and columns of matrix A.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowA">array of n+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of n elements. (updated after solving.)</param>
      <param name="b">vector of n elements.</param>
      <param name="ax">temporary memory for BiCGSTAB.</param>
      <param name="r0">temporary memory for BiCGSTAB.</param>
      <param name="r">temporary memory for BiCGSTAB.</param>
      <param name="v">temporary memory for BiCGSTAB.</param>
      <param name="p">temporary memory for BiCGSTAB.</param>
      <param name="s">temporary memory for BiCGSTAB.</param>
      <param name="t">temporary memory for BiCGSTAB.</param>
      <param name="threshold">iterate tolerence of BiCGSTAB solver.</param>
      <param name="maxIterate">max iterate count of BiCGSTAB solver.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Cudafy.Maths.RAND.GPGPURAND">
      <summary>
            RAND wrapper for Cuda GPUs.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Maths.RAND.GPGPURAND" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Dispose">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Create(Cudafy.Host.GPGPU,System.Boolean)">
      <summary>
            Creates an instance based on the specified gpu with pseudo random generator.
            </summary>
      <param name="gpu">The gpu.</param>
      <param name="host">if set to <c>true</c> the uses generator on the host (if applicable).</param>
      <returns>New instance.</returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Create(Cudafy.Host.GPGPU,Cudafy.Maths.RAND.curandRngType,System.Boolean)">
      <summary>
            Creates an instance based on the specified gpu.
            </summary>
      <param name="gpu">The gpu.</param>
      <param name="rng_type">The type of generator.</param>
      <param name="host">if set to <c>true</c> the uses generator on the host (if applicable).</param>
      <returns>New instance.</returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Shutdown">
      <summary>
            Shutdowns this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.SetPseudoRandomGeneratorSeed(System.UInt64)">
      <summary>
            Sets the pseudo random generator seed.
            </summary>
      <param name="seed">The seed.</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateUniform(System.Single[],System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateUniform(System.Double[],System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Generate(System.UInt32[],System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateLogNormal(System.Single[],System.Single,System.Single,System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="mean">The mean.</param>
      <param name="stddev">The stddev.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateLogNormal(System.Double[],System.Double,System.Double,System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="mean">The mean.</param>
      <param name="stddev">The stddev.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.Generate(System.UInt64[],System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateNormal(System.Single[],System.Single,System.Single,System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="mean">The mean.</param>
      <param name="stddev">The stddev.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateNormal(System.Double[],System.Single,System.Single,System.Int32)">
      <summary>
            Generates random data.
            </summary>
      <param name="array">The array.</param>
      <param name="mean">The mean.</param>
      <param name="stddev">The stddev.</param>
      <param name="n">Count</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GenerateSeeds">
      <summary>
            Generates seeds.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GetDirectionVectors32(Cudafy.Maths.RAND.curandDirectionVectorSet)">
      <summary>
            Gets the direction vectors for 32-bit.
            </summary>
      <param name="set">The set.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GetDirectionVectors64(Cudafy.Maths.RAND.curandDirectionVectorSet)">
      <summary>
            Gets the direction vectors for 64-bit.
            </summary>
      <param name="set">The set.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GetScrambleConstants32(System.Int32)">
      <summary>
            Gets the scramble constants for 32-bit.
            </summary>
      <param name="n">Count</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GetScrambleConstants64(System.Int32)">
      <summary>
            Gets the scramble constants for 64-bit.
            </summary>
      <param name="n">Count</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.GetVersion">
      <summary>
            Gets the version of library.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.SetGeneratorOffset(System.UInt64)">
      <summary>
            Sets the generator offset.
            </summary>
      <param name="offset">The offset.</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.SetGeneratorOrdering(Cudafy.Maths.RAND.curandOrdering)">
      <summary>
            Sets the generator ordering.
            </summary>
      <param name="order">The order.</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.SetQuasiRandomGeneratorDimensions(System.UInt32)">
      <summary>
            Sets the quasi random generator dimensions.
            </summary>
      <param name="num_dimensions">The num_dimensions.</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.GPGPURAND.SetStream(System.Int32)">
      <summary>
            Sets the stream.
            </summary>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.CudaRAND.CopyMemory(System.IntPtr,System.IntPtr,System.UInt32)">
      <summary>
            Copies memory.
            </summary>
      <param name="Destination">The destination.</param>
      <param name="Source">The source.</param>
      <param name="Length">The length.</param>
    </member>
    <member name="T:Cudafy.Maths.CudafyMathException">
      <summary>
            Exceptions for host.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.CudafyMathException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.CudafyMathException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.Maths.CudafyMathException.#ctor(System.Exception,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.CudafyMathException" /> class.
            </summary>
      <param name="inner">The inner.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Cudafy.Maths.CudafyMathException.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.CudafyMathException" /> class.
            </summary>
      <param name="errMsg">The err MSG.</param>
      <param name="args">The args.</param>
    </member>
    <member name="M:Cudafy.Maths.CudafyMathException.#ctor(System.Exception,System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.CudafyMathException" /> class.
            </summary>
      <param name="inner">The inner exception.</param>
      <param name="errMsg">The err message.</param>
      <param name="args">The parameters.</param>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftwf_plan">
      <summary>
            Creates, stores, and destroys fftw plans
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftwf_plan._handle">
      <summary>
            Native handle.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf_plan.Execute">
      <summary>
            Executes this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf_plan.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Maths.FFT.fftwf_plan" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf_plan.dft_1d(Cudafy.Maths.FFT.eFFTType,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates plan..
            </summary>
      <param name="fftType">Type of fft.</param>
      <param name="n">The n.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="direction">The direction.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf_plan.dft_2d(Cudafy.Maths.FFT.eFFTType,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            DFT_2Ds the specified FFT type.
            </summary>
      <param name="fftType">Type of the FFT.</param>
      <param name="nx">The nx.</param>
      <param name="ny">The ny.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="direction">The direction.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf_plan.dft_3d(Cudafy.Maths.FFT.eFFTType,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            DFT_3Ds the specified FFT type.
            </summary>
      <param name="fftType">Type of the FFT.</param>
      <param name="nx">The nx.</param>
      <param name="ny">The ny.</param>
      <param name="nz">The nz.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="direction">The direction.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Maths.FFT.fftwf_plan.Handle">
      <summary>
            Gets the handle.
            </summary>
      <value>The handle.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.fftwf_plan.Input">
      <summary>
            Gets or sets the input.
            </summary>
      <value>The input.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.fftwf_plan.Output">
      <summary>
            Gets or sets the output.
            </summary>
      <value>The output.</value>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftw_plan">
      <summary>
            Creates, stores, and destroys fftw plans
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_plan._handle">
      <summary>
            Native handle.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw_plan.Execute">
      <summary>
            Executes this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw_plan.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Maths.FFT.fftwf_plan" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw_plan.dft_1d(Cudafy.Maths.FFT.eFFTType,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates plan..
            </summary>
      <param name="fftType">FFT type.</param>
      <param name="n">The n.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="direction">The direction.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw_plan.dft_2d(Cudafy.Maths.FFT.eFFTType,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            DFT_2Ds the specified FFT type.
            </summary>
      <param name="fftType">Type of the FFT.</param>
      <param name="nx">The nx.</param>
      <param name="ny">The ny.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="direction">The direction.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw_plan.dft_3d(Cudafy.Maths.FFT.eFFTType,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            DFT_3Ds the specified FFT type.
            </summary>
      <param name="fftType">Type of the FFT.</param>
      <param name="nx">The nx.</param>
      <param name="ny">The ny.</param>
      <param name="nz">The nz.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="direction">The direction.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Maths.FFT.fftw_plan.Handle">
      <summary>
            Gets the handle.
            </summary>
      <value>The handle.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.fftw_plan.Input">
      <summary>
            Gets or sets the input.
            </summary>
      <value>The input.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.fftw_plan.Output">
      <summary>
            Gets or sets the output.
            </summary>
      <value>The output.</value>
    </member>
    <member name="T:Cudafy.Maths.FFT.GPGPUFFT">
      <summary>
            FFT wrapper.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.GPGPUFFT._gpu">
      <summary>
            GPU instance on which the FFT instance was made.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.FFT.GPGPUFFT" /> class.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.VerifyTypes(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32@,System.Int32@)">
      <summary>
            Verifies the types.
            </summary>
      <param name="fftType">Type of the FFT.</param>
      <param name="dataType">Type of the data.</param>
      <param name="inSize">Size of input elements.</param>
      <param name="outSize">Size of output elements.</param>
      <returns>The CUFFTType.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.SetStream(Cudafy.Maths.FFT.FFTPlan,System.Int32)">
      <summary>
            Sets the stream.
            </summary>
      <param name="plan">The plan to set the stream for.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Create(Cudafy.Host.GPGPU)">
      <summary>
            Creates a GPGPUFFT based on the supplied GPGPU instance (e.g. CudaFFT or EmulatedGPU).
            </summary>
      <param name="gpu">The gpu instance.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Remove(Cudafy.Maths.FFT.FFTPlan)">
      <summary>
            Frees the specified plan.
            </summary>
      <param name="plan">The plan.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.RemoveAll">
      <summary>
            Destroys all plans.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Plan1D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32)">
      <summary>
            Creates a 1D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <returns>Plan.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Plan1D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Plan1s the D.
            </summary>
      <param name="fftType">Type of the FFT.</param>
      <param name="dataType">Type of the data.</param>
      <param name="nx">The nx.</param>
      <param name="batchSize">Size of the batch.</param>
      <param name="istride">The istride.</param>
      <param name="idist">The idist.</param>
      <param name="ostride">The ostride.</param>
      <param name="odist">The odist.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Plan2D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 2D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The x length in samples.</param>
      <param name="ny">The y length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <returns>Plan.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Plan3D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 3D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The x length in samples.</param>
      <param name="ny">The y length in samples.</param>
      <param name="nz">The z length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <returns>Plan.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.Execute``2(Cudafy.Maths.FFT.FFTPlan,``0[],``1[],System.Boolean)">
      <summary>
            Executes the specified plan.
            </summary>
      <typeparam name="T">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <typeparam name="U">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <param name="plan">The plan.</param>
      <param name="input">The input data.</param>
      <param name="output">The output data.</param>
      <param name="inverse">if set to <c>true</c> inverse.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.GetVersion">
      <summary>
            Gets the version of library wrapped by this library.
            </summary>
      <returns>Version of library or -1 if not supported or available.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.GPGPUFFT.SetCompatibilityMode(Cudafy.Maths.FFT.FFTPlan,Cudafy.Maths.FFT.eCompatibilityMode)">
      <summary>
            Configures the layout of CUFFT output in FFTWcompatible modes.
            When FFTW compatibility is desired, it can be configured for padding
            only, for asymmetric complex inputs only, or to be fully compatible.
            </summary>
      <param name="plan">The plan.</param>
      <param name="mode">The mode.</param>
    </member>
    <member name="T:Cudafy.Maths.FFT.CudaFFT">
      <summary>
            FFT wrapper for Cuda GPUs.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.SetStream(Cudafy.Maths.FFT.FFTPlan,System.Int32)">
      <summary>
            Sets the stream.
            </summary>
      <param name="plan">The plan to set the stream for.</param>
      <param name="streamId">The stream id.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.Plan1D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32)">
      <summary>
            Creates a 1D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">Data type.</param>
      <param name="nx">The length in samples.</param>
      <param name="batchSize">The number of FFTs in batch.</param>
      <returns>Plan.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.Plan2D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 2D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">Data type.</param>
      <param name="nx">The number of samples in x dimension.</param>
      <param name="ny">The number of samples in y dimension.</param>
      <param name="batchSize">Size of batch.</param>
      <returns>Plan.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.Plan3D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 3D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">Data type.</param>
      <param name="nx">The number of samples in x dimension.</param>
      <param name="ny">The number of samples in y dimension.</param>
      <param name="nz">The number of samples in z dimension.</param>
      <param name="batchSize">Size of batch.</param>
      <returns>Plan.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.Execute``2(Cudafy.Maths.FFT.FFTPlan,``0[],``1[],System.Boolean)">
      <summary>
            Executes the specified plan.
            </summary>
      <typeparam name="T">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <typeparam name="U">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <param name="plan">The plan.</param>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="inverse">if set to <c>true</c> inverse.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.Remove(Cudafy.Maths.FFT.FFTPlan)">
      <summary>
            Frees the specified plan.
            </summary>
      <param name="plan">The plan.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.GetVersion">
      <summary>
            Gets the version of CUFFT (CUDA 5.0 only)
            </summary>
      <returns>Version of library or -1 if not supported or available.</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.CudaFFT.SetCompatibilityMode(Cudafy.Maths.FFT.FFTPlan,Cudafy.Maths.FFT.eCompatibilityMode)">
      <summary>
            Configures the layout of CUFFT output in FFTWcompatible modes.
            When FFTW compatibility is desired, it can be configured for padding
            only, for asymmetric complex inputs only, or to be fully compatible.
            </summary>
      <param name="plan">The plan.</param>
      <param name="mode">The mode.</param>
    </member>
    <member name="T:Cudafy.Maths.FFT.HostFFT">
      <summary>
            Implements emulation of GPU FFT library.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.HostFFT.Plan1D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32)">
      <summary>
            Creates a 1D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <returns>
            Plan.
            </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.HostFFT.Plan2D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 2D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The x length in samples.</param>
      <param name="ny">The y length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <returns>
            Plan.
            </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.HostFFT.Plan3D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 3D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The x length in samples.</param>
      <param name="ny">The y length in samples.</param>
      <param name="nz">The z length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <returns>
            Plan.
            </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.HostFFT.Execute``2(Cudafy.Maths.FFT.FFTPlan,``0[],``1[],System.Boolean)">
      <summary>
            Executes the specified plan.
            </summary>
      <typeparam name="T">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <typeparam name="U">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <param name="plan">The plan.</param>
      <param name="input">The input data.</param>
      <param name="output">The output data.</param>
      <param name="inverse">if set to <c>true</c> inverse.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.HostFFT.Remove(Cudafy.Maths.FFT.FFTPlan)">
      <summary>
            Frees the specified plan.
            </summary>
      <param name="plan">The plan.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.HostFFT.Plan1D(Cudafy.Maths.FFT.eFFTType,Cudafy.Maths.FFT.eDataType,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a 1D plan.
            </summary>
      <param name="fftType">Type of FFT.</param>
      <param name="dataType">The data type.</param>
      <param name="nx">The length in samples.</param>
      <param name="batch">The number of FFTs in batch.</param>
      <param name="istride">The istride.</param>
      <param name="idist">The idist.</param>
      <param name="ostride">The ostride.</param>
      <param name="odist">The odist.</param>
      <returns>Plan.</returns>
    </member>
    <member name="T:Cudafy.Maths.FFT.FFTPlan">
      <summary>
            Abstract base class for FFT plans.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.FFTPlan.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Maths.FFT.FFTPlan" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.FFTPlan.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.FFTPlan.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan.IsDisposed">
      <summary>
            Gets a value indicating whether this instance is disposed.
            </summary>
      <value>
        <c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan.BatchSize">
      <summary>
            Gets or sets the size of the batch.
            </summary>
      <value>The size of the batch.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan.Length">
      <summary>
            Gets the length when overridden.
            </summary>
      <value>The length.</value>
    </member>
    <member name="T:Cudafy.Maths.FFT.FFTPlan1D">
      <summary>
            Represents a 1D FFT plan.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.FFTPlan1D.Execute``2(``0[],``1[],System.Boolean)">
      <summary>
            Executes the FFT.
            </summary>
      <typeparam name="T">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <typeparam name="U">Data format: Double, Single, ComplexD or ComplexF.</typeparam>
      <param name="input">The input.</param>
      <param name="output">The output.</param>
      <param name="inverse">if set to <c>true</c> inverse.</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.FFTPlan1D.SetCompatibilityMode(Cudafy.Maths.FFT.eCompatibilityMode)">
      <summary>
            Configures the layout of CUFFT output in FFTWcompatible modes.
            When FFTW compatibility is desired, it can be configured for padding
            only, for asymmetric complex inputs only, or to be fully compatible.
            </summary>
      <param name="mode">The mode.</param>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan1D.XSize">
      <summary>
            Gets or sets the size of the X dimension.
            </summary>
      <value>The size of the X dimension.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan1D.Length">
      <summary>
            Gets the length (XSize).
            </summary>
      <value>The length.</value>
    </member>
    <member name="T:Cudafy.Maths.FFT.FFTPlan2D">
      <summary>
            Represents a 2D FFT plan.
            </summary>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan2D.YSize">
      <summary>
            Gets or sets the size of the Y dimension.
            </summary>
      <value>The size of the Y dimension.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan2D.Length">
      <summary>
            Gets the length (XSize * YSize).
            </summary>
      <value>The length.</value>
    </member>
    <member name="T:Cudafy.Maths.FFT.FFTPlan3D">
      <summary>
            Represents a 3D FFT plan.
            </summary>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan3D.ZSize">
      <summary>
            Gets or sets the size of the Z dimension.
            </summary>
      <value>The size of the Z dimension.</value>
    </member>
    <member name="P:Cudafy.Maths.FFT.FFTPlan3D.Length">
      <summary>
            Gets the length (XSize * YSize * ZSize).
            </summary>
      <value>The length.</value>
    </member>
    <member name="T:Cudafy.Maths.FFT.eFFTType">
      <summary>
            FFT Type enumeration.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eFFTType.Real2Complex">
      <summary>
            Real to complex.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eFFTType.Complex2Real">
      <summary>
            Complex to real.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eFFTType.Complex2Complex">
      <summary>
            Complex to complex.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.FFT.eDataType">
      <summary>
            Data type enumeration.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eDataType.Double">
      <summary>
            Double floating point.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eDataType.Single">
      <summary>
            Single floating point.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.FFT.eCompatibilityMode">
      <summary>
            FFTW compatibility mode.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eCompatibilityMode.Native">
      <summary>
      </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eCompatibilityMode.FFTW_Padding">
      <summary>
                 Inserts extra padding between packed in-place transforms for
                 batched transforms with power-of-2 size. (default)
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eCompatibilityMode.FFTW_Asymmetric">
      <summary>
                 Guarantees FFTW-compatible output for non-symmetric complex inputs
                 for transforms with power-of-2 size. This is only useful for
                 artificial (i.e. random) datasets as actual data will always be
                 symmetric if it has come from the real plane. If you don't
                 understand what this means, you probably don't have to use it.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.eCompatibilityMode.FFTW_All">
      <summary>
                For convenience, enables all FFTW compatibility modes at once.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftw_flags">
      <summary>
            FFTW planner flags
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.Measure">
      <summary>
            Tells FFTW to find an optimized plan by actually computing several FFTs and measuring their execution time. 
            Depending on your machine, this can take some time (often a few seconds). Default (0x0). 
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.DestroyInput">
      <summary>
            Specifies that an out-of-place transform is allowed to overwrite its 
            input array with arbitrary data; this can sometimes allow more efficient algorithms to be employed.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.Unaligned">
      <summary>
            Rarely used. Specifies that the algorithm may not impose any unusual alignment requirements on the input/output 
            arrays (i.e. no SIMD). This flag is normally not necessary, since the planner automatically detects 
            misaligned arrays. The only use for this flag is if you want to use the guru interface to execute a given 
            plan on a different array that may not be aligned like the original. 
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.ConserveMemory">
      <summary>
            Not used.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.Exhaustive">
      <summary>
            Like Patient, but considers an even wider range of algorithms, including many that we think are 
            unlikely to be fast, to produce the most optimal plan but with a substantially increased planning time. 
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.PreserveInput">
      <summary>
            Specifies that an out-of-place transform must not change its input array. 
            </summary>
      <remarks>
            This is ordinarily the default, 
            except for c2r and hc2r (i.e. complex-to-real) transforms for which DestroyInput is the default. 
            In the latter cases, passing PreserveInput will attempt to use algorithms that do not destroy the 
            input, at the expense of worse performance; for multi-dimensional c2r transforms, however, no 
            input-preserving algorithms are implemented and the planner will return null if one is requested.
            </remarks>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.Patient">
      <summary>
            Like Measure, but considers a wider range of algorithms and often produces a more optimal plan 
            (especially for large transforms), but at the expense of several times longer planning time 
            (especially for large transforms).
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_flags.Estimate">
      <summary>
            Specifies that, instead of actual measurements of different algorithms, a simple heuristic is 
            used to pick a (probably sub-optimal) plan quickly. With this flag, the input/output arrays 
            are not overwritten during planning. 
            </summary>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftw_direction">
      <summary>
            Defines direction of operation
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_direction.Forward">
      <summary>
            Computes a regular DFT
            </summary>
    </member>
    <member name="F:Cudafy.Maths.FFT.fftw_direction.Backward">
      <summary>
            Computes the inverse DFT
            </summary>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftw_kind">
      <summary>
            Kinds of real-to-real transforms
            </summary>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftw">
      <summary>
            Contains the Basic Interface FFTW functions for double-precision (double) operations
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.malloc(System.Int32)">
      <summary>
            Allocates FFTW-optimized unmanaged memory
            </summary>
      <param name="length">Amount to allocate, in bytes</param>
      <returns>Pointer to allocated memory</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.free(System.IntPtr)">
      <summary>
            Deallocates memory allocated by FFTW malloc
            </summary>
      <param name="mem">Pointer to memory to release</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.destroy_plan(System.IntPtr)">
      <summary>
            Deallocates an FFTW plan and all associated resources
            </summary>
      <param name="plan">Pointer to the plan to release</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.cleanup">
      <summary>
            Clears all memory used by FFTW, resets it to initial state. Does not replace destroy_plan and free
            </summary>
      <remarks>After calling fftw_cleanup, all existing plans become undefined, and you should not 
            attempt to execute them nor to destroy them. You can however create and execute/destroy new plans, 
            in which case FFTW starts accumulating wisdom information again. 
            fftw_cleanup does not deallocate your plans; you should still call fftw_destroy_plan for this purpose.</remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.set_timelimit(System.Double)">
      <summary>
            Sets the maximum time that can be used by the planner.
            </summary>
      <param name="seconds">Maximum time, in seconds.</param>
      <remarks>This function instructs FFTW to spend at most seconds seconds (approximately) in the planner. 
            If seconds == -1.0 (the default value), then planning time is unbounded. 
            Otherwise, FFTW plans with a progressively wider range of algorithms until the the given time limit is 
            reached or the given range of algorithms is explored, returning the best available plan. For example, 
            specifying fftw_flags.Patient first plans in Estimate mode, then in Measure mode, then finally (time 
            permitting) in Patient. If fftw_flags.Exhaustive is specified instead, the planner will further progress to 
            Exhaustive mode. 
            </remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.execute(System.IntPtr)">
      <summary>
            Executes an FFTW plan, provided that the input and output arrays still exist
            </summary>
      <param name="plan">Pointer to the plan to execute</param>
      <remarks>execute (and equivalents) is the only function in FFTW guaranteed to be thread-safe.</remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.many_dft(System.Int32,System.Int32[],System.Int32,System.IntPtr,System.Int32[],System.Int32,System.Int32,System.IntPtr,System.Int32[],System.Int32,System.Int32,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Many_dfts the specified rank.
            </summary>
      <param name="rank">The rank.</param>
      <param name="n">The n.</param>
      <param name="howmany">The howmany.</param>
      <param name="input">The input.</param>
      <param name="inembed">The inembed.</param>
      <param name="istride">The istride.</param>
      <param name="idist">The idist.</param>
      <param name="output">The output.</param>
      <param name="onembed">The onembed.</param>
      <param name="ostride">The ostride.</param>
      <param name="odist">The odist.</param>
      <param name="sign">The sign.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.many_dft_r2c(System.Int32,System.Int32[],System.Int32,System.IntPtr,System.Int32[],System.Int32,System.Int32,System.IntPtr,System.Int32[],System.Int32,System.Int32,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Many_dft_r2cs the specified rank.
            </summary>
      <param name="rank">The rank.</param>
      <param name="n">The n.</param>
      <param name="howmany">The howmany.</param>
      <param name="input">The input.</param>
      <param name="inembed">The inembed.</param>
      <param name="istride">The istride.</param>
      <param name="idist">The idist.</param>
      <param name="output">The output.</param>
      <param name="onembed">The onembed.</param>
      <param name="ostride">The ostride.</param>
      <param name="odist">The odist.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.many_dft_c2r(System.Int32,System.Int32[],System.Int32,System.IntPtr,System.Int32[],System.Int32,System.Int32,System.IntPtr,System.Int32[],System.Int32,System.Int32,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Many_dft_c2rs the specified rank.
            </summary>
      <param name="rank">The rank.</param>
      <param name="n">The n.</param>
      <param name="howmany">The howmany.</param>
      <param name="input">The input.</param>
      <param name="inembed">The inembed.</param>
      <param name="istride">The istride.</param>
      <param name="idist">The idist.</param>
      <param name="output">The output.</param>
      <param name="onembed">The onembed.</param>
      <param name="ostride">The ostride.</param>
      <param name="odist">The odist.</param>
      <param name="flags">The flags.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional complex-to-complex DFT
            </summary>
      <param name="n">The logical size of the transform</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional complex-to-complex DFT
            </summary>
      <param name="nx">The logical size of the transform along the first dimension</param>
      <param name="ny">The logical size of the transform along the second dimension</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional complex-to-complex DFT
            </summary>
      <param name="nx">The logical size of the transform along the first dimension</param>
      <param name="ny">The logical size of the transform along the second dimension</param>
      <param name="nz">The logical size of the transform along the third dimension</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional complex-to-complex DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the logical size along each dimension</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_r2c_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional real-to-complex DFT
            </summary>
      <param name="n">Number of REAL (input) elements in the transform</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_r2c_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional real-to-complex DFT
            </summary>
      <param name="nx">Number of REAL (input) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (input) elements in the transform along the second dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_r2c_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional real-to-complex DFT
            </summary>
      <param name="nx">Number of REAL (input) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (input) elements in the transform along the second dimension</param>
      <param name="nz">Number of REAL (input) elements in the transform along the third dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_r2c(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional real-to-complex DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the number of REAL (input) elements along each dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_c2r_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional complex-to-real DFT
            </summary>
      <param name="n">Number of REAL (output) elements in the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_c2r_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional complex-to-real DFT
            </summary>
      <param name="nx">Number of REAL (output) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (output) elements in the transform along the second dimension</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_c2r_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional complex-to-real DFT
            </summary>
      <param name="nx">Number of REAL (output) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (output) elements in the transform along the second dimension</param>
      <param name="nz">Number of REAL (output) elements in the transform along the third dimension</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.dft_c2r(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional complex-to-real DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the number of REAL (output) elements along each dimension</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.r2r_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional real-to-real DFT
            </summary>
      <param name="n">Number of elements in the transform</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kind">The kind of real-to-real transform to compute</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.r2r_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional real-to-real DFT
            </summary>
      <param name="nx">Number of elements in the transform along the first dimension</param>
      <param name="ny">Number of elements in the transform along the second dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kindx">The kind of real-to-real transform to compute along the first dimension</param>
      <param name="kindy">The kind of real-to-real transform to compute along the second dimension</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.r2r_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional real-to-real DFT
            </summary>
      <param name="nx">Number of elements in the transform along the first dimension</param>
      <param name="ny">Number of elements in the transform along the second dimension</param>
      <param name="nz">Number of elements in the transform along the third dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kindx">The kind of real-to-real transform to compute along the first dimension</param>
      <param name="kindy">The kind of real-to-real transform to compute along the second dimension</param>
      <param name="kindz">The kind of real-to-real transform to compute along the third dimension</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.r2r(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind[],Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional real-to-real DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the number of elements in the transform along each dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kind">An array containing the kind of real-to-real transform to compute along each dimension</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.flops(System.IntPtr,System.Double@,System.Double@,System.Double@)">
      <summary>
            Returns (approximately) the number of flops used by a certain plan
            </summary>
      <param name="plan">The plan to measure</param>
      <param name="add">Reference to double to hold number of adds</param>
      <param name="mul">Reference to double to hold number of muls</param>
      <param name="fma">Reference to double to hold number of fmas (fused multiply-add)</param>
      <remarks>Total flops ~= add+mul+2*fma or add+mul+fma if fma is supported</remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftw.print_plan(System.IntPtr)">
      <summary>
            Outputs a "nerd-readable" version of the specified plan to stdout
            </summary>
      <param name="plan">The plan to output</param>
    </member>
    <member name="T:Cudafy.Maths.FFT.fftwf">
      <summary>
            Contains the Basic Interface FFTW functions for single-precision (float) operations
            </summary>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.malloc(System.Int32)">
      <summary>
            Allocates FFTW-optimized unmanaged memory
            </summary>
      <param name="length">Amount to allocate, in bytes</param>
      <returns>Pointer to allocated memory</returns>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.free(System.IntPtr)">
      <summary>
            Deallocates memory allocated by FFTW malloc
            </summary>
      <param name="mem">Pointer to memory to release</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.destroy_plan(System.IntPtr)">
      <summary>
            Deallocates an FFTW plan and all associated resources
            </summary>
      <param name="plan">Pointer to the plan to release</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.cleanup">
      <summary>
            Clears all memory used by FFTW, resets it to initial state. Does not replace destroy_plan and free
            </summary>
      <remarks>After calling fftw_cleanup, all existing plans become undefined, and you should not 
            attempt to execute them nor to destroy them. You can however create and execute/destroy new plans, 
            in which case FFTW starts accumulating wisdom information again. 
            fftw_cleanup does not deallocate your plans; you should still call fftw_destroy_plan for this purpose.</remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.set_timelimit(System.Double)">
      <summary>
            Sets the maximum time that can be used by the planner.
            </summary>
      <param name="seconds">Maximum time, in seconds.</param>
      <remarks>This function instructs FFTW to spend at most seconds seconds (approximately) in the planner. 
            If seconds == -1.0 (the default value), then planning time is unbounded. 
            Otherwise, FFTW plans with a progressively wider range of algorithms until the the given time limit is 
            reached or the given range of algorithms is explored, returning the best available plan. For example, 
            specifying fftw_flags.Patient first plans in Estimate mode, then in Measure mode, then finally (time 
            permitting) in Patient. If fftw_flags.Exhaustive is specified instead, the planner will further progress to 
            Exhaustive mode. 
            </remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.execute(System.IntPtr)">
      <summary>
            Executes an FFTW plan, provided that the input and output arrays still exist
            </summary>
      <param name="plan">Pointer to the plan to execute</param>
      <remarks>execute (and equivalents) is the only function in FFTW guaranteed to be thread-safe.</remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional complex-to-complex DFT
            </summary>
      <param name="n">The logical size of the transform</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional complex-to-complex DFT
            </summary>
      <param name="nx">The logical size of the transform along the first dimension</param>
      <param name="ny">The logical size of the transform along the second dimension</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional complex-to-complex DFT
            </summary>
      <param name="nx">The logical size of the transform along the first dimension</param>
      <param name="ny">The logical size of the transform along the second dimension</param>
      <param name="nz">The logical size of the transform along the third dimension</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_direction,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional complex-to-complex DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the logical size along each dimension</param>
      <param name="direction">Specifies the direction of the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_r2c_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional real-to-complex DFT
            </summary>
      <param name="n">Number of REAL (input) elements in the transform</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_r2c_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional real-to-complex DFT
            </summary>
      <param name="nx">Number of REAL (input) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (input) elements in the transform along the second dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_r2c_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional real-to-complex DFT
            </summary>
      <param name="nx">Number of REAL (input) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (input) elements in the transform along the second dimension</param>
      <param name="nz">Number of REAL (input) elements in the transform along the third dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_r2c(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional real-to-complex DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the number of REAL (input) elements along each dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 8-byte complex numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_c2r_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional complex-to-real DFT
            </summary>
      <param name="n">Number of REAL (output) elements in the transform</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_c2r_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional complex-to-real DFT
            </summary>
      <param name="nx">Number of REAL (output) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (output) elements in the transform along the second dimension</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_c2r_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional complex-to-real DFT
            </summary>
      <param name="nx">Number of REAL (output) elements in the transform along the first dimension</param>
      <param name="ny">Number of REAL (output) elements in the transform along the second dimension</param>
      <param name="nz">Number of REAL (output) elements in the transform along the third dimension</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.dft_c2r(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional complex-to-real DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the number of REAL (output) elements along each dimension</param>
      <param name="input">Pointer to an array of 8-byte complex numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.r2r_1d(System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 1-dimensional real-to-real DFT
            </summary>
      <param name="n">Number of elements in the transform</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kind">The kind of real-to-real transform to compute</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.r2r_2d(System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 2-dimensional real-to-real DFT
            </summary>
      <param name="nx">Number of elements in the transform along the first dimension</param>
      <param name="ny">Number of elements in the transform along the second dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kindx">The kind of real-to-real transform to compute along the first dimension</param>
      <param name="kindy">The kind of real-to-real transform to compute along the second dimension</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.r2r_3d(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_kind,Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for a 3-dimensional real-to-real DFT
            </summary>
      <param name="nx">Number of elements in the transform along the first dimension</param>
      <param name="ny">Number of elements in the transform along the second dimension</param>
      <param name="nz">Number of elements in the transform along the third dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kindx">The kind of real-to-real transform to compute along the first dimension</param>
      <param name="kindy">The kind of real-to-real transform to compute along the second dimension</param>
      <param name="kindz">The kind of real-to-real transform to compute along the third dimension</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.r2r(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,Cudafy.Maths.FFT.fftw_kind[],Cudafy.Maths.FFT.fftw_flags)">
      <summary>
            Creates a plan for an n-dimensional real-to-real DFT
            </summary>
      <param name="rank">Number of dimensions</param>
      <param name="n">Array containing the number of elements in the transform along each dimension</param>
      <param name="input">Pointer to an array of 4-byte real numbers</param>
      <param name="output">Pointer to an array of 4-byte real numbers</param>
      <param name="kind">An array containing the kind of real-to-real transform to compute along each dimension</param>
      <param name="flags">Flags that specify the behavior of the planner</param>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.flops(System.IntPtr,System.Double@,System.Double@,System.Double@)">
      <summary>
            Returns (approximately) the number of flops used by a certain plan
            </summary>
      <param name="plan">The plan to measure</param>
      <param name="add">Reference to double to hold number of adds</param>
      <param name="mul">Reference to double to hold number of muls</param>
      <param name="fma">Reference to double to hold number of fmas (fused multiply-add)</param>
      <remarks>Total flops ~= add+mul+2*fma or add+mul+fma if fma is supported</remarks>
    </member>
    <member name="M:Cudafy.Maths.FFT.fftwf.print_plan(System.IntPtr)">
      <summary>
            Outputs a "nerd-readable" version of the specified plan to stdout
            </summary>
      <param name="plan">The plan to output</param>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateUniform(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT)">
      <summary>
            GenerateUniform
            </summary>
      <param name="generator">Handle</param>
      <param name="outputPtr">Single array</param>
      <param name="n">Count</param>
      <returns>Status</returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateUniformDouble(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT)">
      <summary>
            GenerateUniform
            </summary>
      <param name="generator">Handle</param>
      <param name="outputPtr">Double array</param>
      <param name="n">Count</param>
      <returns>Status</returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.Generate(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT)">
      <summary>
      </summary>
      <param name="generator">
      </param>
      <param name="outputPtr">Int32 array</param>
      <param name="num">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateLogNormal(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT,System.Single,System.Single)">
      <summary>
      </summary>
      <param name="generator">
      </param>
      <param name="outputPtr">Float array</param>
      <param name="n">
      </param>
      <param name="mean">
      </param>
      <param name="stddev">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateLogNormalDouble(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT,System.Double,System.Double)">
      <summary>
      </summary>
      <param name="generator">
      </param>
      <param name="outputPtr">Double array</param>
      <param name="n">
      </param>
      <param name="mean">
      </param>
      <param name="stddev">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateLongLong(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT)">
      <summary>
      </summary>
      <param name="generator">
      </param>
      <param name="outputPtr">UInt64 array</param>
      <param name="num">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateNormal(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT,System.Single,System.Single)">
      <summary>
      </summary>
      <param name="generator">
      </param>
      <param name="outputPtr">Single Array</param>
      <param name="n">
      </param>
      <param name="mean">
      </param>
      <param name="stddev">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GenerateNormalDouble(Cudafy.Maths.RAND.RandGenerator,System.IntPtr,GASS.Types.SizeT,System.Double,System.Double)">
      <summary>
      </summary>
      <param name="generator">
      </param>
      <param name="outputPtr">Double array</param>
      <param name="n">
      </param>
      <param name="mean">
      </param>
      <param name="stddev">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GetScrambleConstants32(System.IntPtr@)">
      <summary>
      </summary>
      <param name="constants">UInt32 array</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.RAND.ICURANDDriver.GetScrambleConstants64(System.IntPtr@)">
      <summary>
      </summary>
      <param name="constants">UInt64 array</param>
      <returns>
      </returns>
    </member>
    <member name="T:Cudafy.Maths.RAND.curandDirectionVectorSet">
      <summary>
            Rand Direction Vector Set
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandDirectionVectorSet.CURAND_DIRECTION_VECTORS_32_JOEKUO6">
      <summary>
            Specific set of 32-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandDirectionVectorSet.CURAND_SCRAMBLED_DIRECTION_VECTORS_32_JOEKUO6">
      <summary>
            Specific set of 32-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions, and scrambled
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandDirectionVectorSet.CURAND_DIRECTION_VECTORS_64_JOEKUO6">
      <summary>
            Specific set of 64-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandDirectionVectorSet.CURAND_SCRAMBLED_DIRECTION_VECTORS_64_JOEKUO6">
      <summary>
            Specific set of 64-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions, and scrambled
            </summary>
    </member>
    <member name="T:Cudafy.Maths.RAND.curandStatus">
      <summary>
            Status
            </summary>
    </member>
    <member name="T:Cudafy.Maths.RAND.curandRngType">
      <summary>
      </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_TEST">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_PSEUDO_DEFAULT">
      <summary>
            Default pseudorandom generator
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_PSEUDO_XORWOW">
      <summary>
            XORWOW pseudorandom generator
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_QUASI_DEFAULT">
      <summary>
            Default quasirandom generator
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_QUASI_SOBOL32">
      <summary>
            Sobol32 quasirandom generator
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_QUASI_SCRAMBLED_SOBOL32">
      <summary>
            Scrambled Sobol32 quasirandom generator
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_QUASI_SOBOL64">
      <summary>
            Sobol64 quasirandom generator
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandRngType.CURAND_RNG_QUASI_SCRAMBLED_SOBOL64">
      <summary>
            Scrambled Sobol64 quasirandom generator
            </summary>
    </member>
    <member name="T:Cudafy.Maths.RAND.curandOrdering">
      <summary>
      </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandOrdering.CURAND_ORDERING_PSEUDO_BEST">
      <summary>
            Best ordering for pseudorandom results
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandOrdering.CURAND_ORDERING_PSEUDO_DEFAULT">
      <summary>
            Specific default 4096 thread sequence for pseudorandom results
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandOrdering.CURAND_ORDERING_PSEUDO_SEEDED">
      <summary>
            Specific seeding pattern for fast lower quality pseudorandom results
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.curandOrdering.CURAND_ORDERING_QUASI_DEFAULT">
      <summary>
            Specific n-dimensional ordering for quasirandom results
            </summary>
    </member>
    <member name="T:Cudafy.Maths.RAND.RandDirectionVectors32">
      <summary>
            Array of 32 * 32-bit direction vectors.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.RandDirectionVectors32.direction_vectors">
      <summary>
            Fixed size array of 32 direction vectors.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.RAND.RandDirectionVectors64">
      <summary>
            Array of 64 * 64-bit direction vectors.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.RAND.RandDirectionVectors64.direction_vectors">
      <summary>
            Fixed size array of 64 direction vectors.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.RAND.RandGenerator">
      <summary>
      </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.GPGPUSPARSE">
      <summary>
            Abstract base class for devices supporting SPARSE matrices.
            Warning: This code is alpha and incomplete.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Create(Cudafy.Host.GPGPU)">
      <summary>
            Creates a SPARSE wrapper based on the specified gpu. Note only CudaGPU is supported.
            </summary>
      <param name="gpu">The gpu.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Cudafy.Maths.SPARSE.GPGPUSPARSE" /> class.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Cudafy.Maths.SPARSE.GPGPUSPARSE" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Shutdown">
      <summary>
            Shutdowns this instance.
            </summary>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.GetVersionInfo">
      <summary>
            Gets the version info.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.NNZ(System.Int32,System.Int32,System.Single[],System.Int32[],Cudafy.Maths.SPARSE.cusparseDirection,System.Int32)">
      <summary>
            Computes the number of non-zero elements per row or column and the total number of non-zero elements.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="vector">array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
      <param name="dirA">indicates whether to count the number of non-zero elements per row or per column, respectively.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
      <returns>total number of non-zero elements.</returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.NNZ(System.Int32,System.Int32,System.Single[],System.Int32[],Cudafy.Maths.SPARSE.cusparseMatDescr,Cudafy.Maths.SPARSE.cusparseDirection,System.Int32)">
      <summary>
            Computes the number of non-zero elements per row or column and the total number of non-zero elements.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="vector">array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="dirA">indicates whether to count the number of non-zero elements per row or per column, respectively.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
      <returns>total number of non-zero elements.</returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.NNZ(System.Int32,System.Int32,System.Double[],System.Int32[],Cudafy.Maths.SPARSE.cusparseDirection,System.Int32)">
      <summary>
            Computes the number of non-zero elements per row or column and the total number of non-zero elements.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="vector">array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
      <param name="dirA">indicates whether to count the number of non-zero elements per row or per column, respectively.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
      <returns>total number of non-zero elements.</returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.NNZ(System.Int32,System.Int32,System.Double[],System.Int32[],Cudafy.Maths.SPARSE.cusparseMatDescr,Cudafy.Maths.SPARSE.cusparseDirection,System.Int32)">
      <summary>
            Computes the number of non-zero elements per row or column and the total number of non-zero elements.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="vector">array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="dirA">indicates whether to count the number of non-zero elements per row or per column, respectively.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
      <returns>total number of non-zero elements.</returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSR(System.Int32,System.Int32,System.Single[],System.Int32[],System.Single[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSR format. All the parameters are pre-allocated by the user, and the arrays are filled in based on nnzPerRow.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
      <param name="csrValA">array of nnz elements to be filled.</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColIndA">array of nnz column indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSR(System.Int32,System.Int32,System.Single[],System.Int32[],System.Single[],System.Int32[],System.Int32[],System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSR format. All the parameters are pre-allocated by the user, and the arrays are filled in based on nnzPerRow.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
      <param name="csrValA">array of nnz elements to be filled.</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColIndA">array of nnz column indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSR(System.Int32,System.Int32,System.Double[],System.Int32[],System.Double[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSR format. All the parameters are pre-allocated by the user, and the arrays are filled in based on nnzPerRow.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
      <param name="csrValA">array of nnz elements to be filled.</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColIndA">array of nnz column indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSR(System.Int32,System.Int32,System.Double[],System.Int32[],System.Double[],System.Int32[],System.Int32[],System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSR format. All the parameters are pre-allocated by the user, and the arrays are filled in based on nnzPerRow.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
      <param name="csrValA">array of nnz elements to be filled.</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColIndA">array of nnz column indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2Dense(System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],System.Single[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix in CSR format defined by the three arrays csrValA, csrRowA and csrColA into a matrix A in dense format.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowsA">array of m+1 index elements.</param>
      <param name="csrColsA">array of nnz column indices.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2Dense(System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Int32)">
      <summary>
            Converts the matrix in CSR format defined by the three arrays csrValA, csrRowA and csrColA into a matrix A in dense format.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowsA">array of m+1 index elements.</param>
      <param name="csrColsA">array of nnz column indices.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2Dense(System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],System.Double[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix in CSR format defined by the three arrays csrValA, csrRowA and csrColA into a matrix A in dense format.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowsA">array of m+1 index elements.</param>
      <param name="csrColsa">array of nnz column indices.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2Dense(System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Int32)">
      <summary>
            Converts the matrix in CSR format defined by the three arrays csrValA, csrRowA and csrColA into a matrix A in dense format.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowsA">array of m+1 index elements.</param>
      <param name="csrColsA">array of nnz column indices.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSC(System.Int32,System.Int32,System.Single[],System.Int32[],System.Single[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSC format. All the parameters are pre-allocated by the user, and the arrays are filled in based nnzPerCol.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerCol">&gt;array of size m containing the number of non-zero elements per column.</param>
      <param name="cscValA">array of nnz elements to be filled.</param>
      <param name="cscRowIndA">array of nnz row indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSC(System.Int32,System.Int32,System.Single[],System.Int32[],System.Single[],System.Int32[],System.Int32[],System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSC format. All the parameters are pre-allocated by the user, and the arrays are filled in based nnzPerCol.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerCol">&gt;array of size m containing the number of non-zero elements per column.</param>
      <param name="cscValA">array of nnz elements to be filled.</param>
      <param name="cscRowIndA">array of nnz row indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSC(System.Int32,System.Int32,System.Double[],System.Int32[],System.Double[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSC format. All the parameters are pre-allocated by the user, and the arrays are filled in based nnzPerCol.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerCol">&gt;array of size m containing the number of non-zero elements per column.</param>
      <param name="cscValA">array of nnz elements to be filled.</param>
      <param name="cscRowIndA">array of nnz row indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.Dense2CSC(System.Int32,System.Int32,System.Double[],System.Int32[],System.Double[],System.Int32[],System.Int32[],System.Int32)">
      <summary>
            Converts the matrix A in dense format into a matrix in CSC format. All the parameters are pre-allocated by the user, and the arrays are filled in based nnzPerCol.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="nnzPerCol">&gt;array of size m containing the number of non-zero elements per column.</param>
      <param name="cscValA">array of nnz elements to be filled.</param>
      <param name="cscRowIndA">array of nnz row indices, corresponding to the non-zero elements in the matrix.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSC2Dense(System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],System.Single[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix in CSC format defined by the three arrays cscValA, cscColA and cscRowA into matrix A in dense format. The dense matrix A is filled in with the values of the sparse matrix and with zeros elsewhere.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="cscValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrColA[m] - csrColA[0].</param>
      <param name="cscRowA">array of nnz row indices.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSC2Dense(System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Int32)">
      <summary>
            Converts the matrix in CSC format defined by the three arrays cscValA, cscColA and cscRowA into matrix A in dense format. The dense matrix A is filled in with the values of the sparse matrix and with zeros elsewhere.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="cscValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrColA[m] - csrColA[0].</param>
      <param name="cscRowA">array of nnz row indices.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSC2Dense(System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],System.Double[],Cudafy.Maths.SPARSE.cusparseMatDescr,System.Int32)">
      <summary>
            Converts the matrix in CSC format defined by the three arrays cscValA, cscColA and cscRowA into matrix A in dense format. The dense matrix A is filled in with the values of the sparse matrix and with zeros elsewhere.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="cscValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrColA[m] - csrColA[0].</param>
      <param name="cscRowA">array of nnz row indices.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSC2Dense(System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Int32)">
      <summary>
            Converts the matrix in CSC format defined by the three arrays cscValA, cscColA and cscRowA into matrix A in dense format. The dense matrix A is filled in with the values of the sparse matrix and with zeros elsewhere.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="cscValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrColA[m] - csrColA[0].</param>
      <param name="cscRowA">array of nnz row indices.</param>
      <param name="cscColA">array of n+1 index elements.</param>
      <param name="A">array of dimension (lda, n)</param>
      <param name="lda">leading dimension of A. If lda is 0, automatically be m.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2CSC(System.Int32,System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseAction,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Converts the matrix in CSR format defined with the three arrays csrVal, csrRow and csrCol into matrix A in CSC format defined by array cscVal, cscRow, cscCol.
            The resultng matrix can also be seen as the transpose of the original sparse matrix. This routine can also be used to convert a matrix in CSC format into a matrix in CSR format.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="csrVal">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRow[m] - csrRow[0].</param>
      <param name="csrRow">array of m+1 indices.</param>
      <param name="csrCol">array of nnz column indices.</param>
      <param name="cscVal">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrCol[n] - csrCol[0]. if copyValues is non-zero, updated array.</param>
      <param name="cscRow">updated array of nnz row indices.</param>
      <param name="cscCol">updated array of n+1 index elements.</param>
      <param name="copyValues">if Symbloic, cscVal array is not filled.</param>
      <param name="bs">base index.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2CSC(System.Int32,System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseAction,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Converts the matrix in CSR format defined with the three arrays csrVal, csrRow and csrCol into matrix A in CSC format defined by array cscVal, cscRow, cscCol.
            The resultng matrix can also be seen as the transpose of the original sparse matrix. This routine can also be used to convert a matrix in CSC format into a matrix in CSR format.
            </summary>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="n">number of columns of the matrix A; n must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="csrVal">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRow[m] - csrRow[0].</param>
      <param name="csrRow">array of m+1 indices.</param>
      <param name="csrCol">array of nnz column indices.</param>
      <param name="cscVal">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrCol[n] - csrCol[0]. if copyValues is non-zero, updated array.</param>
      <param name="cscRow">updated array of nnz row indices.</param>
      <param name="cscCol">updated array of n+1 index elements.</param>
      <param name="copyValues">if Symbloic, cscVal array is not filled.</param>
      <param name="bs">base index.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.COO2CSR(System.Int32,System.Int32,System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Converts the array containing the uncompressed row indices (corresponding to COO format) into an array of compressed row pointers (corresponding to CSR format).
            It can also be used to convert the array containing the uncompressed column indices (corresponding to COO format) into an array of column pointers (corresponding to CSC format).
            </summary>
      <param name="nnz">number of non-zeros of the matrix in COO format; this is also the length of array cooRow.</param>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="cooRow">array of row indices.</param>
      <param name="csrRow">array of row pointers.</param>
      <param name="idxBase">base index.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSR2COO(System.Int32,System.Int32,System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Converts the array containing the compressed row pointers (corresponding to CSR format) into an array of uncompressed row indices ( corresponding to COO format).
            It can also be used to convert the array containing the compressed column pointers (corresponding to CSC format) into an array of uncompressed column indices (corresponding to COO format).
            </summary>
      <param name="nnz">number of non-zeros of the matrix in COO format; this is also the length of array cooRow</param>
      <param name="m">number of rows of the matrix A; m must be at least zero.</param>
      <param name="csrRow">array of compressed row pointers.</param>
      <param name="cooRow">array of umcompressed row indices.</param>
      <param name="idxBase">base index.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.AXPY(System.Single@,System.Single[],System.Int32[],System.Single[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Multiplies the vector x in sparse format by the constant alpha and adds
            the result to the vector y in dense format.
            y = alpha * x + y
            </summary>
      <param name="alpha">constant multiplier.</param>
      <param name="vectorx">non-zero values of vector x.</param>
      <param name="indexx">indices corresponding to nonzero values of vector x.</param>
      <param name="vectory">initial vector in dense format.</param>
      <param name="nnz">number of elements of the vector x (set to 0 for all elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.AXPY(System.Double@,System.Double[],System.Int32[],System.Double[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Multiplies the vector x in sparse format by the constant alpha and adds
            the result to the vector y in dense format.
            y = alpha * x + y
            </summary>
      <param name="alpha">constant multiplier.</param>
      <param name="vectorx">non-zero values of vector x.</param>
      <param name="indexx">indices corresponding to nonzero values of vector x.</param>
      <param name="vectory">initial vector in dense format.</param>
      <param name="nnz">number of elements of the vector x (set to 0 for all elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.DOT(System.Single[],System.Int32[],System.Single[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Returns the dot product of a vector x in sparse format and vector y in dense format.
            For i = 0 to n-1
                result += x[i] * y[i]
            </summary>
      <param name="vectorx">non-zero values of vector x.</param>
      <param name="indexx">indices corresponding to non-zero values of vector x.</param>
      <param name="vectory">vector in dense format.</param>
      <param name="n">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
      <returns>result.</returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.DOT(System.Double[],System.Int32[],System.Double[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Returns the dot product of a vector x in sparse format and vector y in dense format.
            For i = 0 to n-1
                result += x[i] * y[i]
            </summary>
      <param name="vectorx">non-zero values of vector x.</param>
      <param name="indexx">indices corresponding to non-zero values of vector x.</param>
      <param name="vectory">vector in dense format.</param>
      <param name="n">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
      <returns>result.</returns>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.GTHR(System.Single[],System.Single[],System.Int32[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Gathers the elements of the vector y listed by the index array indexx into the array vectorx.
            x[i] = y[i]
            </summary>
      <param name="vectory">vectorindenseformat,ofsizegreaterthanorequaltomax(indexx)-idxBase+1</param>
      <param name="vectorx">pre-allocated array in device memory of size greater than or equal to nnz</param>
      <param name="indexx">indices corresponding to non-zero values of vector x.</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.GTHR(System.Double[],System.Double[],System.Int32[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Gathers the elements of the vector y listed by the index array indexx into the array vectorx.
            x[i] = y[i]
            </summary>
      <param name="vectory">vectorindenseformat,ofsizegreaterthanorequaltomax(indexx)-idxBase+1</param>
      <param name="vectorx">pre-allocated array in device memory of size greater than or equal to nnz</param>
      <param name="indexx">indices corresponding to non-zero values of vector x.</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.GTHRZ(System.Single[],System.Single[],System.Int32[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Gathers the elements of the vector y listed by the index array indexx into the array vectorx, and zeroes those elements in the vector y.
            x[i] = y[i]
            y[i] = 0
            </summary>
      <param name="vectory">vectorindenseformat,ofsizegreaterthanorequaltomax(indexx)-idxBase+1.</param>
      <param name="vectorx">pre-allocated array in device memory of size greater than or equal to nnz.</param>
      <param name="indexx">indices corresponding to non-zero values of vector x.</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.GTHRZ(System.Double[],System.Double[],System.Int32[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Gathers the elements of the vector y listed by the index array indexx into the array vectorx, and zeroes those elements in the vector y.
            x[i] = y[i]
            y[i] = 0
            </summary>
      <param name="vectory">vectorindenseformat,ofsizegreaterthanorequaltomax(indexx)-idxBase+1.</param>
      <param name="vectorx">pre-allocated array in device memory of size greater than or equal to nnz.</param>
      <param name="indexx">indices corresponding to non-zero values of vector x.</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.ROT(System.Single[],System.Int32[],System.Single[],System.Single@,System.Single@,System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Applies givens rotation, defined by values c and s, to vectors x in sparse and y in dense format.
            x[i] = c * x[i] + s * y[i];
            y[i] = c * y[i] - s * x[i];
            </summary>
      <param name="vectorx">non-zero values of the vector x.</param>
      <param name="indexx">indices correspoding to non-zero values of vector x.</param>
      <param name="vectory">vector in dense format.</param>
      <param name="c">scalar</param>
      <param name="s">scalar</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.ROT(System.Double[],System.Int32[],System.Double[],System.Double@,System.Double@,System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Applies givens rotation, defined by values c and s, to vectors x in sparse and y in dense format.
            x[i] = c * x[i] + s * y[i];
            y[i] = c * y[i] - s * x[i];
            </summary>
      <param name="vectorx">non-zero values of the vector x.</param>
      <param name="indexx">indices correspoding to non-zero values of vector x.</param>
      <param name="vectory">vector in dense format.</param>
      <param name="c">scalar</param>
      <param name="s">scalar</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.SCTR(System.Single[],System.Int32[],System.Single[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Scatters the vector x in sparse format into the vector y in dense format.
            It modifies only the lements of y whose indices are listed in the array indexx.
            y[i] = x[i]
            </summary>
      <param name="vectorx">non-zero values of vector x.</param>
      <param name="indexx">indices correspoding to non-zero values of vector x.</param>
      <param name="vectory">pre-allocated vector in dense format, of size greater than or equal to max(indexx)-ibase+1.</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.SCTR(System.Double[],System.Int32[],System.Double[],System.Int32,Cudafy.Maths.SPARSE.cusparseIndexBase)">
      <summary>
            Scatters the vector x in sparse format into the vector y in dense format.
            It modifies only the lements of y whose indices are listed in the array indexx.
            y[i] = x[i]
            </summary>
      <param name="vectorx">non-zero values of vector x.</param>
      <param name="indexx">indices correspoding to non-zero values of vector x.</param>
      <param name="vectory">pre-allocated vector in dense format, of size greater than or equal to max(indexx)-ibase+1.</param>
      <param name="nnz">number of non-zero elements of the vector x (set to 0 for all non-zero elements).</param>
      <param name="ibase">The index base.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMV(System.Int32,System.Int32,System.Int32,System.Single@,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single@,System.Single[],Cudafy.Maths.SPARSE.cusparseMatDescr,Cudafy.Maths.SPARSE.cusparseOperation)">
      <summary>
            Performs one of the matrix-vector operations.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">specifies the number of rows of matrix A; m mmust be at least zero.</param>
      <param name="n">specifies the number of columns of matrix A; n mmust be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * x.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be ontained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of n elements if op(A) = A, and m elements if op(A) = transpose(A).</param>
      <param name="beta">scalar multiplier applied to y. If beta is zero, y does not have to be a valid input.</param>
      <param name="y">vector of m elements if op(A) = A, and n elements if op(A) = transpose(A).</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="op">specifies op(A).</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMV(System.Int32,System.Int32,System.Int32,System.Single@,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single@,System.Single[],Cudafy.Maths.SPARSE.cusparseOperation)">
      <summary>
            Performs one of the matrix-vector operations.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">specifies the number of rows of matrix A; m mmust be at least zero.</param>
      <param name="n">specifies the number of columns of matrix A; n mmust be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * x.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be ontained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of n elements if op(A) = A, and m elements if op(A) = transpose(A).</param>
      <param name="beta">scalar multiplier applied to y. If beta is zero, y does not have to be a valid input.</param>
      <param name="y">vector of m elements if op(A) = A, and n elements if op(A) = transpose(A).</param>
      <param name="op">specifies op(A).</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMV(System.Int32,System.Int32,System.Int32,System.Double@,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double@,System.Double[],Cudafy.Maths.SPARSE.cusparseMatDescr,Cudafy.Maths.SPARSE.cusparseOperation)">
      <summary>
            Performs one of the matrix-vector operations.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">specifies the number of rows of matrix A; m mmust be at least zero.</param>
      <param name="n">specifies the number of columns of matrix A; n mmust be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * x.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be ontained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of n elements if op(A) = A, and m elements if op(A) = transpose(A).</param>
      <param name="beta">scalar multiplier applied to y. If beta is zero, y does not have to be a valid input.</param>
      <param name="y">vector of m elements if op(A) = A, and n elements if op(A) = transpose(A).</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="op">specifies op(A).</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMV(System.Int32,System.Int32,System.Int32,System.Double@,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double@,System.Double[],Cudafy.Maths.SPARSE.cusparseOperation)">
      <summary>
            Performs one of the matrix-vector operations.
            y = alpha * op(A) * x + beta * y
            </summary>
      <param name="m">specifies the number of rows of matrix A; m mmust be at least zero.</param>
      <param name="n">specifies the number of columns of matrix A; n mmust be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * x.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be ontained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of n elements if op(A) = A, and m elements if op(A) = transpose(A).</param>
      <param name="beta">scalar multiplier applied to y. If beta is zero, y does not have to be a valid input.</param>
      <param name="y">vector of m elements if op(A) = A, and n elements if op(A) = transpose(A).</param>
      <param name="op">specifies op(A).</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRSV_ANALYSIS(System.Int32,System.Int32,System.Single[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseOperation,Cudafy.Maths.SPARSE.cusparseSolveAnalysisInfo,Cudafy.Maths.SPARSE.cusparseMatDescr)">
      <summary>
            Performs the analysis phase of the solution of a sparse triangular linear system.
            op(A) * y = alpha * x
            </summary>
      <param name="m">specifies the number of rows and columns of matrix A; m must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="op">specifies op(A).</param>
      <param name="info">structure that stores the information collected during the analysis phase. It should be passed to the solve phase unchanged.</param>
      <param name="descrA">descriptor of matrix A.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRSV_ANALYSIS(System.Int32,System.Int32,System.Double[],System.Int32[],System.Int32[],Cudafy.Maths.SPARSE.cusparseOperation,Cudafy.Maths.SPARSE.cusparseSolveAnalysisInfo,Cudafy.Maths.SPARSE.cusparseMatDescr)">
      <summary>
            Performs the analysis phase of the solution of a sparse triangular linear system.
            op(A) * y = alpha * x
            </summary>
      <param name="m">specifies the number of rows and columns of matrix A; m must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="op">specifies op(A).</param>
      <param name="info">structure that stores the information collected during the analysis phase. It should be passed to the solve phase unchanged.</param>
      <param name="descrA">descriptor of matrix A.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRSV_SOLVE(System.Int32,System.Single@,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single[],Cudafy.Maths.SPARSE.cusparseOperation,Cudafy.Maths.SPARSE.cusparseSolveAnalysisInfo,Cudafy.Maths.SPARSE.cusparseMatDescr)">
      <summary>
            Performs the solve phase of the solution of a sparse triangular linear system.
            op(A) * y = alpha * x
            </summary>
      <param name="m">specifies the number of rows and columns of matrix A; m must be at least zero.</param>
      <param name="alpha">scalar multiplier applied to x.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of m elements.</param>
      <param name="y">vector of m elements. updated according to op(A) * y = alpha * x</param>
      <param name="op">specifies op(A).</param>
      <param name="info">structure that stores the information collected during the analysis phase. It should be passed to the solve phase unchanged.</param>
      <param name="descrA">descriptor of matrix A.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRSV_SOLVE(System.Int32,System.Double@,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double[],Cudafy.Maths.SPARSE.cusparseOperation,Cudafy.Maths.SPARSE.cusparseSolveAnalysisInfo,Cudafy.Maths.SPARSE.cusparseMatDescr)">
      <summary>
            Performs the solve phase of the solution of a sparse triangular linear system.
            op(A) * y = alpha * x
            </summary>
      <param name="m">specifies the number of rows and columns of matrix A; m must be at least zero.</param>
      <param name="alpha">scalar multiplier applied to x.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRow[m] - csrRow[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="x">vector of m elements.</param>
      <param name="y">vector of m elements. updated according to op(A) * y = alpha * x</param>
      <param name="op">specifies op(A).</param>
      <param name="info">structure that stores the information collected during the analysis phase. It should be passed to the solve phase unchanged.</param>
      <param name="descrA">descriptor of matrix A.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMM(System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single@,System.Single[],Cudafy.Maths.SPARSE.cusparseMatDescr,Cudafy.Maths.SPARSE.cusparseOperation,System.Int32,System.Int32)">
      <summary>
            Performs matrix-matrix operations. A is CSR format matrix and B, C is dense format.
            C = alpha * op(A) * B + beta * C
            </summary>
      <param name="m">number of rows of matrix A; m must be at least zero.</param>
      <param name="k">number of columns of matrix A; k must be at least zero.</param>
      <param name="n">number of columns of matrices B and C; n must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * B.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="B">array of dimension (ldb, n).</param>
      <param name="beta">scalar multiplier applied to C. If beta is zero, C does not have to be a valid input.</param>
      <param name="C">array of dimension (ldc, n).</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="op">specifies op(A).</param>
      <param name="ldb">leading dimension of B.</param>
      <param name="ldc">leading dimension of C.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMM(System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single@,System.Single[],Cudafy.Maths.SPARSE.cusparseOperation,System.Int32,System.Int32)">
      <summary>
            Performs matrix-matrix operations. A is CSR format matrix and B, C is dense format.
            C = alpha * op(A) * B + beta * C
            </summary>
      <param name="m">number of rows of matrix A; m must be at least zero.</param>
      <param name="k">number of columns of matrix A; k must be at least zero.</param>
      <param name="n">number of columns of matrices B and C; n must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * B.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="B">array of dimension (ldb, n).</param>
      <param name="beta">scalar multiplier applied to C. If beta is zero, C does not have to be a valid input.</param>
      <param name="C">array of dimension (ldc, n).</param>
      <param name="op">specifies op(A).</param>
      <param name="ldb">leading dimension of B.</param>
      <param name="ldc">leading dimension of C.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMM(System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double@,System.Double[],Cudafy.Maths.SPARSE.cusparseMatDescr,Cudafy.Maths.SPARSE.cusparseOperation,System.Int32,System.Int32)">
      <summary>
            Performs matrix-matrix operations. A is CSR format matrix and B, C is dense format.
            C = alpha * op(A) * B + beta * C
            </summary>
      <param name="m">number of rows of matrix A; m must be at least zero.</param>
      <param name="k">number of columns of matrix A; k must be at least zero.</param>
      <param name="n">number of columns of matrices B and C; n must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * B.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="B">array of dimension (ldb, n).</param>
      <param name="beta">scalar multiplier applied to C. If beta is zero, C does not have to be a valid input.</param>
      <param name="C">array of dimension (ldc, n).</param>
      <param name="descrA">descriptor of matrix A.</param>
      <param name="op">specifies op(A).</param>
      <param name="ldb">leading dimension of B.</param>
      <param name="ldc">leading dimension of C.</param>
    </member>
    <member name="M:Cudafy.Maths.SPARSE.GPGPUSPARSE.CSRMM(System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double@,System.Double[],Cudafy.Maths.SPARSE.cusparseOperation,System.Int32,System.Int32)">
      <summary>
            Performs matrix-matrix operations. A is CSR format matrix and B, C is dense format.
            C = alpha * op(A) * B + beta * C
            </summary>
      <param name="m">number of rows of matrix A; m must be at least zero.</param>
      <param name="k">number of columns of matrix A; k must be at least zero.</param>
      <param name="n">number of columns of matrices B and C; n must be at least zero.</param>
      <param name="nnz">number of non-zero elements of matrix A.</param>
      <param name="alpha">scalar multiplier applied to op(A) * B.</param>
      <param name="csrValA">array of nnz elements, where nnz is the number of non-zero elements and can be obtained from csrRowA[m] - csrRowA[0].</param>
      <param name="csrRowA">array of m+1 index elements.</param>
      <param name="csrColA">array of nnz column indices.</param>
      <param name="B">array of dimension (ldb, n).</param>
      <param name="beta">scalar multiplier applied to C. If beta is zero, C does not have to be a valid input.</param>
      <param name="C">array of dimension (ldc, n).</param>
      <param name="op">specifies op(A).</param>
      <param name="ldb">leading dimension of B.</param>
      <param name="ldc">leading dimension of C.</param>
    </member>
    <member name="P:Cudafy.Maths.SPARSE.GPGPUSPARSE.IsDisposed">
      <summary>
            Gets a value indicating whether this instance is disposed.
            </summary>
      <value>
        <c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.CUSPARSEStatus">
      <summary>
            This is a status type returned by the library functions.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.CUSPARSEStatus.Success">
      <summary>
            The operation completed successfully.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.CUSPARSEStatus.NotInitialized">
      <summary>
            The CUSPARSE library was not initialized.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseAction">
      <summary>
            This type indicates whether the operation is performed only on indices or on data and indices.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseAction.Symbolic">
      <summary>
            The operation is performed only on indices.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseAction.Numeric">
      <summary>
            The operation is performed on data and indices.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseDiagType">
      <summary>
            This type indicates if the matrix diagonal entries are unity.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseDiagType.NonUnit">
      <summary>
            The matrix diagonal has non-unit elements.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseDiagType.Unit">
      <summary>
            The matrix diagonal has unit elements.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseDirection">
      <summary>
            This type indicates whether the elements of a dense matrix should be parsed by rows or by columns.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseDirection.Row">
      <summary>
            The matrix should be parsed by rows.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseDirection.Column">
      <summary>
            The matrix should be parsed by columns.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseFillMode">
      <summary>
            This type indicates if the lower or upper part of a matrix is stored in sparse storage.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseFillMode.Lower">
      <summary>
            The lower triangular part is stored.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseFillMode.Upper">
      <summary>
            The upper triangular part is stored.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseHandle">
      <summary>
            This is a pointer type to an opaque CUSPARSE context, which the user must initialize by calling cusparseCreate() prior to calling any other library function.
            The Handle created and retruned by cusparseCreate() must be passed to every CUSPARSE function.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseIndexBase">
      <summary>
            This is type indicates if the base of the matrix indices is zero or one.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseIndexBase.Zero">
      <summary>
            The base index is zero.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseIndexBase.One">
      <summary>
            The base index is one.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseMatDescr">
      <summary>
            The structure is used to describe the shape and properties of a matrix.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseMatrixType">
      <summary>
            This type indicates the type of matrix stored in sparse storage. Notice that for symmetric, Hermitian and triangular matrices only their lower or upper part is assumed to be stored.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseMatrixType.General">
      <summary>
            The matrix is general.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseMatrixType.Symmetric">
      <summary>
            The matrix is symmetric.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseMatrixType.Hermitian">
      <summary>
            The matrix is Hermitian.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseMatrixType.Triangular">
      <summary>
            The matrix is triangular.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseOperation">
      <summary>
            This type indicates which operations need to be performed with sparse matrix.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseOperation.NonTranspose">
      <summary>
            The non-transpose operation is selected.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseOperation.Transpose">
      <summary>
            The transpose operation is selected.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparseOperation.ConjugateTranspose">
      <summary>
            The conjugate transpose operation is selected.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparsePointerMode">
      <summary>
            This type indicates whether the scalar values are passed by reference on the host or device.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparsePointerMode.Host">
      <summary>
            The scalars are passed by reference on the host.
            </summary>
    </member>
    <member name="F:Cudafy.Maths.SPARSE.cusparsePointerMode.Device">
      <summary>
            The scalars are passed by reference on the device.
            </summary>
    </member>
    <member name="T:Cudafy.Maths.SPARSE.cusparseSolveAnalysisInfo">
      <summary>
            This is a pointer type to an opaque structure holding the information collected in the analysis phase of the solution of the sparse triangular linear system.
            It is expected to be passed unchanged to the solution phase of the sparse triangular linear system.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.INode">
      <summary>
            AST node that supports pattern matching.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.GetChildByRole``1(ICSharpCode.NRefactory.CSharp.Role{``0})">
      <summary>
            Gets the first child with the specified role.
            Returns the role's null object if the child is not found.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.AddChildUnsafe(ICSharpCode.NRefactory.CSharp.AstNode,ICSharpCode.NRefactory.CSharp.Role)">
      <summary>
            Adds a child without performing any safety checks.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.Remove">
      <summary>
            Removes this node from its parent.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.ReplaceWith(ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Replaces this node with the new node.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstNode.Clone">
      <summary>
            Clones the whole subtree starting at this AST node.
            </summary>
      <remarks>Annotations are copied over to the new nodes; and any annotations implementing ICloneable will be cloned.</remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.Ancestors">
      <summary>
            Gets the ancestors of this node (excluding this node itself)
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.Descendants">
      <summary>
            Gets all descendants of this node (excluding this node itself).
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.DescendantsAndSelf">
      <summary>
            Gets all descendants of this node (including this node itself).
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.AstNode.Annotations">
      <summary>
            Gets all annotations stored on this AstNode.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.MemberDeclaration.PrivateImplementationType">
      <summary>
            Only supported on members that can be declared in an interface.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TypeDeclaration">
      <summary>
            class Name&lt;TypeParameters&gt; : BaseTypes where Constraints;
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.ICodeMappings.CodeMappings">
      <summary>
            Gets the code mappings.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAAstBuilder.RunTransformations">
      <summary>
            Runs the C# transformations on the compilation unit.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAAstBuilder.GenerateCode(ICSharpCode.Decompiler.ITextOutput)">
      <summary>
            Generates CUDA code from the abstract source tree.
            </summary>
      <remarks>This method adds ParenthesizedExpressions into the AST, and will run transformations if <see cref="M:Cudafy.Translator.CUDAAstBuilder.RunTransformations" /> was not called explicitly</remarks>
    </member>
    <member name="M:Cudafy.Translator.CUDAAstBuilder.CreateType(Mono.Cecil.TypeDefinition)">
      <summary>
            Creates the AST for a type definition.
            </summary>
      <param name="typeDef">
      </param>
      <returns>TypeDeclaration or DelegateDeclaration.</returns>
    </member>
    <member name="M:Cudafy.Translator.CUDAAstBuilder.ConvertType(Mono.Cecil.TypeReference,Mono.Cecil.ICustomAttributeProvider,Cudafy.Translator.ConvertTypeOptions)">
      <summary>
            Converts a type reference.
            </summary>
      <param name="type">The Cecil type reference that should be converted into
            a type system type reference.</param>
      <param name="typeAttributes">Attributes associated with the Cecil type reference.
            This is used to support the 'dynamic' type.</param>
    </member>
    <member name="M:Cudafy.Translator.CUDAAstBuilder.SetNewModifier(ICSharpCode.NRefactory.CSharp.AttributedNode)">
      <summary>
            Sets new modifier if the member hides some other member from a base type.
            </summary>
      <param name="member">The node of the member which new modifier state should be determined.</param>
    </member>
    <member name="M:Cudafy.Translator.CUDAAstBuilder.HidesByName(Mono.Cecil.IMemberDefinition,System.Boolean)">
      <summary>
            Determines whether any base class member has the same name as the given member.
            </summary>
      <param name="member">The derived type's member.</param>
      <param name="includeBaseMethods">true if names of methods declared in base types should also be checked.</param>
      <returns>true if any base member has the same name as given member, otherwise false.</returns>
    </member>
    <member name="P:Cudafy.Translator.CUDAAstBuilder.CompilationUnit">
      <summary>
            Gets the abstract source tree.
            </summary>
    </member>
    <member name="P:Cudafy.Translator.CUDAAstBuilder.CodeMappings">
      <summary>
        <inheritdoc />
      </summary>
    </member>
    <member name="P:Cudafy.Translator.CUDAAstBuilder.LocalVariables">
      <summary>
            Gets the local variables for the current decompiled type, method, etc.
            <remarks>The key is the metadata token.</remarks></summary>
    </member>
    <member name="T:Cudafy.Translator.CudafyTranslator">
      <summary>
            Implements translation of .NET code to CUDA C.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy">
      <summary>
            Tries to use a previous serialized CudafyModule else cudafies and compiles the type in which the calling method is located. 
            CUDA architecture is 1.3; platform is set to the current application's (x86 or x64); and the CUDA version is the 
            latest official release found on the current machine. 
            </summary>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(Cudafy.eArchitecture)">
      <summary>
            Tries to use a previous serialized CudafyModule else cudafies and compiles the type in which the calling method is located. 
            CUDA architecture is as specified; platform is set to the current application's (x86 or x64); and the CUDA version is the 
            latest official release found on the current machine. 
            </summary>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(Cudafy.ePlatform)">
      <summary>
            Tries to use a previous serialized CudafyModule else cudafies and compiles the type in which the calling method is located. 
            CUDA architecture is 1.3; platform is as specified; and the CUDA version is the 
            latest official release found on the current machine. 
            </summary>
      <param name="platform">The platform.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(Cudafy.ePlatform,Cudafy.eArchitecture)">
      <summary>
            Cudafies for the specified platform.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(System.Object)">
      <summary>
            Cudafies and compiles the type of the specified object with default settings. 
            CUDA architecture is 1.3; platform is set to the current application's (x86 or x64); and the CUDA version is the 
            latest official release found on the current machine. 
            </summary>
      <param name="o">An instance of the type to cudafy. Typically pass 'this'.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(System.Type[])">
      <summary>
            Cudafies and compiles the specified types with default settings. 
            CUDA architecture is 1.3; platform is set to the current application's (x86 or x64); and the CUDA version is the 
            latest official release found on the current machine. 
            </summary>
      <param name="types">The types.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(Cudafy.ePlatform,Cudafy.eArchitecture,System.Type[])">
      <summary>
            Cudafies the specified types for the specified platform.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <param name="types">The types.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(Cudafy.eArchitecture,System.Type[])">
      <summary>
            Cudafies the specified types for the specified architecture on automatic platform.
            </summary>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <param name="types">The types.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Translate(Cudafy.eArchitecture,System.Type[])">
      <summary>
            Translates the specified types for the specified architecture without compiling. You can later call Compile method on the CudafyModule.
            </summary>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <param name="types">The types.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.CudafyOld(Cudafy.ePlatform,Cudafy.eArchitecture,System.Version,System.Boolean,System.Type[])">
      <summary>
            Cudafies the specified types. Working directory will be as per CudafyTranslator.WorkingDirectory.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <param name="cudaVersion">The CUDA version. Specify null to automatically use the highest installed version.</param>
      <param name="compile">if set to <c>true</c> compile to PTX.</param>
      <param name="types">The types.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(Cudafy.ePlatform,Cudafy.eArchitecture,System.Version,System.Boolean,System.Type[])">
      <summary>
            Cudafies the specified types. Working directory will be as per CudafyTranslator.WorkingDirectory.
            </summary>
      <param name="platform">The platform.</param>
      <param name="arch">The CUDA or OpenCL architecture.</param>
      <param name="cudaVersion">The CUDA version. Specify null to automatically use the highest installed version.</param>
      <param name="compile">if set to <c>true</c> compile to PTX.</param>
      <param name="types">The types.</param>
      <returns>A CudafyModule.</returns>
    </member>
    <member name="M:Cudafy.Translator.CudafyTranslator.Cudafy(System.Collections.Generic.IEnumerable{Cudafy.CompileProperties},System.Type[])">
      <summary>
            Translates and compiles the given types against specified compilation properties.
            </summary>
      <param name="props">The settings.</param>
      <param name="types">Types to search and translate.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Translator.CudafyTranslator.Language">
      <summary>
            Gets or sets the language to generate.
            </summary>
      <value>
            The language.
            </value>
    </member>
    <member name="P:Cudafy.Translator.CudafyTranslator.WorkingDirectory">
      <summary>
            Gets or sets the working directory for the compiler. The compiler must write temporary files to disk. This
            can be an issue if the application does not have write access of your application directly.
            </summary>
    </member>
    <member name="P:Cudafy.Translator.CudafyTranslator.TimeOut">
      <summary>
            Gets or sets the time out for compilation.
            </summary>
      <value>
            The time out in milliseconds.
            </value>
    </member>
    <member name="P:Cudafy.Translator.CudafyTranslator.GenerateDebug">
      <summary>
            Gets or sets a value indicating whether to compile for debug.
            </summary>
      <value>
        <c>true</c> if compile for debug; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Translator.CudafyTranslator.AllowClasses">
      <summary>
            Gets or sets a value indicating whether to allow classes to be Cudafyed. 
            Note that DeviceClassHelper utility can be used to move class objects from Host to Device.
            </summary>
      <value>
        <c>true</c> if classes are permitted; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Cudafy.Translator.CudafyTranslator.DeleteTempFiles">
      <summary>
            Gets or sets a value indicating whether to delete any temporary files.
            </summary>
      <value>
        <c>true</c> if delete temporary files; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:ICSharpCode.ILSpy.Language">
      <summary>
            Base class for language-specific decompiler implementations.
            </summary>
    </member>
    <member name="M:ICSharpCode.ILSpy.Language.TypeToString(Mono.Cecil.TypeReference,System.Boolean,Mono.Cecil.ICustomAttributeProvider)">
      <summary>
            Converts a type reference into a string. This method is used by the member tree node for parameter and return types.
            </summary>
    </member>
    <member name="M:ICSharpCode.ILSpy.Language.GetTooltip(Mono.Cecil.MemberReference)">
      <summary>
            Converts a member signature to a string.
            This is used for displaying the tooltip on a member reference.
            </summary>
    </member>
    <member name="M:ICSharpCode.ILSpy.Language.ToString">
      <summary>
            Used for WPF keyboard navigation.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.Language.Name">
      <summary>
            Gets the name of the language (as shown in the UI)
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.Language.FileExtension">
      <summary>
            Gets the file extension used by source code files in this language.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.IAstVisitor`2">
      <summary>
            AST visitor.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.IPatternAstVisitor`2">
      <summary>
            AST visitor that works for patterns.
            </summary>
    </member>
    <member name="T:Cudafy.Translator.CUDAOutputVisitor">
      <summary>
            Outputs the AST.
            </summary>
    </member>
    <member name="F:Cudafy.Translator.CUDAOutputVisitor.lastWritten">
      <summary>
            Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.WriteSpecials(ICSharpCode.NRefactory.CSharp.AstNode,ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Writes all specials from start to end (exclusive). Does not touch the positionStack.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.WriteSpecialsUpToRole(ICSharpCode.NRefactory.CSharp.Role)">
      <summary>
            Writes all specials between the current position (in the positionStack) and the next
            node with the specified role. Advances the current position.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.WriteSpecialsUpToNode(ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Writes all specials between the current position (in the positionStack) and the specified node.
            Advances the current position.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.Comma(ICSharpCode.NRefactory.CSharp.AstNode,System.Boolean)">
      <summary>
            Writes a comma.
            </summary>
      <param name="nextNode">The next node after the comma.</param>
      <param name="noSpaceAfterComma">When set prevents printing a space after comma.</param>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.WriteKeyword(System.String,ICSharpCode.NRefactory.CSharp.Role{ICSharpCode.NRefactory.CSharp.CSharpTokenNode})">
      <summary>
            Writes a keyword, and all specials up to
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.Semicolon">
      <summary>
            Marks the end of a statement
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.Space(System.Boolean)">
      <summary>
            Writes a space depending on policy.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.IsKeyword(System.String,ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Determines whether the specified identifier is a keyword in the given context.
            </summary>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.VisitFieldDeclaration(ICSharpCode.NRefactory.CSharp.FieldDeclaration,System.Object)">
      <summary>
            Visits the field declaration.
            </summary>
      <param name="fieldDeclaration">The field declaration.</param>
      <param name="data">The data.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Cudafy.Translator.CUDAOutputVisitor.VisitParameterDeclaration(ICSharpCode.NRefactory.CSharp.ParameterDeclaration,System.Object)">
      <summary>
            Visits the parameter declaration.
            </summary>
      <param name="parameterDeclaration">The parameter declaration.</param>
      <param name="data">The data.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Cudafy.Translator.CUDAOutputVisitor.ConstantDims">
      <summary>
            Gets or sets the dims of the latest CUDA Constant.
            </summary>
      <value>
            The constant dims.
            </value>
    </member>
    <member name="T:Cudafy.Translator.ExtensionMethods">
      <summary>
            Internal use.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstBuilder.RunTransformations">
      <summary>
            Runs the C# transformations on the compilation unit.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstBuilder.GenerateCode(ICSharpCode.Decompiler.ITextOutput)">
      <summary>
            Generates C# code from the abstract source tree.
            </summary>
      <remarks>This method adds ParenthesizedExpressions into the AST, and will run transformations if <see cref="M:ICSharpCode.Decompiler.Ast.AstBuilder.RunTransformations" /> was not called explicitly</remarks>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstBuilder.CreateType(Mono.Cecil.TypeDefinition)">
      <summary>
            Creates the AST for a type definition.
            </summary>
      <param name="typeDef">
      </param>
      <returns>TypeDeclaration or DelegateDeclaration.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstBuilder.ConvertType(Mono.Cecil.TypeReference,Mono.Cecil.ICustomAttributeProvider,ICSharpCode.Decompiler.Ast.ConvertTypeOptions)">
      <summary>
            Converts a type reference.
            </summary>
      <param name="type">The Cecil type reference that should be converted into
            a type system type reference.</param>
      <param name="typeAttributes">Attributes associated with the Cecil type reference.
            This is used to support the 'dynamic' type.</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstBuilder.SetNewModifier(ICSharpCode.NRefactory.CSharp.AttributedNode)">
      <summary>
            Sets new modifier if the member hides some other member from a base type.
            </summary>
      <param name="member">The node of the member which new modifier state should be determined.</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstBuilder.HidesByName(Mono.Cecil.IMemberDefinition,System.Boolean)">
      <summary>
            Determines whether any base class member has the same name as the given member.
            </summary>
      <param name="member">The derived type's member.</param>
      <param name="includeBaseMethods">true if names of methods declared in base types should also be checked.</param>
      <returns>true if any base member has the same name as given member, otherwise false.</returns>
    </member>
    <member name="P:ICSharpCode.Decompiler.Ast.AstBuilder.CompilationUnit">
      <summary>
            Gets the abstract source tree.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.Ast.AstBuilder.CodeMappings">
      <summary>
        <inheritdoc />
      </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.Ast.AstBuilder.LocalVariables">
      <summary>
            Gets the local variables for the current decompiled type, method, etc.
            <remarks>The key is the metadata token.</remarks></summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstMethodBodyBuilder.CreateMethodBody(Mono.Cecil.MethodDefinition,ICSharpCode.Decompiler.DecompilerContext,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.ParameterDeclaration},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Collections.Generic.IEnumerable{ICSharpCode.Decompiler.ILAst.ILVariable}})">
      <summary>
            Creates the body for the method definition.
            </summary>
      <param name="methodDef">Method definition to decompile.</param>
      <param name="context">Decompilation context.</param>
      <param name="parameters">Parameter declarations of the method being decompiled.
            These are used to update the parameter names when the decompiler generates names for the parameters.</param>
      <param name="localVariables">Local variables storage that will be filled/updated with the local variables.</param>
      <returns>Block for the method body</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.AstMethodBodyBuilder.DivideBySize(ICSharpCode.NRefactory.CSharp.Expression,Mono.Cecil.TypeReference)">
      <summary>
            Divides expr by the size of 'type'.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Expression">
      <summary>
            Base class for expressions.
            </summary>
      <remarks>
            This class is useful even though it doesn't provide any additional functionality:
            It can be used to communicate more information in APIs, e.g. "this subnode will always be an expression"
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Member(System.String)">
      <summary>
            Builds an member reference expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Indexer(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
      <summary>
            Builds an indexer expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Indexer(ICSharpCode.NRefactory.CSharp.Expression[])">
      <summary>
            Builds an indexer expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
      <summary>
            Builds an invocation expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.String,ICSharpCode.NRefactory.CSharp.Expression[])">
      <summary>
            Builds an invocation expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.AstType},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
      <summary>
            Builds an invocation expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
      <summary>
            Builds an invocation expression using this expression as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Expression.Invoke(ICSharpCode.NRefactory.CSharp.Expression[])">
      <summary>
            Builds an invocation expression using this expression as target.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext">
      <summary>
            Context representing the set of assemblies in which a type is being searched.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
      <summary>
            Retrieves a class.
            </summary>
      <param name="nameSpace">Namespace that contains the class</param>
      <param name="name">Name of the class</param>
      <param name="typeParameterCount">Number of type parameters</param>
      <param name="nameComparer">Language-specific rules for how class names are compared</param>
      <returns>The type definition for the class; or null if no such class exists.</returns>
      <remarks>This method never returns inner classes; it can be used only with top-level classes.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetClasses">
      <summary>
            Retrieves all top-level classes.
            </summary>
      <remarks>
            If this method is called within <c>using (pc.Synchronize())</c>, then the returned enumerable is valid
            only until the end of the synchronize block.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetClasses(System.String,System.StringComparer)">
      <summary>
            Retrieves all classes in the specified namespace.
            </summary>
      <param name="nameSpace">Namespace in which classes are being retrieved. Use <c>string.Empty</c> for the root namespace.</param>
      <param name="nameComparer">Language-specific rules for how namespace names are compared</param>
      <returns>List of classes within that namespace.</returns>
      <remarks>
            If this method is called within <c>using (var spc = pc.Synchronize())</c>, then the returned enumerable is valid
            only until the end of the synchronize block.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetNamespaces">
      <summary>
            Retrieves all namespaces.
            </summary>
      <remarks>
            If this method is called within <c>using (var spc = pc.Synchronize())</c>, then the returned enumerable is valid
            only until the end of the synchronize block.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.GetNamespace(System.String,System.StringComparer)">
      <summary>
            Gets a namespace.
            </summary>
      <param name="nameSpace">The full name of the namespace.</param>
      <param name="nameComparer">The comparer to use.</param>
      <returns>The full name of the namespace, if it exists; or null if the namespace does not exist.</returns>
      <remarks>
            For StringComparer.Ordinal, the return value is either null or the input namespace.
            For other name comparers, this method returns the declared name of the namespace.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.Synchronize">
      <summary>
            Returns a <see cref="T:ICSharpCode.NRefactory.TypeSystem.ISynchronizedTypeResolveContext" /> that
            represents the same context as this instance, but cannot be modified
            by other threads.
            The ISynchronizedTypeResolveContext must be disposed from the same thread
            that called this method when it is no longer used.
            </summary>
      <remarks>
            A simple implementation might enter a ReaderWriterLock when the synchronized context
            is created, and releases the lock when Dispose() is called.
            However, implementations based on immutable data structures are also possible.
            </remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CacheManager">
      <summary>
            Returns the cache manager associated with this resolve context,
            or null if caching is not allowed.
            Whenever the resolve context changes in some way, this property must return a new object to
            ensure that old caches are cleared.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ISynchronizedTypeResolveContext">
      <summary>
            Context representing the set of assemblies in which a type is being searched.
            Guarantees that the list of types available in the context is not changed until Dispose() is called.
            The Dispose() method must be called from the same thread that create the
            <c>ISynchronizedTypeResolveContext</c>.
            </summary>
      <remarks>
            A simple implementation might enter a ReaderWriterLock when the synchronized context
            is created, and releases the lock when Dispose() is called.
            However, implementations based on immutable data structures are also possible.
            
            Calling Synchronize() on an already synchronized context is possible, but has no effect.
            Only disposing the outermost ISynchronizedTypeResolveContext releases the lock.
            </remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IProjectContent">
      <summary>
            Mutable container of all classes in an assembly.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.CecilTypeResolveContext">
      <summary>
            ITypeResolveContext implementation that lazily loads types from Cecil.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Statement">
      <summary>
            Base class for statements.
            </summary>
      <remarks>
            This class is useful even though it doesn't provide any additional functionality:
            It can be used to communicate more information in APIs, e.g. "this subnode will always be a statement"
            </remarks>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.CommentStatement">
      <summary>
            Allows storing comments inside IEnumerable{Statement}. Used in the AstMethodBuilder.
            CommentStatement nodes are replaced with regular comments later on.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.DecompilerContext.ReservedVariableNames">
      <summary>
            Used to pass variable names from a method to its anonymous methods.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.IOutputFormatter">
      <summary>
            Output formatter for the Output visitor.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.IOutputFormatter.WriteIdentifier(System.String)">
      <summary>
            Writes an identifier.
            If the identifier conflicts with a keyword, the output visitor will
            call <c>WriteToken("@")</c> before calling WriteIdentifier().
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.IOutputFormatter.WriteKeyword(System.String)">
      <summary>
            Writes a keyword to the output.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.IOutputFormatter.WriteToken(System.String)">
      <summary>
            Writes a token to the output.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.AddCheckedBlocks">
      <summary>
            Add checked/unchecked blocks.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.AddCheckedBlocks.InsertedNode">
      <summary>
            Holds the blocks and expressions that should be inserted
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.AddCheckedBlocks.Result">
      <summary>
            Holds the result of an insertion operation.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.CombineQueryExpressions">
      <summary>
            Combines query expressions and removes transparent identifiers.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.Transforms.CombineQueryExpressions.RemoveTransparentIdentifierReferences(ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Removes all occurrences of transparent identifiers
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.DepthFirstAstVisitor`2">
      <summary>
            AST visitor with a default implementation that visits all node depth-first.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.ContextTrackingVisitor`1">
      <summary>
            Base class for AST visitors that need the current type/method context info.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.ConvertConstructorCallIntoInitializer">
      <summary>
            If the first element of a constructor is a chained constructor call, convert it into a constructor initializer.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.DeclareVariables">
      <summary>
            Moves variable declarations to improved positions.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.Transforms.DeclareVariables.FindDeclarationPoint(ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis,ICSharpCode.NRefactory.CSharp.VariableDeclarationStatement,ICSharpCode.NRefactory.CSharp.BlockStatement,ICSharpCode.NRefactory.CSharp.Statement@)">
      <summary>
            Finds the declaration point for the variable within the specified block.
            </summary>
      <param name="daa">
            Definite assignment analysis, must be prepared for 'block' or one of its parents.
            </param>
      <param name="varDecl">The variable to declare</param>
      <param name="block">The block in which the variable should be declared</param>
      <param name="declarationPoint">
            Output parameter: the first statement within 'block' where the variable needs to be declared.
            </param>
      <returns>
            Returns whether it is possible to move the variable declaration into sub-blocks.
            </returns>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.DelegateConstruction">
      <summary>
            Converts "new Action(obj, ldftn(func))" into "new Action(obj.func)".
            For anonymous methods, creates an AnonymousMethodExpression.
            Also gets rid of any "Display Classes" left over after inlining an anonymous method.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.IntroduceExtensionMethods">
      <summary>
            Converts extension method calls into infix syntax.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.IntroduceQueryExpressions">
      <summary>
            Decompiles query expressions.
            Based on C# 4.0 spec, 7.16.2 Query expression translation
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.Transforms.IntroduceQueryExpressions.ValidateThenByChain(ICSharpCode.NRefactory.CSharp.InvocationExpression,System.String)">
      <summary>
            Ensure that all ThenBy's are correct, and that the list of ThenBy's is terminated by an 'OrderBy' invocation.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.Transforms.IntroduceQueryExpressions.MatchSimpleLambda(ICSharpCode.NRefactory.CSharp.Expression,System.String@,ICSharpCode.NRefactory.CSharp.Expression@)">
      <summary>Matches simple lambdas of the form "a =&gt; b"</summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.IntroduceUsingDeclarations">
      <summary>
            Introduces using declarations.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.PatternStatementTransform">
      <summary>
            Finds the expanded form of using statements using pattern matching and replaces it with a UsingStatement.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Ast.Transforms.PatternStatementTransform.variableAssignPattern">
      <summary>
            $variable = $initializer;
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.Transforms.PatternStatementTransform.TransformTryCatchFinally(ICSharpCode.NRefactory.CSharp.TryCatchStatement)">
      <summary>
            Simplify nested 'try { try {} catch {} } finally {}'.
            This transformation must run after the using/lock tranformations.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.Pattern">
      <summary>
            Base class for all patterns.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.ReplaceMethodCallsWithOperators">
      <summary>
            Replaces method calls with the appropriate operator expressions.
            Also simplifies "x = x op y" into "x op= y" where possible.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Ast.Transforms.ReplaceMethodCallsWithOperators.RestoreOriginalAssignOperatorAnnotation">
      <summary>
            This annotation is used to convert a compound assignment "a += 2;" or increment operator "a++;"
            back to the original "a = a + 2;". This is sometimes necessary when the checked/unchecked semantics
            cannot be guaranteed otherwise (see CheckedUnchecked.ForWithCheckedInitializerAndUncheckedIterator test)
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.TypesHierarchyHelpers.IsBaseMethod(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether one method overrides or hides another method.
            </summary>
      <param name="parentMethod">The method declared in a base type.</param>
      <param name="childMethod">The method declared in a derived type.</param>
      <returns>true if <paramref name="childMethod" /> hides or overrides <paramref name="parentMethod" />,
            otherwise false.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.TypesHierarchyHelpers.IsBaseProperty(Mono.Cecil.PropertyDefinition,Mono.Cecil.PropertyDefinition)">
      <summary>
            Determines whether a property overrides or hides another property.
            </summary>
      <param name="parentProperty">The property declared in a base type.</param>
      <param name="childProperty">The property declared in a derived type.</param>
      <returns>true if the <paramref name="childProperty" /> hides or overrides <paramref name="parentProperty" />,
            otherwise false.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.TypesHierarchyHelpers.FindBaseMethods(Mono.Cecil.MethodDefinition)">
      <summary>
            Finds all methods from base types overridden or hidden by the specified method.
            </summary>
      <param name="method">The method which overrides or hides methods from base types.</param>
      <returns>Methods overriden or hidden by the specified method.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.TypesHierarchyHelpers.FindBaseProperties(Mono.Cecil.PropertyDefinition)">
      <summary>
            Finds all properties from base types overridden or hidden by the specified property.
            </summary>
      <param name="property">The property which overrides or hides properties from base types.</param>
      <returns>Properties overriden or hidden by the specified property.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.Ast.TypesHierarchyHelpers.IsVisibleFromDerived(Mono.Cecil.IMemberDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Determinates whether member of the base type is visible from a derived type.
            </summary>
      <param name="baseMember">The member which visibility is checked.</param>
      <param name="derivedType">The derived type.</param>
      <returns>true if the member is visible from derived type, othewise false.</returns>
    </member>
    <member name="T:ICSharpCode.Decompiler.CecilExtensions">
      <summary>
            Cecil helper methods.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.CecilExtensions.GetEndOffset(Mono.Cecil.Cil.Instruction)">
      <summary>
            Gets the (exclusive) end offset of this instruction.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.SourceCodeMapping">
      <summary>
            Maps the source code to IL.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.SourceCodeMapping.ToArray(System.Boolean)">
      <summary>
            Retrieves the array that contains the IL range and the missing gaps between ranges.
            </summary>
      <returns>The array representation of the step aranges.</returns>
    </member>
    <member name="P:ICSharpCode.Decompiler.SourceCodeMapping.SourceCodeLine">
      <summary>
            Gets or sets the source code line number in the output.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.SourceCodeMapping.ILInstructionOffset">
      <summary>
            Gets or sets IL Range offset for the source code line. E.g.: 13-19 &lt;-&gt; 135.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.SourceCodeMapping.MemberMapping">
      <summary>
            Gets or sets the member mapping this source code mapping belongs to.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.MemberMapping">
      <summary>
            Stores the method information and its source code mappings.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.MemberMapping.MemberReference">
      <summary>
            Gets or sets the type of the mapping.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.MemberMapping.MetadataToken">
      <summary>
            Metadata token of the method.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.MemberMapping.CodeSize">
      <summary>
            Gets or sets the code size for the member mapping.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.MemberMapping.MemberCodeMappings">
      <summary>
            Gets or sets the source code mappings.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.MemberMapping.InvertedList">
      <summary>
            Gets the inverted IL Ranges.<br />
            E.g.: for (0-9, 11-14, 14-18, 21-25) =&gt; (9-11,18-21).
            </summary>
      <returns>IL Range inverted list.</returns>
    </member>
    <member name="T:ICSharpCode.Decompiler.CodeMappings">
      <summary>
            Code mappings helper class.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.CodeMappings.CreateCodeMapping(Mono.Cecil.MethodDefinition,System.Tuple{System.String,System.Collections.Generic.List{ICSharpCode.Decompiler.MemberMapping}})">
      <summary>
            Create code mapping for a method.
            </summary>
      <param name="method">Method to create the mapping for.</param>
      <param name="sourceCodeMappings">Source code mapping storage.</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.CodeMappings.GetInstructionByTypeAndLine(System.Tuple{System.String,System.Collections.Generic.List{ICSharpCode.Decompiler.MemberMapping}},System.String,System.Int32,System.UInt32@)">
      <summary>
            Gets source code mapping and metadata token based on type name and line number.
            </summary>
      <param name="codeMappings">Code mappings storage.</param>
      <param name="typeName">Type name.</param>
      <param name="lineNumber">Line number.</param>
      <param name="metadataToken">Metadata token.</param>
      <returns>
      </returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.CodeMappings.GetInstructionByTypeTokenAndOffset(System.Tuple{System.String,System.Collections.Generic.List{ICSharpCode.Decompiler.MemberMapping}},System.String,System.UInt32,System.Int32,System.Boolean@)">
      <summary>
            Gets a mapping given a type, a token and an IL offset.
            </summary>
      <param name="codeMappings">Code mappings storage.</param>
      <param name="typeName">Type name.</param>
      <param name="token">Token.</param>
      <param name="ilOffset">IL offset.</param>
      <param name="isMatch">True, if perfect match.</param>
      <returns>A code mapping.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.CodeMappings.GetSourceCodeFromMetadataTokenAndOffset(System.Tuple{System.String,System.Collections.Generic.List{ICSharpCode.Decompiler.MemberMapping}},System.String,System.UInt32,System.Int32,Mono.Cecil.MemberReference@,System.Int32@)">
      <summary>
            Gets the source code and type name from metadata token and offset.
            </summary>
      <param name="codeMappings">Code mappings storage.</param>
      <param name="typeName">Current type name.</param>
      <param name="token">Metadata token.</param>
      <param name="ilOffset">IL offset.</param>
      <param name="typeName">Type definition.</param>
      <param name="line">Line number.</param>
      <remarks>It is possible to exist to different types from different assemblies with the same metadata token.</remarks>
    </member>
    <member name="T:ICSharpCode.Decompiler.DecompilerException">
      <summary>
            Desctiption of DecompilerException.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.DecompilerSettings">
      <summary>
            Settings for the decompiler.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AnonymousMethods">
      <summary>
            Decompile anonymous methods/lambdas.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.YieldReturn">
      <summary>
            Decompile enumerators.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AutomaticProperties">
      <summary>
            Decompile automatic properties
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.AutomaticEvents">
      <summary>
            Decompile automatic events
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UsingStatement">
      <summary>
            Decompile using statements.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ForEachStatement">
      <summary>
            Decompile foreach statements.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.LockStatement">
      <summary>
            Decompile lock statements.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.UseDebugSymbols">
      <summary>
            Gets/Sets whether to use variable names from debug symbols, if available.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ObjectOrCollectionInitializers">
      <summary>
            Gets/Sets whether to use C# 3.0 object/collection initializers
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.DecompilerSettings.ShowXmlDocumentation">
      <summary>
            Gets/Sets whether to include XML documentation comments in the decompiled code
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Disassembler.ILStructureType">
      <summary>
            Specifies the type of an IL structure.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Root">
      <summary>
            The root block of the method
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Loop">
      <summary>
            A nested control structure representing a loop.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Try">
      <summary>
            A nested control structure representing a try block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Handler">
      <summary>
            A nested control structure representing a catch, finally, or fault block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructureType.Filter">
      <summary>
            A nested control structure representing an exception filter block.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Disassembler.ILStructure">
      <summary>
            An IL structure.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.StartOffset">
      <summary>
            Start position of the structure.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.EndOffset">
      <summary>
            End position of the structure. (exclusive)
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.ExceptionHandler">
      <summary>
            The exception handler associated with the Try, Filter or Handler block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.LoopEntryPoint">
      <summary>
            The loop's entry point.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.Disassembler.ILStructure.Children">
      <summary>
            The list of child structures.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Disassembler.ILStructure.FindAllBranches(Mono.Cecil.Cil.MethodBody)">
      <summary>
            Finds all branches. Returns list of source offset-&gt;target offset mapping.
            Multiple entries for the same source offset are possible (switch statements).
            The result is sorted by source offset.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.Disassembler.ILStructure.GetInnermost(System.Int32)">
      <summary>
            Gets the innermost structure containing the specified offset.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler">
      <summary>
            Disassembles a method body.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.Disassembler.ReflectionDisassembler">
      <summary>
            Disassembles type and member definitions.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.Disassembler.ReflectionDisassembler.CodeMappings">
      <inheritdoc />
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.JumpType">
      <summary>
            Describes the type of a control flow egde.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.JumpType.Normal">
      <summary>
            A regular control flow edge.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.JumpType.JumpToExceptionHandler">
      <summary>
            Jump to exception handler (an exception occurred)
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.JumpType.LeaveTry">
      <summary>
            Jump from try block to leave target:
            This is not a real jump, as the finally handler is executed first!
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.JumpType.EndFinally">
      <summary>
            Jump at endfinally (to any of the potential leave targets).
            For any leave-instruction, control flow enters the finally block - the edge to the leave target (LeaveTry) is not a real control flow edge.
            EndFinally edges are inserted at the end of the finally block, jumping to any of the targets of the leave instruction.
            This edge type is only used when copying of finally blocks is disabled (with copying, a normal deterministic edge is used at each copy of the endfinally node).
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowEdge">
      <summary>
            Represents an edge in the control flow graph, pointing from Source to Target.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraph">
      <summary>
            Contains the control flow graph.
            </summary>
      <remarks>Use ControlFlowGraph builder to create instances of the ControlFlowGraph.</remarks>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraph.ResetVisited">
      <summary>
            Resets "Visited" to false for all nodes in this graph.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraph.ComputeDominance(System.Threading.CancellationToken)">
      <summary>
            Computes the dominator tree.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraph.ComputeDominanceFrontier">
      <summary>
            Computes dominance frontiers.
            This method requires that the dominator tree is already computed!
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraphBuilder">
      <summary>
            Constructs the Control Flow Graph from a Cecil method body.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraphBuilder.GetInstructionIndex(Mono.Cecil.Cil.Instruction)">
      <summary>
            Determines the index of the instruction (for use with the hasIncomingJumps array)
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraphBuilder.Build">
      <summary>
            Builds the ControlFlowGraph.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowGraphBuilder.CopyFinallySubGraph(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode,ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
      <summary>
            Creates a copy of all nodes pointing to 'end' and replaces those references with references to 'newEnd'.
            Nodes pointing to the copied node are copied recursively to update those references, too.
            This recursion stops at 'start'. The modified version of start is returned.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType">
      <summary>
            Type of the control flow node
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.Normal">
      <summary>
            A normal node represents a basic block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.EntryPoint">
      <summary>
            The entry point of the method.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.RegularExit">
      <summary>
            The exit point of the method (every ret instruction branches to this node)
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.ExceptionalExit">
      <summary>
            This node represents leaving a method irregularly by throwing an exception.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.CatchHandler">
      <summary>
            This node is used as a header for exception handler blocks.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.FinallyOrFaultHandler">
      <summary>
            This node is used as a header for finally blocks and fault blocks.
            Every leave instruction in the try block leads to the handler of the containing finally block;
            and exceptional control flow also leads to this handler.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNodeType.EndFinallyOrFault">
      <summary>
            This node is used as footer for finally blocks and fault blocks.
            Depending on the "copyFinallyBlocks" option used when creating the graph, it is connected with all leave targets using
            EndFinally edges (when not copying); or with a specific leave target using a normal edge (when copying).
            For fault blocks, an exception edge is used to represent the "re-throwing" of the exception.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode">
      <summary>
            Represents a block in the control flow graph.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.BlockIndex">
      <summary>
            Index of this node in the ControlFlowGraph.Nodes collection.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Offset">
      <summary>
            Gets the IL offset of this node.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.NodeType">
      <summary>
            Type of the node.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.EndFinallyOrFaultNode">
      <summary>
            If this node is a FinallyOrFaultHandler node, this field points to the corresponding EndFinallyOrFault node.
            Otherwise, this field is null.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Visited">
      <summary>
            Visited flag, used in various algorithms.
            Before using it in your algorithm, reset it to false by calling ControlFlowGraph.ResetVisited();
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.DominatorTreeChildren">
      <summary>
            List of children in the dominator tree.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.DominanceFrontier">
      <summary>
            The dominance frontier of this node.
            This is the set of nodes for which this node dominates a predecessor, but which are not strictly dominated by this node.
            </summary>
      <remarks>
            b.DominanceFrontier = { y in CFG; (exists p in predecessors(y): b dominates p) and not (b strictly dominates y)}
            </remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Start">
      <summary>
            Start of code block represented by this node. Only set for nodetype == Normal.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.End">
      <summary>
            End of the code block represented by this node. Only set for nodetype == Normal.
            The end is exclusive, the end instruction itself does not belong to this block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.ExceptionHandler">
      <summary>
            Gets the exception handler associated with this node.
            Only set for nodetype == CatchHandler or nodetype == FinallyOrFaultHandler.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Incoming">
      <summary>
            List of incoming control flow edges.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Outgoing">
      <summary>
            List of outgoing control flow edges.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.UserData">
      <summary>
            Any user data
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Dominates(ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode)">
      <summary>
            Gets whether <c>this</c> dominates <paramref name="node" />.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.IsReachable">
      <summary>
            Gets whether this node is reachable. Requires that dominance is computed!
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.CopyFrom">
      <summary>
            Signalizes that this node is a copy of another node.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.ImmediateDominator">
      <summary>
            Gets the immediate dominator (the parent in the dominator tree).
            Null if dominance has not been calculated; or if the node is unreachable.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Predecessors">
      <summary>
            Gets all predecessors (=sources of incoming edges)
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Successors">
      <summary>
            Gets all successors (=targets of outgoing edges)
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode.Instructions">
      <summary>
            Gets all instructions in this node.
            Returns an empty list for special nodes that don't have any instructions.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureDetector">
      <summary>
            Detects the structure of the control flow (exception blocks and loops).
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureDetector.FindNodes(ICSharpCode.Decompiler.FlowAnalysis.ControlStructure,Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.Instruction)">
      <summary>
            Removes all nodes from start to end (exclusive) from this ControlStructure and moves them to the target structure.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureType.Root">
      <summary>
            The root block of the method
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureType.Loop">
      <summary>
            A nested control structure representing a loop.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureType.Try">
      <summary>
            A nested control structure representing a try block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureType.Handler">
      <summary>
            A nested control structure representing a catch, finally, or fault block.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureType.Filter">
      <summary>
            A nested control structure representing an exception filter block.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.ControlStructure">
      <summary>
            Represents the structure detected by the <see cref="T:ICSharpCode.Decompiler.FlowAnalysis.ControlStructureDetector" />.
            
            This is a tree of ControlStructure nodes. Each node contains a set of CFG nodes, and every CFG node is contained in exactly one ControlStructure node.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructure.Nodes">
      <summary>
            The nodes in this control structure.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructure.AllNodes">
      <summary>
            The nodes in this control structure and in all child control structures.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructure.EntryPoint">
      <summary>
            The entry point of this control structure.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.ControlStructure.ExceptionHandler">
      <summary>
            The exception handler associated with this Try,Handler or Finally structure.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.OpCodeInfo">
      <summary>
            Additional info about opcodes.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.OpCodeInfo.IsMoveInstruction">
      <summary>
            'Move' kind of instructions have one input (may be stack or local variable) and copy that value to all outputs (again stack or local variable).
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.OpCodeInfo.CanThrow">
      <summary>
            Specifies whether this opcode is capable of throwing exceptions.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.SimplifyByRefCalls">
      <summary>
            This is a transformation working on SSA form.
            It removes ldloca instructions and replaces them with SpecialOpCode.PrepareByOutCall or SpecialOpCode.PrepareByRefCall.
            This then allows the variable that had its address taken to also be transformed into SSA.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.SsaBlock">
      <summary>
            A block in a control flow graph; with instructions represented by "SsaInstructions" (instructions use variables, no evaluation stack).
            Usually these variables are in SSA form to make analysis easier.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaBlock.BlockIndex">
      <summary>
            The block index in the control flow graph.
            This correspons to the node index in ControlFlowGraph.Nodes, so it can be used to retrieve the original CFG node and look
            up additional information (e.g. dominance).
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.SsaForm">
      <summary>
            Represents a graph of SsaBlocks.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.SsaFormBuilder">
      <summary>
            Constructs "SsaForm" graph for a CFG.
            This class transforms the method from stack-based IL to a register-based IL language.
            Then it calls into TransformToSsa to convert the resulting graph to static single assignment form.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.None">
      <summary>
            No special op code: SsaInstruction has a normal IL instruction
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.Phi">
      <summary>
             function: chooses the appropriate variable based on which CFG edge was used to enter this block
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.PrepareByRefCall">
      <summary>
            Variable is read from before passing it by ref.
            This instruction constructs a managed reference to the variable.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.PrepareByOutCall">
      <summary>
            This instruction constructs a managed reference to the variable.
            The variable is not really read from.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.PrepareForFieldAccess">
      <summary>
            This instruction constructs a managed reference to the variable.
            The reference is used for a field access on a value type.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.WriteAfterByRefOrOutCall">
      <summary>
            Variable is written to after passing it by ref or out.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.Uninitialized">
      <summary>
            Variable is not initialized.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.Parameter">
      <summary>
            Value is passed in as parameter
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.Exception">
      <summary>
            Value is a caught exception.
            TypeOperand is set to the exception type.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SpecialOpCode.InitObj">
      <summary>
            Initialize a value type. Unlike the real initobj instruction, this one does not take an address
            but assigns to the target variable.
            TypeOperand is set to the type being created.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaInstruction.Instruction">
      <summary>
            The original IL instruction.
            May be null for "invented" instructions (SpecialOpCode != None).
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaInstruction.Prefixes">
      <summary>
            Prefixes in front of the IL instruction.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaInstruction.TypeOperand">
      <summary>
            Gets the type operand. This is used only in combination with some special opcodes.
            </summary>
    </member>
    <member name="P:ICSharpCode.Decompiler.FlowAnalysis.SsaInstruction.IsMoveInstruction">
      <summary>
            Gets whether this instruction is a simple assignment from one variable to another.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.SsaOptimization">
      <summary>
            Contains some very simple optimizations that work on the SSA form.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.FlowAnalysis.SsaOptimization.DirectlyStoreToVariables(ICSharpCode.Decompiler.FlowAnalysis.SsaForm)">
      <summary>
            When any instructions stores its result in a stack location that's used only once in a 'stloc' or 'starg' instruction,
            we optimize this to directly store in the target location.
            As optimization this is redundant (does the same as copy propagation), but it'll make us keep the variables named
            after locals instead of keeping the temps as using only the simple copy propagation would do.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.SsaVariable">
      <summary>
            Represents a variable used with the SsaInstruction register-based instructions.
            Despite what the name suggests, the variable is not necessarily in single-assignment form - take a look at "bool IsSingleAssignment".
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaVariable.IsSingleAssignment">
      <summary>
            Gets whether this variable has only a single assignment.
            This field is initialized in TransformToSsa step.
            </summary>
      <remarks>Not all variables can be transformed to single assignment form: variables that have their address taken
            cannot be represented in SSA (although SimplifyByRefCalls will get rid of the address-taking instruction in almost all cases)</remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaVariable.Definition">
      <summary>
            Gets the instruction defining the variable.
            This field is initialized in TransformToSsa step. It is only set for variables with a single assignment.
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.FlowAnalysis.SsaVariable.Usage">
      <summary>
            Gets the places where a variable is used.
            If a single instruction reads a variable 2 times (e.g. adding to itself), then it must be included 2 times in this list!
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.FlowAnalysis.TransformToSsa">
      <summary>
            Convers a method to static single assignment form.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.DefaultDictionary`2">
      <summary>
            Dictionary with default values.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.GotoRemoval.Enter(ICSharpCode.Decompiler.ILAst.ILNode,System.Collections.Generic.HashSet{ICSharpCode.Decompiler.ILAst.ILNode})">
      <summary>
            Get the first expression to be excecuted if the instruction pointer is at the start of the given node.
            Try blocks may not be entered in any way.  If possible, the try block is returned as the node to be executed.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.GotoRemoval.Exit(ICSharpCode.Decompiler.ILAst.ILNode,System.Collections.Generic.HashSet{ICSharpCode.Decompiler.ILAst.ILNode})">
      <summary>
            Get the first expression to be excecuted if the instruction pointer is at the end of the given node
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.ILAstBuilder.StackSlot">
      <summary> Immutable </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.ILAstBuilder.VariableSlot">
      <summary> Immutable </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstBuilder.ConvertLocalVariables(System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILAstBuilder.ByteCode})">
      <summary>
            If possible, separates local variables into several independent variables.
            It should undo any compilers merging.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.ILAstOptimizer">
      <summary>
            IL AST transformation that introduces array, object and collection initializers.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.RemoveRedundantCode(ICSharpCode.Decompiler.ILAst.ILBlock)">
      <summary>
            Removes redundatant Br, Nop, Dup, Pop
            </summary>
      <param name="method">
      </param>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.ReduceBranchInstructionSet(ICSharpCode.Decompiler.ILAst.ILBlock)">
      <summary>
            Reduces the branch codes to just br and brtrue.
            Moves ILRanges to the branch argument
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.IntroducePropertyAccessInstructions(ICSharpCode.Decompiler.ILAst.ILNode)">
      <summary>
            Converts call and callvirt instructions that read/write properties into CallGetter/CallSetter instructions.
            
            CallGetter/CallSetter is used to allow the ILAst to represent "while ((SomeProperty = value) != null)".
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.SplitToBasicBlocks(ICSharpCode.Decompiler.ILAst.ILBlock)">
      <summary>
            Group input into a set of blocks that can be later arbitraliby schufled.
            The method adds necessary branches to make control flow between blocks
            explicit and thus order independent.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.FlattenBasicBlocks(ICSharpCode.Decompiler.ILAst.ILNode)">
      <summary>
            Flattens all nested basic blocks, except the the top level 'node' argument
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.ReduceIfNesting(ICSharpCode.Decompiler.ILAst.ILNode)">
      <summary>
            Reduce the nesting of conditions.
            It should be done on flat data that already had most gotos removed
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.TransformObjectInitializers(System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILNode},ICSharpCode.Decompiler.ILAst.ILExpression,System.Int32)">
      <summary>
            Handles both object and collection initializers.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.IsCollectionType(Mono.Cecil.TypeReference)">
      <summary>
            Gets whether the type supports collection initializers.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.IsSetterInObjectInitializer(ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Gets whether 'expr' represents a setter in an object initializer.
            ('CallvirtSetter(Property, v, value)')
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.IsAddMethodCall(ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Gets whether 'expr' represents the invocation of an 'Add' method in a collection initializer.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizer.ParseObjectInitializer(System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILNode},System.Int32@,ICSharpCode.Decompiler.ILAst.ILVariable,ICSharpCode.Decompiler.ILAst.ILExpression,System.Boolean)">
      <summary>
            Parses an object initializer.
            </summary>
      <param name="body">ILAst block</param>
      <param name="pos">
            Input: position of the instruction assigning to 'v'.
            Output: first position after the object initializer
            </param>
      <param name="v">The variable that holds the object being initialized</param>
      <param name="newObjExpr">The newobj instruction</param>
      <returns>InitObject instruction</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizerExtensionMethods.RunOptimization(ICSharpCode.Decompiler.ILAst.ILBlock,System.Func{System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILNode},ICSharpCode.Decompiler.ILAst.ILBasicBlock,System.Int32,System.Boolean})">
      <summary>
            Perform one pass of a given optimization on this block.
            This block must consist of only basicblocks.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizerExtensionMethods.HasNoSideEffects(ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            The expression has no effect on the program and can be removed
            if its return value is not needed.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILAstOptimizerExtensionMethods.CanBeExpressionStatement(ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Can the expression be used as a statement in C#?
            </summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILBasicBlock.Body">
      <remarks> Body has to start with a label and end with unconditional control flow </remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.DefaultValue">
      <summary>
            Represents the 'default(T)' instruction.
            </summary>
      <remarks>Introduced by SimplifyLdObjAndStObj step</remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.CompoundAssignment">
      <summary>
            ILExpression with a single child: binary operator.
            This expression means that the binary operator will also assign the new value to its left-hand side.
            'CompoundAssignment' must not be used for local variables, as inlining (and other) optimizations don't know that it modifies the variable.
            </summary>
      <remarks>Introduced by MakeCompoundAssignments step</remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.PostIncrement">
      <summary>
            Represents the post-increment operator.
            The first argument is the address of the variable to increment (ldloca instruction).
            The second arugment is the amount the variable is incremented by (ldc.i4 instruction)
            </summary>
      <remarks>Introduced by IntroducePostIncrement step</remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.CallGetter">
      <summary>Calls the getter of a static property (or indexer), or of an instance property on 'base'</summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.CallvirtGetter">
      <summary>Calls the getter of an instance property (or indexer)</summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.CallSetter">
      <summary>Calls the setter of a static property (or indexer), or of an instance property on 'base'</summary>
      <remarks>This allows us to represent "while ((SomeProperty = val) != null) {}"</remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.CallvirtSetter">
      <summary>Calls the setter of a instance property (or indexer)</summary>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.ILCode.AddressOf">
      <summary>Simulates getting the address of the argument instruction.</summary>
      <remarks>
            Used for postincrement for properties, and to represent the Address() method on multi-dimensional arrays.
            Also used when inlining a method call on a value type: "stloc(v, ...); call(M, ldloca(v));" becomes "call(M, AddressOf(...))"
            </remarks>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.ILInlining">
      <summary>
            Performs inlining transformations.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.InlineInto(System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILNode},System.Int32,System.Boolean)">
      <summary>
            Inlines instructions before pos into block.Body[pos].
            </summary>
      <returns>The number of instructions that were inlined.</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.InlineIfPossible(System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILNode},System.Int32@)">
      <summary>
            Aggressively inlines the stloc instruction at block.Body[pos] into the next instruction, if possible.
            If inlining was possible; we will continue to inline (non-aggressively) into the the combined instruction.
            </summary>
      <remarks>
            After the operation, pos will point to the new combined instruction.
            </remarks>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.InlineOneIfPossible(System.Collections.Generic.List{ICSharpCode.Decompiler.ILAst.ILNode},System.Int32,System.Boolean)">
      <summary>
            Inlines the stloc instruction at block.Body[pos] into the next instruction, if possible.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.InlineIfPossible(ICSharpCode.Decompiler.ILAst.ILVariable,ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILNode,System.Boolean)">
      <summary>
            Inlines 'expr' into 'next', if possible.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.IsGeneratedValueTypeTemporary(ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILExpression,System.Int32,ICSharpCode.Decompiler.ILAst.ILVariable,ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Is this a temporary variable generated by the C# compiler for instance method calls on value type values
            </summary>
      <param name="next">The next top-level expression</param>
      <param name="parent">The direct parent of the load within 'next'</param>
      <param name="pos">Index of the load within 'parent'</param>
      <param name="v">The variable being inlined.</param>
      <param name="inlinedExpression">The expression being inlined</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.NonAggressiveInlineInto(ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Determines whether a variable should be inlined in non-aggressive mode, even though it is not a generated variable.
            </summary>
      <param name="next">The next top-level expression</param>
      <param name="parent">The direct parent of the load within 'next'</param>
      <param name="inlinedExpression">The expression being inlined</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.CanInlineInto(ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILVariable,ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Gets whether 'expressionBeingMoved' can be inlined into 'expr'.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.FindLoadInNext(ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILVariable,ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILExpression@,System.Int32@)">
      <summary>
            Finds the position to inline to.
            </summary>
      <returns>true = found; false = cannot continue search; null = not found</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.IsSafeForInlineOver(ICSharpCode.Decompiler.ILAst.ILExpression,ICSharpCode.Decompiler.ILAst.ILExpression)">
      <summary>
            Determines whether it is save to move 'expressionBeingMoved' past 'expr'
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.ILInlining.CopyPropagation">
      <summary>
            Runs a very simple form of copy propagation.
            Copy propagation is used in two cases:
            1) assignments from arguments to local variables
               If the target variable is assigned to only once (so always is that argument) and the argument is never changed (no ldarga/starg),
               then we can replace the variable with the argument.
            2) assignments of address-loading instructions to local variables
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.LoopsAndConditions">
      <summary>
            Description of LoopsAndConditions.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.TypeAnalysis">
      <summary>
            Assigns C# types to IL expressions.
            </summary>
      <remarks>
            Types are inferred in a bidirectional manner:
            The expected type flows from the outside to the inside, the actual inferred type flows from the inside to the outside.
            </remarks>
    </member>
    <member name="F:ICSharpCode.Decompiler.ILAst.TypeAnalysis.NativeInt">
      <summary>
            Information amount used for IntPtr.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.TypeAnalysis.CreateDependencyGraph(ICSharpCode.Decompiler.ILAst.ILNode)">
      <summary>
            Creates the "ExpressionToInfer" instances (=nodes in dependency graph)
            </summary>
      <remarks>
            We are using a dependency graph to ensure that expressions are analyzed in the correct order.
            </remarks>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.TypeAnalysis.InferTypeForExpression(ICSharpCode.Decompiler.ILAst.ILExpression,Mono.Cecil.TypeReference,System.Boolean)">
      <summary>
            Infers the C# type of <paramref name="expr" />.
            </summary>
      <param name="expr">The expression</param>
      <param name="expectedType">The expected type of the expression</param>
      <param name="forceInferChildren">Whether direct children should be inferred even if its not necessary. (does not apply to nested children!)</param>
      <returns>The inferred type</returns>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.TypeAnalysis.Reset(ICSharpCode.Decompiler.ILAst.ILBlock)">
      <summary>
            Clears the type inference data on the method.
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.YieldAnalysisFailedException">
      <summary>
            This exception is thrown when we find something else than we expect from the C# compiler.
            This aborts the analysis and makes the whole transform fail.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.StateRange.UnionWith(ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.StateRange,System.Int32,System.Int32)">
      <summary>
            Unions this state range with (other intersect (minVal to maxVal))
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.StateRange.Simplify">
      <summary>
            Merges overlapping interval ranges.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.AnalyzeCtor">
      <summary>
            Looks at the enumerator's ctor and figures out which of the fields holds the state.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.CreateILAst(Mono.Cecil.MethodDefinition)">
      <summary>
            Creates ILAst for the specified method, optimized up to before the 'YieldReturn' step.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.AnalyzeCurrentProperty">
      <summary>
            Looks at the enumerator's get_Current method and figures out which of the fields holds the current value.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ILAst.YieldReturnDecompiler.InitStateRanges(ICSharpCode.Decompiler.ILAst.ILNode)">
      <summary>
            Initializes the state range logic:
            Clears 'ranges' and sets 'ranges[entryPoint]' to the full range (int.MinValue to int.MaxValue)
            </summary>
    </member>
    <member name="T:ICSharpCode.Decompiler.ReferenceResolvingException">
      <summary>
            Represents an error while resolving a reference to a type or a member.
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ReferenceResolvingException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:ResolveException" /> class
            </summary>
    </member>
    <member name="M:ICSharpCode.Decompiler.ReferenceResolvingException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:ResolveException" /> class
            </summary>
      <param name="message">A <see cref="T:System.String" /> that describes the error. The content of message is intended to be understood by humans. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.ReferenceResolvingException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:ResolveException" /> class
            </summary>
      <param name="message">A <see cref="T:System.String" /> that describes the error. The content of message is intended to be understood by humans. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
      <param name="inner">The exception that is the cause of the current exception. If the innerException parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="M:ICSharpCode.Decompiler.ReferenceResolvingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:ResolveException" /> class
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNode">
      <summary>
            Represents a node in the control flow graph of a C# method.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.None">
      <summary>
            Unknown node type
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.StartNode">
      <summary>
            Node in front of a statement
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.BetweenStatements">
      <summary>
            Node between two statements
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.EndNode">
      <summary>
            Node at the end of a statement list
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNodeType.LoopCondition">
      <summary>
            Node representing the position before evaluating the condition of a loop.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdge.IsLeavingTryFinally">
      <summary>
            Gets whether this control flow edge is leaving any try-finally statements.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdge.TryFinallyStatements">
      <summary>
            Gets the try-finally statements that this control flow edge is leaving.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.Normal">
      <summary>
            Regular control flow.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.ConditionTrue">
      <summary>
            Conditional control flow (edge taken if condition is true)
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.ConditionFalse">
      <summary>
            Conditional control flow (edge taken if condition is false)
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowEdgeType.Jump">
      <summary>
            A jump statement (goto, goto case, break or continue)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder">
      <summary>
            Constructs the control flow graph for C# statements.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.NodeCreationVisitor.CreateConnectedEndNode(ICSharpCode.NRefactory.CSharp.Statement,ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowNode)">
      <summary>
            Creates an end node for <c>stmt</c> and connects <c>from</c> with the new node.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.EvaluateConstant(ICSharpCode.NRefactory.CSharp.Expression)">
      <summary>
            Evaluates an expression.
            </summary>
      <returns>The constant value of the expression; or null if the expression is not a constant.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.EvaluateCondition(ICSharpCode.NRefactory.CSharp.Expression)">
      <summary>
            Evaluates an expression.
            </summary>
      <returns>The value of the constant boolean expression; or null if the value is not a constant boolean expression.</returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.ControlFlowGraphBuilder.EvaluateOnlyPrimitiveConstants">
      <summary>
            Gets/Sets whether to handle only primitive expressions as constants (no complex expressions like "a + b").
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus">
      <summary>
            Represents the definite assignment status of a variable at a specific location.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.PotentiallyAssigned">
      <summary>
            The variable might be assigned or unassigned.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.DefinitelyAssigned">
      <summary>
            The variable is definitely assigned.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.AssignedAfterTrueExpression">
      <summary>
            The variable is definitely assigned iff the expression results in the value 'true'.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.AssignedAfterFalseExpression">
      <summary>
            The variable is definitely assigned iff the expression results in the value 'false'.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentStatus.CodeUnreachable">
      <summary>
            The code is unreachable.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis">
      <summary>
            Implements the C# definite assignment analysis (C# 4.0 Spec: 5.3 Definite assignment)
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.SetAnalyzedRange(ICSharpCode.NRefactory.CSharp.Statement,ICSharpCode.NRefactory.CSharp.Statement)">
      <summary>
            Sets the range of statements to be analyzed.
            This method can be used to restrict the analysis to only a part of the method.
            Only the control flow paths that are fully contained within the selected part will be analyzed.
            </summary>
      <remarks>Both 'start' and 'end' are inclusive.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.ExportGraph">
      <summary>
            Exports the CFG. This method is intended to help debugging issues related to definite assignment.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.EvaluateConstant(ICSharpCode.NRefactory.CSharp.Expression)">
      <summary>
            Evaluates an expression.
            </summary>
      <returns>The constant value of the expression; or null if the expression is not a constant.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.EvaluateCondition(ICSharpCode.NRefactory.CSharp.Expression)">
      <summary>
            Evaluates an expression.
            </summary>
      <returns>The value of the constant boolean expression; or null if the value is not a constant boolean expression.</returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Analysis.DefiniteAssignmentAnalysis.UnassignedVariableUses">
      <summary>
            Gets the unassigned usages of the previously analyzed variable.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Analysis.MinimalResolveContext">
      <summary>
            Resolve context represents the minimal mscorlib required for evaluating constants.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AstNodeCollection`1">
      <summary>
            Represents the children of an AstNode that have a specific role.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AstType">
      <summary>
            A type reference in the C# AST.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.MakePointerType">
      <summary>
            Creates a pointer type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.CSharp.ComposedType" />.
            If this type already is a pointer type, this method just increases the PointerRank of the existing pointer type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.MakeArrayType(System.Int32)">
      <summary>
            Creates an array type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.CSharp.ComposedType" />.
            If this type already is an array type, the additional rank is prepended to the existing array specifier list.
            Thus, <c>new SimpleType("T").MakeArrayType(1).MakeArrayType(2)</c> will result in "T[,][]".
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.MakeNullableType">
      <summary>
            Creates a nullable type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.CSharp.ComposedType" />.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Member(System.String)">
      <summary>
            Builds an expression that can be used to access a static member on this type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
      <summary>
            Builds an invocation expression using this type as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Invoke(System.String,ICSharpCode.NRefactory.CSharp.Expression[])">
      <summary>
            Builds an invocation expression using this type as target.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.AstType.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.AstType},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Expression})">
      <summary>
            Builds an invocation expression using this type as target.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ArraySpecifier">
      <summary>
            [,,,]
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AnonymousMethodExpression">
      <summary>
            delegate(Parameters) {Body}
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AnonymousTypeCreateExpression">
      <summary>
            new { [ExpressionList] }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ArrayCreateExpression">
      <summary>
            new Type[Dimensions]
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.ArrayCreateExpression.AdditionalArraySpecifiers">
      <summary>
            Gets additional array ranks (those without size info).
            Empty for "new int[5,1]"; will contain a single element for "new int[5][]".
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ArrayInitializerExpression">
      <summary>
            { Elements }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AsExpression">
      <summary>
            Expression as TypeReference
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AssignmentExpression">
      <summary>
            Left Operator= Right
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Assign">
      <summary>left = right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Add">
      <summary>left += right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Subtract">
      <summary>left -= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Multiply">
      <summary>left *= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Divide">
      <summary>left /= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Modulus">
      <summary>left %= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.ShiftRight">
      <summary>left &gt;&gt;= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.BitwiseOr">
      <summary>left |= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.ExclusiveOr">
      <summary>left ^= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.AssignmentOperatorType.Any">
      <summary>Any operator (for pattern matching)</summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.BaseReferenceExpression">
      <summary>
            base
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.BinaryOperatorExpression">
      <summary>
            Left Operator Right
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.BitwiseAnd">
      <summary>left &amp; right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.BitwiseOr">
      <summary>left | right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ConditionalAnd">
      <summary>left &amp;&amp; right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ConditionalOr">
      <summary>left || right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ExclusiveOr">
      <summary>left ^ right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.GreaterThan">
      <summary>left &gt; right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.GreaterThanOrEqual">
      <summary>left &gt;= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Equality">
      <summary>left == right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.InEquality">
      <summary>left != right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.LessThan">
      <summary>left &lt; right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.LessThanOrEqual">
      <summary>left &lt;= right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Add">
      <summary>left + right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Subtract">
      <summary>left - right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Multiply">
      <summary>left * right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Divide">
      <summary>left / right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Modulus">
      <summary>left % right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ShiftLeft">
      <summary>left &lt;&lt; right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.ShiftRight">
      <summary>left &gt;&gt; right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.NullCoalescing">
      <summary>left ?? right</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.BinaryOperatorType.Any">
      <summary>
            Any binary operator (used in pattern matching)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.CastExpression">
      <summary>
            (CastTo)Expression
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.CheckedExpression">
      <summary>
            checked(Expression)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ConditionalExpression">
      <summary>
            Condition ? TrueExpression : FalseExpression
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.DefaultValueExpression">
      <summary>
            default(Type)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.DirectionExpression">
      <summary>
            ref Expression
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.EmptyExpression">
      <summary>
            Type&lt;[EMPTY]&gt;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.IndexerExpression">
      <summary>
            Target[Arguments]
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.InvocationExpression">
      <summary>
            Target(Arguments)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.IsExpression">
      <summary>
            Expression is Type
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.LambdaExpression">
      <summary>
            Parameters =&gt; Body
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.MemberReferenceExpression">
      <summary>
            Target.MemberName
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.NamedArgumentExpression">
      <summary>
            Represents a named argument passed to a method or attribute.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.NullReferenceExpression">
      <summary>
            null
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ObjectCreateExpression">
      <summary>
            new Type(Arguments) { Initializer }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ParenthesizedExpression">
      <summary>
            ( Expression )
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.PointerReferenceExpression">
      <summary>
            Target-&gt;MemberName
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.PrimitiveExpression">
      <summary>
            Represents a literal value.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.QueryContinuationClause">
      <summary>
            Represents a query continuation.
            "(from .. select ..) into Identifier" or "(from .. group .. by ..) into Identifier"
            Note that "join .. into .." is not a query continuation!
            
            This is always the first(!!) clause in a query expression.
            The tree for "from a in b select c into d select e" looks like this:
            new QueryExpression {
            	new QueryContinuationClause {
            		PrecedingQuery = new QueryExpression {
            			new QueryFromClause(a in b),
            			new QuerySelectClause(c)
            		},
            		Identifier = d
            	},
            	new QuerySelectClause(e)
            }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.QueryJoinClause">
      <summary>
            Represents a join or group join clause.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.SizeOfExpression">
      <summary>
            sizeof(Type)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.StackAllocExpression">
      <summary>
            stackalloc Type[Count]
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ThisReferenceExpression">
      <summary>
            this
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TypeOfExpression">
      <summary>
            typeof(Type)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TypeReferenceExpression">
      <summary>
            Represents an AstType as an expression.
            This is used when calling a method on a primitive type: "int.Parse()"
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UnaryOperatorExpression">
      <summary>
            Operator Expression
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Not">
      <summary>Logical not (!a)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.BitNot">
      <summary>Bitwise not (~a)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Minus">
      <summary>Unary minus (-a)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Plus">
      <summary>Unary plus (+a)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Increment">
      <summary>Pre increment (++a)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Decrement">
      <summary>Pre decrement (--a)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.PostIncrement">
      <summary>Post increment (a++)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.PostDecrement">
      <summary>Post decrement (a--)</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.UnaryOperatorType.Dereference">
      <summary>Dereferencing (*a)</summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UncheckedExpression">
      <summary>
            unchecked(Expression)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UndocumentedExpression">
      <summary>
            Represents undocumented expressions.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Attribute">
      <summary>
            Attribute(Arguments)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.AttributeSection">
      <summary>
            [AttributeTarget: Attributes]
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Constraint">
      <summary>
            where TypeParameter : BaseTypes
            </summary>
      <remarks>
            new(), struct and class constraints are represented using a PrimitiveType "new", "struct" or "class"
            </remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.DelegateDeclaration">
      <summary>
            delegate ReturnType Name&lt;TypeParameters&gt;(Parameters) where Constraints;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.NamespaceDeclaration">
      <summary>
            namespace Name { Members }
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.NamespaceDeclaration.FullName">
      <summary>
            Gets the full namespace name (including any parent namespaces)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TypeParameterDeclaration">
      <summary>
            [in|out] Name
            
            Represents a type parameter.
            Note: mirroring the C# syntax, constraints are not part of the type parameter declaration, but belong
            to the parent type or method.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UsingAliasDeclaration">
      <summary>
            using Alias = Import;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UsingDeclaration">
      <summary>
            using Import;
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Modifiers.Any">
      <summary>
            Special value used to match any modifiers during pattern matching.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.NodeType.TypeReference">
      <summary>
            DomType
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.NodeType.TypeDeclaration">
      <summary>
            Type or delegate declaration
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.NodeType.Pattern">
      <summary>
            Placeholder for a pattern
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Role">
      <summary>
            Represents the role a node plays within its parent.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Role.IsValid(ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Gets whether the specified node is valid in this role.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Role`1">
      <summary>
            Represents the role a node plays within its parent.
            All nodes with this role have type T.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Role`1.NullObject">
      <summary>
            Gets the null object used when there's no node with this role.
            Not every role has a null object; this property returns null for roles without a null object.
            </summary>
      <remarks>
            Roles used for non-collections should always have a null object, so that no AST property returns null.
            However, roles used for collections only may leave out the null object.
            </remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.BlockStatement">
      <summary>
            { Statements }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.BreakStatement">
      <summary>
            break;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.CheckedStatement">
      <summary>
            checked BodyBlock
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ContinueStatement">
      <summary>
            continue;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.DoWhileStatement">
      <summary>
            "do EmbeddedStatement while(Condition);"
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.EmptyStatement">
      <summary>
            ;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ExpressionStatement">
      <summary>
            Expression;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.FixedStatement">
      <summary>
            fixed (Type Variables) EmbeddedStatement
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ForeachStatement">
      <summary>
            foreach (Type VariableName in InExpression) EmbeddedStatement
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ForStatement">
      <summary>
            for (Initializers; Condition; Iterators) EmbeddedStatement
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.ForStatement.Initializers">
      <summary>
            Gets the list of initializer statements.
            Note: this contains multiple statements for "for (a = 2, b = 1; a &gt; b; a--)", but contains
            only a single statement for "for (int a = 2, b = 1; a &gt; b; a--)" (a single VariableDeclarationStatement with two variables)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.GotoStatement">
      <summary>
            "goto Label;"
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.GotoCaseStatement">
      <summary>
            or "goto case LabelExpression;"
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.GotoCaseStatement.LabelExpression">
      <summary>
            Used for "goto case LabelExpression;"
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.GotoDefaultStatement">
      <summary>
            or "goto default;"
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.IfElseStatement">
      <summary>
            if (Condition) TrueStatement else FalseStatement
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.LabelStatement">
      <summary>
            Label:
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.LockStatement">
      <summary>
            lock (Expression) EmbeddedStatement;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ReturnStatement">
      <summary>
            return Expression;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.SwitchStatement">
      <summary>
            switch (Expression) { SwitchSections }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ThrowStatement">
      <summary>
            throw Expression;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TryCatchStatement">
      <summary>
            try TryBlock CatchClauses finally FinallyBlock
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.CatchClause">
      <summary>
            catch (Type VariableName) { Body }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UncheckedStatement">
      <summary>
            unchecked BodyBlock
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UnsafeStatement">
      <summary>
            unsafe { Body }
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.UsingStatement">
      <summary>
            using (ResourceAcquisition) EmbeddedStatement
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.UsingStatement.ResourceAcquisition">
      <summary>
            Either a VariableDeclarationStatement, or an Expression.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.WhileStatement">
      <summary>
            "while (Condition) EmbeddedStatement"
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.YieldBreakStatement">
      <summary>
            yield break;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.YieldStatement">
      <summary>
            yield return Expression;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Accessor">
      <summary>
            get/set/add/remove
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.ConstructorDeclaration.Name">
      <summary>
            Gets/Sets the name of the class containing the constructor.
            This property can be used to inform the output visitor about the class name when writing a constructor declaration
            without writing the complete type declaration. It is ignored when the constructor has a type declaration as parent.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.DestructorDeclaration.Name">
      <summary>
            Gets/Sets the name of the class containing the destructor.
            This property can be used to inform the output visitor about the class name when writing a destructor declaration
            without writing the complete type declaration. It is ignored when the destructor has a type declaration as parent.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.FixedVariableInitializer">
      <summary>
            Name [ CountExpression ]
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OperatorDeclaration.GetOperatorType(System.String)">
      <summary>
            Gets the operator type from the method name, or null, if the method does not represent one of the known operator types.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OperatorDeclaration.GetName(ICSharpCode.NRefactory.CSharp.OperatorType)">
      <summary>
            Gets the method name for the operator type. ("op_Addition", "op_Implicit", etc.)
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OperatorDeclaration.GetToken(ICSharpCode.NRefactory.CSharp.OperatorType)">
      <summary>
            Gets the token for the operator type ("+", "implicit", etc.)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor">
      <summary>
            Inserts the parentheses into the AST that are needed to ensure the AST can be printed correctly.
            For example, if the AST contains
            BinaryOperatorExpresson(2, Mul, BinaryOperatorExpression(1, Add, 1))); printing that AST
            would incorrectly result in "2 * 1 + 1". By running InsertParenthesesVisitor, the necessary
            parentheses are inserted: "2 * (1 + 1)".
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor.GetPrecedence(ICSharpCode.NRefactory.CSharp.Expression)">
      <summary>
            Gets the row number in the C# 4.0 spec operator precedence table.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor.ParenthesizeIfRequired(ICSharpCode.NRefactory.CSharp.Expression,System.Int32)">
      <summary>
            Parenthesizes the expression if it does not have the minimum required precedence.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.InsertParenthesesVisitor.InsertParenthesesForReadability">
      <summary>
            Gets/Sets whether the visitor should insert parentheses to make the code better looking.
            If this property is false, it will insert parentheses only where strictly required by the language spec.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.OutputVisitor">
      <summary>
            Outputs the AST.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.OutputVisitor.lastWritten">
      <summary>
            Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteSpecials(ICSharpCode.NRefactory.CSharp.AstNode,ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Writes all specials from start to end (exclusive). Does not touch the positionStack.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteSpecialsUpToRole(ICSharpCode.NRefactory.CSharp.Role)">
      <summary>
            Writes all specials between the current position (in the positionStack) and the next
            node with the specified role. Advances the current position.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteSpecialsUpToNode(ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Writes all specials between the current position (in the positionStack) and the specified node.
            Advances the current position.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.Comma(ICSharpCode.NRefactory.CSharp.AstNode,System.Boolean)">
      <summary>
            Writes a comma.
            </summary>
      <param name="nextNode">The next node after the comma.</param>
      <param name="noSpacesAfterComma">When set prevents printing a space after comma.</param>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.WriteKeyword(System.String,ICSharpCode.NRefactory.CSharp.Role{ICSharpCode.NRefactory.CSharp.CSharpTokenNode})">
      <summary>
            Writes a keyword, and all specials up to
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.Semicolon">
      <summary>
            Marks the end of a statement
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.Space(System.Boolean)">
      <summary>
            Writes a space depending on policy.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.OutputVisitor.IsKeyword(System.String,ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Determines whether the specified identifier is a keyword in the given context.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TextWriterOutputFormatter">
      <summary>
            Writes C# code into a TextWriter.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.CSharpParser.ParseSnippet(System.IO.TextReader)">
      <summary>
            Parses a file snippet; guessing what the code snippet represents (compilation unit, type members, block, type reference, expression).
            </summary>
    </member>
    <member name="T:Mono.CSharp.Attributable">
      <summary>
              Base class for objects that can have Attributes applied to them.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attributable.ApplyAttributeBuilder(Mono.CSharp.Attribute,Mono.CSharp.MethodSpec,System.Byte[],Mono.CSharp.PredefinedAttributes)">
      <summary>
            Use member-specific procedure to apply attribute @a in @cb to the entity being built in @builder
            </summary>
    </member>
    <member name="P:Mono.CSharp.Attributable.AttributeTargets">
      <summary>
            Returns one AttributeTarget for this element.
            </summary>
    </member>
    <member name="P:Mono.CSharp.Attributable.ValidAttributeTargets">
      <summary>
            Gets list of valid attribute targets for explicit target declaration.
            The first array item is default target. Don't break this rule.
            </summary>
    </member>
    <member name="T:Mono.CSharp.MemberCore">
      <summary>
              Base representation for members.  This is used to keep track
              of Name, Location and Modifier flags, and handling Attributes.
            </summary>
    </member>
    <member name="F:Mono.CSharp.MemberCore.cached_name">
      <summary>
              Public name
            </summary>
    </member>
    <member name="F:Mono.CSharp.MemberCore.mod_flags">
      <summary>
              Modifier flags that the user specified in the source code
            </summary>
    </member>
    <member name="F:Mono.CSharp.MemberCore.comment">
      <summary>
              XML documentation comment
            </summary>
    </member>
    <member name="F:Mono.CSharp.MemberCore.caching_flags">
      <summary>
              MemberCore flags at first detected then cached
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.Emit">
      <summary>
            Base Emit method. This is also entry point for CLS-Compliant verification.
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.GetAttributeObsolete">
      <summary>
            Returns instance of ObsoleteAttribute for this MemberCore
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.CheckObsoleteness(Mono.CSharp.Location)">
      <summary>
            Checks for ObsoleteAttribute presence. It's used for testing of all non-types elements
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.IsClsComplianceRequired">
      <summary>
            Analyze whether CLS-Compliant verification must be execute for this MemberCore.
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.IsExposedFromAssembly">
      <summary>
            Returns true when MemberCore is exposed from assembly.
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.EnableOverloadChecks(Mono.CSharp.MemberCore)">
      <summary>
            Returns true when a member supports multiple overloads (methods, indexers, etc)
            </summary>
    </member>
    <member name="M:Mono.CSharp.MemberCore.VerifyClsCompliance">
      <summary>
            The main virtual method for CLS-Compliant verifications.
            The method returns true if member is CLS-Compliant and false if member is not
            CLS-Compliant which means that CLS-Compliant tests are not necessary. A descendants override it
            and add their extra verifications.
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberCore.Location">
      <summary>
              Location where this declaration happens
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberCore.DocCommentHeader">
      <summary>
              Represents header string for documentation comment 
              for each member types.
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberCore.CLSAttributeValue">
      <summary>
            Goes through class hierarchy and gets value of first found CLSCompliantAttribute.
            If no is attribute exists then assembly CLSCompliantAttribute is returned.
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberCore.HasClsCompliantAttribute">
      <summary>
            Returns true if MemberCore is explicitly marked with CLSCompliantAttribute
            </summary>
    </member>
    <member name="F:Mono.CSharp.DeclSpace.TypeBuilder">
      <summary>
              This points to the actual definition that is being
              created with System.Reflection.Emit
            </summary>
    </member>
    <member name="M:Mono.CSharp.DeclSpace.AddToContainer(Mono.CSharp.MemberCore,System.String)">
      <summary>
            Adds the member to defined_names table. It tests for duplications and enclosing name conflicts
            </summary>
    </member>
    <member name="M:Mono.CSharp.DeclSpace.GetDefinition(System.String)">
      <summary>
              Returns the MemberCore associated with a given name in the declaration
              space. It doesn't return method based symbols !!
            </summary>
    </member>
    <member name="M:Mono.CSharp.DeclSpace.DefineType">
      <remarks>
             Should be overriten by the appropriate declaration space
            </remarks>
    </member>
    <member name="T:Mono.CSharp.TypeContainer">
      <summary>
              This is the base class for structs and classes.  
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeContainer.AddIndexer(Mono.CSharp.Indexer)">
      <summary>
            Indexer has special handling in constrast to other AddXXX because the name can be driven by IndexerNameAttribute
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeContainer.ResolveBaseTypes(Mono.CSharp.TypeExpr@)">
      <summary>
              This function computes the Base class and also the
              list of interfaces that the class or struct @c implements.
              
              The return value is an array (might be null) of
              interfaces implemented (as Types).
              
              The @base_class argument is set to the base object or null
              if this is `System.Object'. 
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeContainer.Define">
      <summary>
              Populates our TypeBuilder with fields and methods
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeContainer.EmitType">
      <summary>
              Emits the code, this step is performed after all
              the types, enumerations, constructors
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeContainer.VerifyImplements(Mono.CSharp.InterfaceMemberBase)">
      <summary>
              Performs checks for an explicit interface implementation.  First it
              checks whether the `interface_type' is a base inteface implementation.
              Then it checks whether `name' exists in the interface type.
            </summary>
    </member>
    <member name="P:Mono.CSharp.TypeContainer.HasEquals">
      <summary>
            Method container contains Equals method
            </summary>
    </member>
    <member name="P:Mono.CSharp.TypeContainer.HasGetHashCode">
      <summary>
            Method container contains GetHashCode method
            </summary>
    </member>
    <member name="M:Mono.CSharp.ClassOrStruct.DefineDefaultConstructor(System.Boolean)">
      <summary>
            Defines the default constructors 
            </summary>
    </member>
    <member name="M:Mono.CSharp.Class.ConditionalConditions">
            Search for at least one defined condition in ConditionalAttribute of attribute class
            Valid only for attribute classes.
        </member>
    <member name="M:Mono.CSharp.Statement.ResolveUnreachable(Mono.CSharp.BlockContext,System.Boolean)">
      <summary>
              We already know that the statement is unreachable, but we still
              need to resolve it to catch errors.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Statement.DoEmit(Mono.CSharp.EmitContext)">
      <summary>
              Return value indicates whether all code paths emitted return.
            </summary>
    </member>
    <member name="T:Mono.CSharp.Expression">
      <remarks>
              Base class for expressions
            </remarks>
    </member>
    <member name="M:Mono.CSharp.Expression.DoResolve(Mono.CSharp.ResolveContext)">
      <summary>
               Performs semantic analysis on the Expression
             </summary>
      <remarks>
               The Resolve method is invoked to perform the semantic analysis
               on the node.
            
               The return value is an expression (it can be the
               same expression in some cases) or a new
               expression that better represents this node.
               
               For example, optimizations of Unary (LiteralInt)
               would return a new LiteralInt with a negated
               value.
               
               If there is an error during semantic analysis,
               then an error should be reported (using Report)
               and a null value should be returned.
               
               There are two side effects expected from calling
               Resolve(): the the field variable "eclass" should
               be set to any value of the enumeration
               `ExprClass' and the type variable should be set
               to a valid type (this is the type of the
               expression).
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Expression.Resolve(Mono.CSharp.ResolveContext,Mono.CSharp.ResolveFlags)">
      <summary>
               Resolves an expression and performs semantic analysis on it.
             </summary>
      <remarks>
               Currently Resolve wraps DoResolve to perform sanity
               checking and assertion checking on what we expect from Resolve.
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Expression.Resolve(Mono.CSharp.ResolveContext)">
      <summary>
              Resolves an expression and performs semantic analysis on it.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Expression.ResolveLValue(Mono.CSharp.ResolveContext,Mono.CSharp.Expression)">
      <summary>
               Resolves an expression for LValue assignment
             </summary>
      <remarks>
               Currently ResolveLValue wraps DoResolveLValue to perform sanity
               checking and assertion checking on what we expect from Resolve
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Expression.Emit(Mono.CSharp.EmitContext)">
      <summary>
               Emits the code for the expression
             </summary>
      <remarks>
               The Emit method is invoked to generate the code
               for the expression.  
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Expression.#ctor">
      <summary>
              Protected constructor.  Only derivate types should
              be able to be created
            </summary>
    </member>
    <member name="M:Mono.CSharp.Expression.ExprClassFromMemberInfo(Mono.CSharp.MemberSpec,Mono.CSharp.Location)">
      <summary>
              Returns a fully formed expression after a MemberLookup
            </summary>
    </member>
    <member name="M:Mono.CSharp.Expression.GetOperatorTrue(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.Location)">
      <summary>
              Returns an expression that can be used to invoke operator true
              on the expression if it exists.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Expression.GetOperatorFalse(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.Location)">
      <summary>
              Returns an expression that can be used to invoke operator false
              on the expression if it exists.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Expression.Error_UnexpectedKind(Mono.CSharp.Report,Mono.CSharp.MemberCore,System.String,Mono.CSharp.Location)">
      <summary>
              Reports that we were expecting `expr' to be of class `expected'
            </summary>
    </member>
    <member name="T:Mono.CSharp.ExpressionStatement">
      <summary>
              This is just a base class for expressions that can
              appear on statements (invocations, object creation,
              assignments, post/pre increment and decrement).  The idea
              being that they would support an extra Emition interface that
              does not leave a result on the stack.
            </summary>
    </member>
    <member name="M:Mono.CSharp.ExpressionStatement.EmitStatement(Mono.CSharp.EmitContext)">
      <summary>
              Requests the expression to be emitted in a `statement'
              context.  This means that no new value is left on the
              stack after invoking this method (constrasted with
              Emit that will always leave a value on the stack).
            </summary>
    </member>
    <member name="T:Mono.CSharp.Assign">
      <summary>
              The Assign node takes care of assigning the value of source into
              the expression represented by target.
            </summary>
    </member>
    <member name="M:Mono.CSharp.InterfaceMemberBase.FindBaseMember(Mono.CSharp.MemberSpec@)">
      <summary>
            Gets base method and its return type
            </summary>
    </member>
    <member name="T:Mono.CSharp.IMethodData">
      <summary>
            Interface for MethodData class. Holds links to parent members to avoid member duplication.
            </summary>
    </member>
    <member name="M:Mono.CSharp.MethodOrOperator.ConditionalConditions">
      <summary>
            Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
            </summary>
    </member>
    <member name="T:Mono.CSharp.IAssignMethod">
      <summary>
               This interface is implemented by expressions that can be assigned to.
             </summary>
      <remarks>
               This interface is implemented by Expressions whose values can not
               store the result on the top of the stack.
            
               Expressions implementing this (Properties, Indexers and Arrays) would
               perform an assignment of the Expression "source" into its final
               location.
            
               No values on the top of the stack are expected to be left by
               invoking this method.
             </remarks>
    </member>
    <member name="T:Mono.CSharp.IMemoryLocation">
      <summary>
              This interface is implemented by variables
            </summary>
    </member>
    <member name="M:Mono.CSharp.IMemoryLocation.AddressOf(Mono.CSharp.EmitContext,Mono.CSharp.AddressOp)">
      <summary>
               The AddressOf method should generate code that loads
               the address of the object and leaves it on the stack.
            
               The `mode' argument is used to notify the expression
               of whether this will be used to read from the address or
               write to the address.
            
               This is just a hint that can be used to provide good error
               reporting, and should have no other side effects. 
             </summary>
    </member>
    <member name="T:Mono.CSharp.LocalTemporary">
      <summary>
               An Expression to hold a temporary value.
             </summary>
      <remarks>
               The LocalTemporary class is used to hold temporary values of a given
               type to "simulate" the expression semantics. The local variable is
               never captured.
            
               The local temporary is used to alter the normal flow of code generation
               basically it creates a local variable, and its emit instruction generates
               code to access this value, return its address or save its value.
            
               If `is_address' is true, then the value that we store is the address to the
               real value, and not the value itself.
            
               This is needed for a value type, because otherwise you just end up making a
               copy of the value on the stack and modifying it. You really need a pointer
               to the origional value so that you can modify it in that location. This
               Does not happen with a class because a class is a pointer -- so you always
               get the indirection.
            
             </remarks>
    </member>
    <member name="F:Mono.CSharp.ResolveContext.Switch">
      <summary>
              If this is non-null, points to the current switch statement
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.Error_AttributeEmitError(System.String)">
      <summary>
            This is rather hack. We report many emit attribute error with same error to be compatible with
            csc. But because csc has to report them this way because error came from ilasm we needn't.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.ResolveAttributeType">
      <summary>
              Tries to resolve the type of the attribute. Flags an error if it can't, and complain is true.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.GetValidTargets">
      <summary>
              Get a string containing a list of valid targets for the attribute 'attr'
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.GetIndexerAttributeValue">
      <summary>
            Returns custom name of indexer
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.GetConditionalAttributeValue">
      <summary>
            Returns condition of ConditionalAttribute
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.GetObsoleteAttribute">
      <summary>
            Creates the instance of ObsoleteAttribute from this attribute instance
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.GetClsCompliantAttributeValue">
      <summary>
            Returns value of CLSCompliantAttribute contructor parameter but because the method can be called
            before ApplyAttribute. We need to resolve the arguments.
            This situation occurs when class deps is differs from Emit order.  
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.IsSecurityActionValid">
      <summary>
            Tests permitted SecurityAction for assembly or other types
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attribute.ExtractSecurityPermissionSet(Mono.CSharp.MethodSpec,System.Collections.Generic.Dictionary{System.Security.Permissions.SecurityAction,System.Security.PermissionSet}@)">
      <summary>
            Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Mono.CSharp.Attribute.Emit(System.Collections.Generic.Dictionary{Mono.CSharp.Attribute,System.Collections.Generic.List{Mono.CSharp.Attribute}})">
      <summary>
            Emit attribute for Attributable symbol
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attributes.CheckTargets">
      <summary>
            Checks whether attribute target is valid for the current element
            </summary>
    </member>
    <member name="M:Mono.CSharp.Attributes.SearchMulti(Mono.CSharp.PredefinedAttribute)">
      <summary>
            Returns all attributes of type 't'. Use it when attribute is AllowMultiple = true
            </summary>
    </member>
    <member name="T:Mono.CSharp.AttributeTester">
      <summary>
            Helper class for attribute verification routine.
            </summary>
    </member>
    <member name="M:Mono.CSharp.AttributeTester.AreOverloadedMethodParamsClsCompliant(Mono.CSharp.AParametersCollection,Mono.CSharp.AParametersCollection)">
      <summary>
            Returns true if parameters of two compared methods are CLS-Compliant.
            It tests differing only in ref or out, or in array rank.
            </summary>
    </member>
    <member name="M:Mono.CSharp.AttributeTester.Report_ObsoleteMessage(System.ObsoleteAttribute,System.String,Mono.CSharp.Location,Mono.CSharp.Report)">
      <summary>
            Common method for Obsolete error/warning reporting.
            </summary>
    </member>
    <member name="M:Mono.CSharp.ConstantFold.BinaryFold(Mono.CSharp.ResolveContext,Mono.CSharp.Binary.Operator,Mono.CSharp.Constant,Mono.CSharp.Constant,Mono.CSharp.Location)">
      <summary>
               Constant expression folder for binary operations.
            
               Returns null if the expression can not be folded.
             </summary>
    </member>
    <member name="T:Mono.CSharp.Interface">
      <summary>
              Interfaces
            </summary>
    </member>
    <member name="F:Mono.CSharp.Interface.AllowedModifiers">
      <summary>
              Modifiers allowed in a class declaration
            </summary>
    </member>
    <member name="T:Mono.CSharp.EmitContext">
      <summary>
              An Emit Context is created for each body of code (from methods,
              properties bodies, indexer bodies or constructor bodies)
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.return_type">
      <summary>
              The value that is allowed to be returned or NULL if there is no
              return type.
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.temporary_storage">
      <summary>
              Keeps track of the Type to LocalBuilder temporary storage created
              to store structures (used to compute the address of the structure
              value on structure method invocations)
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.return_value">
      <summary>
              The location where we store the return value.
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.ReturnLabel">
      <summary>
              The location where return has to jump to return the
              value
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.HasReturnLabel">
      <summary>
              If we already defined the ReturnLabel
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.LoopBegin">
      <summary>
              Current loop begin and end labels.
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.LoopEnd">
      <summary>
              Current loop begin and end labels.
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.DefaultTarget">
      <summary>
              Default target in a switch statement.   Only valid if
              InSwitch is true
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.Switch">
      <summary>
              If this is non-null, points to the current switch statement
            </summary>
    </member>
    <member name="F:Mono.CSharp.EmitContext.CurrentAnonymousMethod">
      <summary>
             Whether we are inside an anonymous method.
            </summary>
    </member>
    <member name="M:Mono.CSharp.EmitContext.Mark(Mono.CSharp.Location)">
      <summary>
              This is called immediately before emitting an IL opcode to tell the symbol
              writer to which source line this opcode belongs.
            </summary>
    </member>
    <member name="M:Mono.CSharp.EmitContext.GetTemporaryLocal(Mono.CSharp.TypeSpec)">
      <summary>
              Returns a temporary storage for a variable of type t as 
              a local variable in the current body.
            </summary>
    </member>
    <member name="M:Mono.CSharp.EmitContext.TemporaryReturn">
      <summary>
               ReturnValue creates on demand the LocalBuilder for the
               return value from the function.  By default this is not
               used.  This is only required when returns are found inside
               Try or Catch statements.
            
               This method is typically invoked from the Emit phase, so
               we allow the creation of a return label if it was not
               requested during the resolution phase.   Could be cleaned
               up, but it would replicate a lot of logic in the Emit phase
               of the code that uses it.
             </summary>
    </member>
    <member name="M:Mono.CSharp.Const.Define">
      <summary>
              Defines the constant in the @parent
            </summary>
    </member>
    <member name="M:Mono.CSharp.Const.Emit">
      <summary>
             Emits the field value by evaluating the expression
            </summary>
    </member>
    <member name="T:Mono.CSharp.Constant">
      <summary>
              Base class for constants and literals.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Constant.GetValue">
      <summary>
             This is used to obtain the actual value of the literal
             cast into an object.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Constant.ConvertExplicitly(System.Boolean,Mono.CSharp.TypeSpec)">
      <summary>
            Maybe ConvertTo name is better. It tries to convert `this' constant to target_type.
            It throws OverflowException 
            </summary>
    </member>
    <member name="M:Mono.CSharp.Constant.TryReduce(Mono.CSharp.ResolveContext,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Attempts to do a compile-time folding of a constant cast.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Constant.IsDefaultInitializer(Mono.CSharp.TypeSpec)">
      <summary>
            Need to pass type as the constant can require a boxing
            and in such case no optimization is possible
            </summary>
    </member>
    <member name="M:Mono.CSharp.IntConstant.TryImplicitIntConversion(Mono.CSharp.TypeSpec)">
      <summary>
              Attempts to perform an implicit constant conversion of the IntConstant
              into a different data type using casts (See Implicit Constant
              Expression Conversions)
            </summary>
    </member>
    <member name="T:Mono.CSharp.SideEffectConstant">
      <summary>
              The value is constant, but when emitted has a side effect.  This is
              used by BitwiseAnd to ensure that the second expression is invoked
              regardless of the value of the left side.  
            </summary>
    </member>
    <member name="F:Mono.CSharp.BlockContext.ReturnLabel">
      <summary>
              The location where return has to jump to return the
              value
            </summary>
    </member>
    <member name="F:Mono.CSharp.BlockContext.HasReturnLabel">
      <summary>
              If we already defined the ReturnLabel
            </summary>
    </member>
    <member name="M:Mono.CSharp.CloneContext.RemapBlockCopy(Mono.CSharp.Block)">
            
             Remaps block to cloned copy if one exists.
            
        </member>
    <member name="M:Mono.CSharp.Convert.ImplicitNumericConversion(Mono.CSharp.Expression,Mono.CSharp.TypeSpec)">
      <summary>
               Implicit Numeric Conversions.
            
               expr is the expression to convert, returns a new expression of type
               target_type or null if an implicit conversion is not possible.
             </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ImplicitConversionExists(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec)">
      <summary>
             Same as ImplicitStandardConversionExists except that it also looks at
             implicit user defined conversions - needed for overload resolution
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ImplicitStandardConversionExists(Mono.CSharp.Expression,Mono.CSharp.TypeSpec)">
      <summary>
              Determines if a standard implicit conversion exists from
              expr_type to target_type
            
             </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.FindMostEncompassedType(System.Collections.Generic.IEnumerable{Mono.CSharp.TypeSpec})">
      <summary>
             Finds "most encompassed type" according to the spec (13.4.2)
             amongst the methods in the MethodGroupExpr
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.FindMostEncompassingType(System.Collections.Generic.IList{Mono.CSharp.TypeSpec})">
      <summary>
             Finds "most encompassing type" according to the spec (13.4.2)
             amongst the types in the given set
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.FindMostSpecificTarget(System.Collections.Generic.IList{Mono.CSharp.MethodSpec},Mono.CSharp.TypeSpec,System.Boolean)">
      <summary>
             Finds the most specific target Tx according to section 13.4.4
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ImplicitUserConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
             User-defined Implicit conversions
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitUserConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
             User-defined Explicit conversions
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ImplicitConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Converts implicitly the resolved expression `expr' into the
              `target_type'.  It returns a new expression that can be used
              in a context that expects a `target_type'.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ImplicitConversionStandard(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
               Attempts to apply the `Standard Implicit
               Conversion' rules to the expression `expr' into
               the `target_type'.  It returns a new expression
               that can be used in a context that expects a
               `target_type'.
            
               This is different from `ImplicitConversion' in that the
               user defined implicit conversions are excluded.
             </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ImplicitConversionRequired(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Attempts to implicitly convert `source' into `target_type', using
              ImplicitConversion.  If there is no implicit conversion, then
              an error is signaled
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitNumericConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec)">
      <summary>
               Performs the explicit numeric conversions
            
             There are a few conversions that are not part of the C# standard,
             they were interim hacks in the C# compiler that were supposed to
             become explicit operators in the UIntPtr class and IntPtr class,
             but for historical reasons it did not happen, so the C# compiler
             ended up with these special hacks.
            
             See bug 59800 for details.
            
             The conversion are:
               UIntPtr-&gt;SByte
               UIntPtr-&gt;Int16
               UIntPtr-&gt;Int32
               IntPtr-&gt;UInt64
               UInt64-&gt;IntPtr
               SByte-&gt;UIntPtr
               Int16-&gt;UIntPtr
            
             </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitReferenceConversionExists(Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
      <summary>
             Returns whether an explicit reference conversion can be performed
             from source_type to target_type
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitReferenceConversion(Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
      <summary>
              Implements Explicit Reference conversions
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitConversionCore(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Performs an explicit conversion of the expression `expr' whose
              type is expr.Type to `target_type'.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitConversionStandard(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Same as ExplicitConversion, only it doesn't include user defined conversions
            </summary>
    </member>
    <member name="M:Mono.CSharp.Convert.ExplicitConversion(Mono.CSharp.ResolveContext,Mono.CSharp.Expression,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Performs an explicit conversion of the expression `expr' whose
              type is expr.Type to `target_type'.
            </summary>
    </member>
    <member name="T:Mono.CSharp.CSharpParser">
      <summary>
               The C# Parser
            </summary>
    </member>
    <member name="F:Mono.CSharp.CSharpParser.yyFinal">
            debugging support, requires the package jay.yydebug.
                  Set to null to suppress debugging messages.
        </member>
    <member name="F:Mono.CSharp.CSharpParser.current_block">
      <summary>
              Current block is used to add statements as we find
              them.  
            </summary>
    </member>
    <member name="F:Mono.CSharp.CSharpParser.current_local_parameters">
      <summary>
              This is used by the unary_expression code to resolve
              a name against a parameter.  
            </summary>
    </member>
    <member name="F:Mono.CSharp.CSharpParser.oob_stack">
            
             An out-of-band stack.
            
        </member>
    <member name="F:Mono.CSharp.CSharpParser.yacc_verbose_flag">
            
             Controls the verbosity of the errors produced by the parser
            
        </member>
    <member name="F:Mono.CSharp.CSharpParser.UnexpectedEOF">
             
             Used by the interactive shell, flags whether EOF was reached
             and an error was produced
            
        </member>
    <member name="F:Mono.CSharp.CSharpParser.file">
            
             The current file.
            
        </member>
    <member name="F:Mono.CSharp.CSharpParser.tmpComment">
            
             Temporary Xml documentation cache.
             For enum types, we need one more temporary store.
            
        </member>
    <member name="F:Mono.CSharp.CSharpParser.current_attr_target">
            Current attribute target
        </member>
    <member name="F:Mono.CSharp.CSharpParser.InteractiveResult">
            When using the interactive parser, this holds the
            resulting expression
        </member>
    <member name="F:Mono.CSharp.CSharpParser.ErrorOutput">
            error output stream.
                  It should be changeable.
        </member>
    <member name="F:Mono.CSharp.CSharpParser.yyExpectingState">
            index-checked interface to yyNames[].
                  @param token single character or %token value.
                  @return token name or [illegal] or [unknown].
        </member>
    <member name="F:Mono.CSharp.CSharpParser.yyMax">
            initial size and increment of the state/value stack [default 256].
                  This is not final so that it can be overwritten outside of invocations
                  of yyparse().
        </member>
    <member name="M:Mono.CSharp.CSharpParser.yyerror(System.String)">
            simplified error message.
                  @see <a href="#yyerror(java.lang.String, java.lang.String[])">yyerror</a></member>
    <member name="M:Mono.CSharp.CSharpParser.yyerror(System.String,System.String[])">
            (syntax) error message.
                  Can be overwritten to control message format.
                  @param message text to be displayed.
                  @param expected vector of acceptable tokens, if available.
        </member>
    <member name="M:Mono.CSharp.CSharpParser.yyExpectingTokens(System.Int32)">
            computes list of expected tokens on error by tracing the tables.
                  @param state for which to compute the list.
                  @return list of token names.
        </member>
    <member name="M:Mono.CSharp.CSharpParser.yyparse(Mono.CSharp.yyParser.yyInput,System.Object)">
            the generated parser, with debugging messages.
                  Maintains a state and a value stack, currently with fixed maximum size.
                  @param yyLex scanner.
                  @param yydebug debug message writer implementing yyDebug, or null.
                  @return result of the last reduction, if any.
                  @throws yyException on irrecoverable parse error.
        </member>
    <member name="M:Mono.CSharp.CSharpParser.yyDefault(System.Object)">
            executed at the beginning of a reduce action.
                  Used as $$ = yyDefault($1), prior to the user-specified action, if any.
                  Can be overwritten to provide deep copy, etc.
                  @param first value for $1, or null.
                  @return first.
        </member>
    <member name="M:Mono.CSharp.CSharpParser.yyparse(Mono.CSharp.yyParser.yyInput)">
            the generated parser.
                  Maintains a state and a value stack, currently with fixed maximum size.
                  @param yyLex scanner.
                  @return result of the last reduction, if any.
                  @throws yyException on irrecoverable parse error.
        </member>
    <member name="T:Mono.CSharp.yyParser.yyException">
            thrown for irrecoverable syntax errors and stack overflow.
        </member>
    <member name="T:Mono.CSharp.yyParser.yyInput">
            must be implemented by a scanner object to supply input to the parser.
        </member>
    <member name="M:Mono.CSharp.yyParser.yyInput.advance">
            move on to next token.
                    @return false if positioned beyond tokens.
                    @throws IOException on input error.
        </member>
    <member name="M:Mono.CSharp.yyParser.yyInput.token">
            classifies current token.
                    Should not be called if advance() returned false.
                    @return current %token or single character.
        </member>
    <member name="M:Mono.CSharp.yyParser.yyInput.value">
            associated with current token.
                    Should not be called if advance() returned false.
                    @return value for token().
        </member>
    <member name="T:Mono.CSharp.Tokenizer">
      <summary>
               Tokenizer for C# source code. 
            </summary>
    </member>
    <member name="M:Mono.CSharp.Tokenizer.ParsePragmaDirective(System.String)">
      <summary>
            Handles #pragma directive
            </summary>
    </member>
    <member name="M:Mono.CSharp.OverloadResolver.BetterFunction(Mono.CSharp.ResolveContext,Mono.CSharp.Arguments,Mono.CSharp.MemberSpec,Mono.CSharp.AParametersCollection,System.Boolean,Mono.CSharp.MemberSpec,Mono.CSharp.AParametersCollection,System.Boolean)">
      <summary>
              Determines "Better function" between candidate
              and the current best match
            </summary>
      <remarks>
               Returns a boolean indicating :
                false if candidate ain't better
                true  if candidate is better than the current best match
            </remarks>
    </member>
    <member name="T:Mono.CSharp.Driver">
      <summary>
               The compiler driver.
            </summary>
    </member>
    <member name="T:Mono.CSharp.FullNamedExpression">
      <summary>
              Represents a namespace or a type.  The name of the class was inspired by
              section 10.8.1 (Fully Qualified Names).
            </summary>
    </member>
    <member name="T:Mono.CSharp.TypeExpr">
      <summary>
              Expression that evaluates to a type
            </summary>
    </member>
    <member name="T:Mono.CSharp.EnumConstant">
      <summary>
             This class is used to wrap literals which belong inside Enums
            </summary>
    </member>
    <member name="T:Mono.CSharp.ExprClass">
      <remarks>
              The ExprClass class contains the is used to pass the 
              classification of an expression (value, variable, namespace,
              type, method group, property access, event access, indexer access,
              nothing).
            </remarks>
    </member>
    <member name="T:Mono.CSharp.ResolveFlags">
      <remarks>
              This is used to tell Resolve in which types of expressions we're
              interested.
            </remarks>
    </member>
    <member name="T:Mono.CSharp.TypeCast">
      <summary>
               This kind of cast is used to encapsulate the child
               whose type is child.Type into an expression that is
               reported to return "return_type".  This is used to encapsulate
               expressions which have compatible types, but need to be dealt
               at higher levels with.
            
               For example, a "byte" expression could be encapsulated in one
               of these as an "unsigned int".  The type for the expression
               would be "unsigned int".
            
             </summary>
    </member>
    <member name="T:Mono.CSharp.BoxedCast">
      <summary>
               This kind of cast is used to encapsulate Value Types in objects.
            
               The effect of it is to box the value type emitted by the previous
               operation.
             </summary>
    </member>
    <member name="T:Mono.CSharp.ConvCast">
      <summary>
               This is used to perform explicit numeric conversions.
            
               Explicit numeric conversions might trigger exceptions in a checked
               context, so they should generate the conv.ovf opcodes instead of
               conv opcodes.
             </summary>
    </member>
    <member name="T:Mono.CSharp.ClassCast">
      <summary>
              This kind of cast is used to encapsulate a child and cast it
              to the class requested
            </summary>
    </member>
    <member name="T:Mono.CSharp.SimpleName">
      <summary>
              SimpleName expressions are formed of a single word and only happen at the beginning 
              of a dotted-name.
            </summary>
    </member>
    <member name="T:Mono.CSharp.TypeExpression">
      <summary>
              Fully resolved Expression that already evaluated to a type
            </summary>
    </member>
    <member name="T:Mono.CSharp.MemberExpr">
      <summary>
              This class denotes an expression which evaluates to a member
              of a struct or a class.
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberExpr.Name">
      <summary>
              The name of this member.
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberExpr.IsInstance">
      <summary>
              Whether this is an instance member.
            </summary>
    </member>
    <member name="P:Mono.CSharp.MemberExpr.IsStatic">
      <summary>
              Whether this is a static member.
            </summary>
    </member>
    <member name="T:Mono.CSharp.MethodGroupExpr">
      <summary>
              MethodGroupExpr represents a group of method candidates which
              can be resolved to the best method overload
            </summary>
    </member>
    <member name="M:Mono.CSharp.MethodGroupExpr.OverloadResolve(Mono.CSharp.ResolveContext,Mono.CSharp.Arguments@,Mono.CSharp.OverloadResolver.IErrorHandler,Mono.CSharp.OverloadResolver.Restrictions)">
      <summary>
               Find the Applicable Function Members (7.4.2.1)
            
               me: Method Group expression with the members to select.
                   it might contain constructors or methods (or anything
                   that maps to a method).
            
               Arguments: ArrayList containing resolved Argument objects.
            
               loc: The location if we want an error to be reported, or a Null
                    location for "probing" purposes.
            
               Returns: The MethodBase (either a ConstructorInfo or a MethodInfo)
                        that is the best match of me on Arguments.
            
             </summary>
    </member>
    <member name="T:Mono.CSharp.FieldExpr">
      <summary>
              Fully resolved expression that evaluates to a Field
            </summary>
    </member>
    <member name="T:Mono.CSharp.PropertyExpr">
      <summary>
               Expression that evaluates to a Property.  The Assign class
               might set the `Value' expression if we are in an assignment.
            
               This is not an LValue because we need to re-write the expression, we
               can not take data from the stack and store it.  
             </summary>
    </member>
    <member name="T:Mono.CSharp.EventExpr">
      <summary>
              Fully resolved expression that evaluates to an Event
            </summary>
    </member>
    <member name="T:Mono.CSharp.VarExpr">
            
            Handles `var' contextual keyword; var becomes a keyword only
            if no type called var exists in a variable scope
            
        </member>
    <member name="T:Mono.CSharp.Enum">
      <summary>
              Enumeration container
            </summary>
    </member>
    <member name="T:Mono.CSharp.Evaluator">
      <summary>
               Evaluator: provides an API to evaluate C# statements and
               expressions dynamically.
             </summary>
      <remarks>
               This class exposes static methods to evaluate expressions in the
               current program.
            
               To initialize the evaluator with a number of compiler
               options call the Init(string[]args) method with a set of
               command line options that the compiler recognizes.
            
               To interrupt execution of a statement, you can invoke the
               Evaluator.Interrupt method.
             </remarks>
    </member>
    <member name="T:Mono.CSharp.Evaluator.QuitValue">
      <summary>
              A sentinel value used to indicate that no value was
              was set by the compiled function.   This is used to
              differentiate between a function not returning a
              value and null.
            </summary>
    </member>
    <member name="F:Mono.CSharp.Evaluator.DescribeTypeExpressions">
      <summary>
              If true, turns type expressions into valid expressions
              and calls the describe method on it
            </summary>
    </member>
    <member name="M:Mono.CSharp.Evaluator.Interrupt">
      <summary>
              Interrupts the evaluation of an expression executing in Evaluate.
            </summary>
      <remarks>
              Use this method to interrupt long-running invocations.
            </remarks>
    </member>
    <member name="M:Mono.CSharp.Evaluator.Compile(System.String,Mono.CSharp.CompiledMethod@)">
      <summary>
               Compiles the input string and returns a delegate that represents the compiled code.
             </summary>
      <remarks>
            
               Compiles the input string as a C# expression or
               statement, unlike the Evaluate method, the
               resulting delegate can be invoked multiple times
               without incurring in the compilation overhead.
            
               If the return value of this function is null,
               this indicates that the parsing was complete.
               If the return value is a string it indicates
               that the input string was partial and that the
               invoking code should provide more code before
               the code can be successfully compiled.
            
               If you know that you will always get full expressions or
               statements and do not care about partial input, you can use
               the other Compile overload. 
            
               On success, in addition to returning null, the
               compiled parameter will be set to the delegate
               that can be invoked to execute the code.
            
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Evaluator.Compile(System.String)">
      <summary>
               Compiles the input string and returns a delegate that represents the compiled code.
             </summary>
      <remarks>
            
               Compiles the input string as a C# expression or
               statement, unlike the Evaluate method, the
               resulting delegate can be invoked multiple times
               without incurring in the compilation overhead.
            
               This method can only deal with fully formed input
               strings and does not provide a completion mechanism.
               If you must deal with partial input (for example for
               interactive use) use the other overload. 
            
               On success, a delegate is returned that can be used
               to invoke the method.
            
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Evaluator.Evaluate(System.String,System.Object@,System.Boolean@)">
      <summary>
               Evaluates and expression or statement and returns any result values.
             </summary>
      <remarks>
               Evaluates the input string as a C# expression or
               statement.  If the input string is an expression
               the result will be stored in the result variable
               and the result_set variable will be set to true.
            
               It is necessary to use the result/result_set
               pair to identify when a result was set (for
               example, execution of user-provided input can be
               an expression, a statement or others, and
               result_set would only be set if the input was an
               expression.
            
               If the return value of this function is null,
               this indicates that the parsing was complete.
               If the return value is a string, it indicates
               that the input is partial and that the user
               should provide an updated string.
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Evaluator.Run(System.String)">
      <summary>
              Executes the given expression or statement.
            </summary>
      <remarks>
               Executes the provided statement, returns true
               on success, false on parsing errors.  Exceptions
               might be thrown by the called code.
            </remarks>
    </member>
    <member name="M:Mono.CSharp.Evaluator.Evaluate(System.String)">
      <summary>
               Evaluates and expression or statement and returns the result.
             </summary>
      <remarks>
               Evaluates the input string as a C# expression or
               statement and returns the value.   
            
               This method will throw an exception if there is a syntax error,
               of if the provided input is not an expression but a statement.
             </remarks>
    </member>
    <member name="M:Mono.CSharp.Evaluator.LoadAssembly(System.String)">
      <summary>
               Loads the given assembly and exposes the API to the user.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Evaluator.ReferenceAssembly(System.Reflection.Assembly)">
      <summary>
               Exposes the API of the given assembly to the Evaluator
            </summary>
    </member>
    <member name="P:Mono.CSharp.Evaluator.InteractiveBaseClass">
      <summary>
               The base class for the classes that host the user generated code
             </summary>
      <remarks>
            
               This is the base class that will host the code
               executed by the Evaluator.  By default
               this is the Mono.CSharp.InteractiveBase class
               which is useful for interactive use.
            
               By changing this property you can control the
               base class and the static members that are
               available to your evaluated code.
             </remarks>
    </member>
    <member name="T:Mono.CSharp.CompiledMethod">
      <summary>
              A delegate that can be used to invoke the
              compiled expression or statement.
            </summary>
      <remarks>
              Since the Compile methods will compile
              statements and expressions into the same
              delegate, you can tell if a value was returned
              by checking whether the returned value is of type
              NoValueSet.   
            </remarks>
    </member>
    <member name="T:Mono.CSharp.InteractiveBase">
      <summary>
              The default base class for every interaction line
            </summary>
      <remarks>
              The expressions and statements behave as if they were
              a static method of this class.   The InteractiveBase class
              contains a number of useful methods, but can be overwritten
              by setting the InteractiveBaseType property in the Evaluator
            </remarks>
    </member>
    <member name="F:Mono.CSharp.InteractiveBase.Output">
      <summary>
              Determines where the standard output of methods in this class will go. 
            </summary>
    </member>
    <member name="F:Mono.CSharp.InteractiveBase.Error">
      <summary>
              Determines where the standard error of methods in this class will go. 
            </summary>
    </member>
    <member name="F:Mono.CSharp.InteractiveBase.Prompt">
      <summary>
              The primary prompt used for interactive use.
            </summary>
    </member>
    <member name="F:Mono.CSharp.InteractiveBase.ContinuationPrompt">
      <summary>
              The secondary prompt used for interactive use (used when
              an expression is incomplete).
            </summary>
    </member>
    <member name="F:Mono.CSharp.InteractiveBase.QuitRequested">
      <summary>
              Used to signal that the user has invoked the  `quit' statement.
            </summary>
    </member>
    <member name="M:Mono.CSharp.InteractiveBase.ShowVars">
      <summary>
              Shows all the variables defined so far.
            </summary>
    </member>
    <member name="M:Mono.CSharp.InteractiveBase.ShowUsing">
      <summary>
              Displays the using statements in effect at this point. 
            </summary>
    </member>
    <member name="M:Mono.CSharp.InteractiveBase.Time(System.Action)">
      <summary>
              Times the execution of the given delegate
            </summary>
    </member>
    <member name="M:Mono.CSharp.InteractiveBase.LoadPackage(System.String)">
      <summary>
              Loads the assemblies from a package
            </summary>
      <remarks>
              Loads the assemblies from a package.   This is equivalent
              to passing the -pkg: command line flag to the C# compiler
              on the command line. 
            </remarks>
    </member>
    <member name="M:Mono.CSharp.InteractiveBase.LoadAssembly(System.String)">
      <summary>
              Loads the assembly
            </summary>
      <remarks>
              Loads the specified assembly and makes its types
              available to the evaluator.  This is equivalent
              to passing the -pkg: command line flag to the C#
              compiler on the command line.
            </remarks>
    </member>
    <member name="M:Mono.CSharp.InteractiveBase.Describe(System.Object)">
      <summary>
              Describes an object or a type.
            </summary>
      <remarks>
              This method will show a textual representation
              of the object's type.  If the object is a
              System.Type it renders the type directly,
              otherwise it renders the type returned by
              invoking GetType on the object.
            </remarks>
    </member>
    <member name="P:Mono.CSharp.InteractiveBase.help">
      <summary>
              Returns a list of available static methods. 
            </summary>
    </member>
    <member name="P:Mono.CSharp.InteractiveBase.quit">
      <summary>
              Indicates to the read-eval-print-loop that the interaction should be finished. 
            </summary>
    </member>
    <member name="T:Mono.CSharp.OptionalAssign">
      <summary>
                A class used to assign values if the source expression is not void
            
                Used by the interactive shell to allow it to call this code to set
                the return value for an invocation.
             </summary>
    </member>
    <member name="T:Mono.CSharp.UnaryMutator">
      <summary>
               Unary Mutator expressions (pre and post ++ and --)
             </summary>
      <remarks>
               UnaryMutator implements ++ and -- expressions.   It derives from
               ExpressionStatement becuase the pre/post increment/decrement
               operators can be used in a statement context.
            
             FIXME: Idea, we could split this up in two classes, one simpler
             for the common case, and one with the extra fields for more complex
             classes (indexers require temporary access;  overloaded require method)
            
             </remarks>
    </member>
    <member name="T:Mono.CSharp.Probe">
      <summary>
               Base class for the `Is' and `As' classes. 
             </summary>
      <remarks>
               FIXME: Split this in two, and we get to save the `Operator' Oper
               size. 
             </remarks>
    </member>
    <member name="T:Mono.CSharp.Is">
      <summary>
              Implementation of the `is' operator.
            </summary>
    </member>
    <member name="T:Mono.CSharp.As">
      <summary>
              Implementation of the `as' operator.
            </summary>
    </member>
    <member name="T:Mono.CSharp.Binary">
      <summary>
              Binary operators
            </summary>
    </member>
    <member name="M:Mono.CSharp.Binary.OperName(Mono.CSharp.Binary.Operator)">
      <summary>
              Returns a stringified representation of the Operator
            </summary>
    </member>
    <member name="M:Mono.CSharp.Binary.EmitBranchable(Mono.CSharp.EmitContext,System.Reflection.Emit.Label,System.Boolean)">
      <remarks>
               EmitBranchable is called from Statement.EmitBoolExpression in the
               context of a conditional bool expression.  This function will return
               false if it is was possible to use EmitBranchable, or true if it was.
            
               The expression's code is generated, and we will generate a branch to `target'
               if the resulting expression value is equal to isTrue
             </remarks>
    </member>
    <member name="T:Mono.CSharp.Conditional">
      <summary>
              Implements the ternary conditional operator (?:)
            </summary>
    </member>
    <member name="T:Mono.CSharp.ParameterReference">
      <summary>
              This represents a reference to a parameter in the intermediate
              representation.
            </summary>
    </member>
    <member name="T:Mono.CSharp.Invocation">
      <summary>
              Invocation of methods or delegates.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Invocation.EmitCall(Mono.CSharp.EmitContext,Mono.CSharp.Expression,Mono.CSharp.MethodSpec,Mono.CSharp.Arguments,Mono.CSharp.Location)">
      <remarks>
               is_base tells whether we want to force the use of the `call'
               opcode instead of using callvirt.  Call is required to call
               a specific method, while callvirt will always use the most
               recent method in the vtable.
            
               is_static tells whether this is an invocation on a static method
            
               instance_expr is an expression that represents the instance
               it must be non-null if is_static is false.
            
               method is the method to invoke.
            
               Arguments is the list of arguments to pass to the method or constructor.
             </remarks>
    </member>
    <member name="M:Mono.CSharp.New.Constantify(Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
            Converts complex core type syntax like 'new int ()' to simple constant
            </summary>
    </member>
    <member name="T:Mono.CSharp.ArrayCreation">
      <summary>
               14.5.10.2: Represents an array creation expression.
             </summary>
      <remarks>
               There are two possible scenarios here: one is an array creation
               expression that specifies the dimensions and optionally the
               initialization data and the other which does not need dimensions
               specified but where initialization data is mandatory.
             </remarks>
    </member>
    <member name="T:Mono.CSharp.This">
      <summary>
              Represents the `this' construct
            </summary>
    </member>
    <member name="T:Mono.CSharp.ArglistAccess">
      <summary>
              Represents the `__arglist' construct
            </summary>
    </member>
    <member name="T:Mono.CSharp.Arglist">
      <summary>
              Represents the `__arglist (....)' construct
            </summary>
    </member>
    <member name="T:Mono.CSharp.TypeOf">
      <summary>
              Implements the typeof operator
            </summary>
    </member>
    <member name="T:Mono.CSharp.SizeOf">
      <summary>
              Implements the sizeof expression
            </summary>
    </member>
    <member name="T:Mono.CSharp.MemberAccess">
      <summary>
              Implements the member access expression
            </summary>
    </member>
    <member name="T:Mono.CSharp.QualifiedAliasMember">
      <summary>
              Implements the qualified-alias-member (::) expression.
            </summary>
    </member>
    <member name="T:Mono.CSharp.CheckedExpr">
      <summary>
              Implements checked expressions
            </summary>
    </member>
    <member name="T:Mono.CSharp.UnCheckedExpr">
      <summary>
              Implements the unchecked expression
            </summary>
    </member>
    <member name="T:Mono.CSharp.ElementAccess">
      <summary>
               An Element Access expression.
            
               During semantic analysis these are transformed into 
               IndexerAccess, ArrayAccess or a PointerArithmetic.
             </summary>
    </member>
    <member name="T:Mono.CSharp.ArrayAccess">
      <summary>
              Implements array access 
            </summary>
    </member>
    <member name="T:Mono.CSharp.EmptyExpression">
      <summary>
               This class exists solely to pass the Type around and to be a dummy
               that can be passed to the conversion functions (this is used by
               foreach implementation to typecast the object return value from
               get_Current into the proper type.  All code has been generated and
               we only care about the side effect conversions to be performed
            
               This is also now used as a placeholder where a no-action expression
               is needed (the `New' class).
             </summary>
    </member>
    <member name="T:Mono.CSharp.FixedField">
      <summary>
            Fixed buffer implementation
            </summary>
    </member>
    <member name="T:Mono.CSharp.TypeParameterExpr">
      <summary>
              A TypeExpr which already resolved to a type parameter.
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeArguments.Resolve(Mono.CSharp.IMemberContext)">
      <summary>
              Resolve the type arguments.
            </summary>
    </member>
    <member name="P:Mono.CSharp.TypeArguments.Arguments">
      <summary>
              We may only be used after Resolve() is called and return the fully
              resolved types.
            </summary>
    </member>
    <member name="M:Mono.CSharp.GenericTypeExpr.#ctor(Mono.CSharp.TypeSpec,Mono.CSharp.TypeArguments,Mono.CSharp.Location)">
      <summary>
              Instantiate the generic type `t' with the type arguments `args'.
              Use this constructor if you already know the fully resolved
              generic type.
            </summary>
    </member>
    <member name="T:Mono.CSharp.GenericMethod">
      <summary>
              A generic method definition.
            </summary>
    </member>
    <member name="M:Mono.CSharp.GenericMethod.Define(Mono.CSharp.MethodOrOperator)">
      <summary>
              Define and resolve the type parameters.
              We're called from Method.Define().
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeManager.CSharpName(Mono.CSharp.TypeSpec)">
      <summary>
              Returns the C# name of a type if possible, or the full type name otherwise
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeManager.HasElementType(Mono.CSharp.TypeSpec)">
      <summary>
            This method is not implemented by MS runtime for dynamic types
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeManager.VerifyUnmanaged(Mono.CSharp.ModuleContainer,Mono.CSharp.TypeSpec,Mono.CSharp.Location)">
      <summary>
              Utility function that can be used to probe whether a type
              is managed or not.  
            </summary>
    </member>
    <member name="M:Mono.CSharp.TypeManager.IsInstantiationOfSameGenericType(Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
      <summary>
              Check whether `type' and `parent' are both instantiations of the same
              generic type.  Note that we do not check the type parameters here.
            </summary>
    </member>
    <member name="T:Mono.CSharp.Return">
      <summary>
              Implements the return statement
            </summary>
    </member>
    <member name="T:Mono.CSharp.Block">
      <summary>
               Block represents a C# block.
             </summary>
      <remarks>
               This class is used in a number of places: either to represent
               explicit blocks that the programmer places or implicit blocks.
            
               Implicit blocks are used as labels or to introduce variable
               declarations.
            
               Top-level blocks derive from Block, and they are called ToplevelBlock
               they contain extra information that is not necessary on normal blocks.
             </remarks>
    </member>
    <member name="T:Mono.CSharp.ParameterBase">
      <summary>
              Abstract Base class for parameters of a method.
            </summary>
    </member>
    <member name="T:Mono.CSharp.SourceFile">
      <summary>
              This is one single source file.
            </summary>
      <remarks>
              This is intentionally a class and not a struct since we need
              to pass this by reference.
            </remarks>
    </member>
    <member name="T:Mono.CSharp.Location">
      <summary>
               Keeps track of the location in the program
             </summary>
      <remarks>
               This uses a compact representation and a couple of auxiliary
               structures to keep track of tokens to (file,line and column) 
               mappings. The usage of the bits is:
               
                 - 16 bits for "checkpoint" which is a mixed concept of
                   file and "line segment"
                 - 8 bits for line delta (offset) from the line segment
                 - 8 bits for column number.
            
               http://lists.ximian.com/pipermail/mono-devel-list/2004-December/009508.html
             </remarks>
    </member>
    <member name="P:Mono.CSharp.Location.IsNull">
      <summary>
              Whether the Location is Null
            </summary>
    </member>
    <member name="M:Mono.CSharp.MethodData.DefineMethodBuilder(Mono.CSharp.TypeContainer,System.String,Mono.CSharp.ParametersCompiled)">
      <summary>
            Create the MethodBuilder for the method 
            </summary>
    </member>
    <member name="M:Mono.CSharp.Namespace.#ctor(Mono.CSharp.Namespace,System.String)">
      <summary>
              Constructor Takes the current namespace and the
              name.  This is bootstrapped with parent == null
              and name = ""
            </summary>
    </member>
    <member name="M:Mono.CSharp.Namespace.LookupExtensionMethod(Mono.CSharp.IMemberContext,Mono.CSharp.TypeSpec,System.String,System.Int32)">
            
            Looks for extension method in this namespace
            
        </member>
    <member name="P:Mono.CSharp.Namespace.Name">
      <summary>
              The qualified name of the current namespace
            </summary>
    </member>
    <member name="P:Mono.CSharp.Namespace.Parent">
      <summary>
              The parent of this namespace, used by the parser to "Pop"
              the current namespace declaration
            </summary>
    </member>
    <member name="M:Mono.CSharp.NamespaceContainer.AddUsing(Mono.CSharp.MemberName,Mono.CSharp.Location)">
      <summary>
              Records a new namespace for resolving name references
            </summary>
    </member>
    <member name="M:Mono.CSharp.NamespaceContainer.Resolve">
      <summary>
              Used to validate that all the using clauses are correct
              after we are finished parsing all the files.  
            </summary>
    </member>
    <member name="T:Mono.CSharp.ReturnParameter">
      <summary>
            Class for applying custom attributes on the return type
            </summary>
    </member>
    <member name="P:Mono.CSharp.ReturnParameter.ValidAttributeTargets">
      <summary>
            Is never called
            </summary>
    </member>
    <member name="T:Mono.CSharp.ParametersCompiled">
      <summary>
              Represents the methods parameters
            </summary>
    </member>
    <member name="F:Mono.CSharp.PendingImplementation.container">
      <summary>
              The container for this PendingImplementation
            </summary>
    </member>
    <member name="F:Mono.CSharp.PendingImplementation.pending_implementations">
      <summary>
              This is the array of TypeAndMethods that describes the pending implementations
              (both interfaces and abstract methods in base class)
            </summary>
    </member>
    <member name="M:Mono.CSharp.PendingImplementation.IsInterfaceMethod(Mono.CSharp.MemberName,Mono.CSharp.TypeSpec,Mono.CSharp.MethodData)">
      <summary>
              Whether the specified method is an interface method implementation
            </summary>
    </member>
    <member name="M:Mono.CSharp.PendingImplementation.InterfaceMethod(Mono.CSharp.MemberName,Mono.CSharp.TypeSpec,Mono.CSharp.MethodData,Mono.CSharp.PendingImplementation.Operation)">
      <remarks>
               If a method in Type `t' (or null to look in all interfaces
               and the base abstract class) with name `Name', return type `ret_type' and
               arguments `args' implements an interface, this method will
               return the MethodInfo that this method implements.
            
               If `name' is null, we operate solely on the method's signature.  This is for
               instance used when implementing indexers.
            
               The `Operation op' controls whether to lookup, clear the pending bit, or clear
               all the methods with the given signature.
            
               The `MethodInfo need_proxy' is used when we're implementing an interface's
               indexer in a class.  If the new indexer's IndexerName does not match the one
               that was used in the interface, then we always need to create a proxy for it.
            
             </remarks>
    </member>
    <member name="M:Mono.CSharp.PendingImplementation.DefineProxy(Mono.CSharp.TypeSpec,Mono.CSharp.MethodSpec,Mono.CSharp.MethodSpec)">
      <summary>
               C# allows this kind of scenarios:
               interface I { void M (); }
               class X { public void M (); }
               class Y : X, I { }
            
               For that case, we create an explicit implementation function
               I.M in Y.
             </summary>
    </member>
    <member name="M:Mono.CSharp.PendingImplementation.BaseImplements(Mono.CSharp.TypeSpec,Mono.CSharp.MethodSpec,Mono.CSharp.MethodSpec@)">
      <summary>
              This function tells whether one of our base classes implements
              the given method (which turns out, it is valid to have an interface
              implementation in a base
            </summary>
    </member>
    <member name="M:Mono.CSharp.PendingImplementation.VerifyPendingMethods(Mono.CSharp.Report)">
      <summary>
              Verifies that any pending abstract methods or interface methods
              were implemented.
            </summary>
    </member>
    <member name="T:Mono.CSharp.EventProperty">
      <summary>
            For case when event is declared like property (with add and remove accessors).
            </summary>
    </member>
    <member name="T:Mono.CSharp.EventField">
      <summary>
            Event is declared like field.
            </summary>
    </member>
    <member name="F:Mono.CSharp.Report.WarningsAreErrors">
      <summary>  
              Whether warnings should be considered errors
            </summary>
    </member>
    <member name="F:Mono.CSharp.Report.extra_information">
      <summary>
            List of symbols related to reported error/warning. You have to fill it before error/warning is reported.
            </summary>
    </member>
    <member name="M:Mono.CSharp.Report.SymbolRelatedToPreviousError(Mono.CSharp.Location,System.String)">
      <summary>
            In most error cases is very useful to have information about symbol that caused the error.
            Call this method before you call Report.Error when it makes sense.
            </summary>
    </member>
    <member name="T:Mono.CSharp.WarningRegions">
      <summary>
            Handles #pragma warning
            </summary>
    </member>
    <member name="T:Mono.CSharp.GotoDefault">
      <summary>
              `goto default' statement
            </summary>
    </member>
    <member name="T:Mono.CSharp.GotoCase">
      <summary>
              `goto case' statement
            </summary>
    </member>
    <member name="F:Mono.CSharp.Switch.SwitchType">
      <summary>
              The governing switch type
            </summary>
    </member>
    <member name="T:Mono.CSharp.Foreach">
      <summary>
              Implementation of the foreach C# statement
            </summary>
    </member>
    <member name="T:Mono.CSharp.SeekableStreamReader">
      <summary>
               This is an arbitrarily seekable StreamReader wrapper.
            
               It uses a self-tuning buffer to cache the seekable data,
               but if the seek is too far, it may read the underly
               stream all over from the beginning.
             </summary>
    </member>
    <member name="P:Mono.CSharp.SeekableStreamReader.Position">
      <remarks>
              This value corresponds to the current position in a stream of characters.
              The StreamReader hides its manipulation of the underlying byte stream and all
              character set/decoding issues.  Thus, we cannot use this position to guess at
              the corresponding position in the underlying byte stream even though there is
              a correlation between them.
            </remarks>
    </member>
    <member name="T:Mono.CSharp.CompletionResult">
      <summary>
              An exception used to terminate the compiler resolution phase and provide completions
            </summary>
      <remarks>
              This is thrown when we want to return the completions or
              terminate the completion process by AST nodes used in
              the completion process.
            </remarks>
    </member>
    <member name="M:Mono.CSharp.TypeSpecComparer.Unify.MayBecomeEqualGenericTypes(Mono.CSharp.TypeSpec,Mono.CSharp.TypeSpec)">
      <summary>
              Check whether `a' and `b' may become equal generic types.
              The algorithm to do that is a little bit complicated.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IFreezable.Freeze">
      <summary>
            Freezes this instance.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IFreezable.IsFrozen">
      <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.Freeze">
      <summary>
            Freezes this instance.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.IsFrozen">
      <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.ParsedFile">
      <summary>
            Represents a file that was parsed and converted for the type system.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor">
      <summary>
            Produces type and member definitions from the DOM.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor.#ctor(ICSharpCode.NRefactory.TypeSystem.IProjectContent,System.String)">
      <summary>
            Creates a new TypeSystemConvertVisitor.
            </summary>
      <param name="pc">The parent project content (used as owner for the types being created).</param>
      <param name="fileName">The file name (used for DomRegions).</param>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor.#ctor(ICSharpCode.NRefactory.CSharp.ParsedFile,ICSharpCode.NRefactory.CSharp.Resolver.UsingScope,ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition)">
      <summary>
            Creates a new TypeSystemConvertVisitor and initializes it with a given context.
            </summary>
      <param name="parsedFile">The parsed file to which members should be added.</param>
      <param name="currentUsingScope">The current using scope.</param>
      <param name="currentTypeDefinition">The current type definition.</param>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor.AddDefaultMethodsToDelegate(ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IParameter})">
      <summary>
            Adds the 'Invoke', 'BeginInvoke', 'EndInvoke' methods, and a constructor, to the <paramref name="delegateType" />.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeReference">
      <summary>
            Represents a reference to a type.
            Must be resolved before it can be used as type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Resolves this type reference.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ITypeOrNamespaceReference">
      <summary>
            Represents a reference which could point to a type or namespace.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ITypeOrNamespaceReference.DoResolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Resolves the reference and returns the ResolveResult.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ITypeOrNamespaceReference.ResolveNamespace(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Returns the namespace that is referenced; or null if no such namespace is found.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.AliasNamespaceReference">
      <summary>
            Looks up an alias (identifier in front of :: operator).
            </summary>
      <remarks>
            The member lookup performed by the :: operator is handled
            by <see cref="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberTypeOrNamespaceReference" />.
            </remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult">
      <summary>
            Represents the result of resolving an expression.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.TypeResolveResult">
      <summary>
            The resolved expression refers to a type name.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.AmbiguousTypeResolveResult">
      <summary>
            Represents an ambiguous type resolve result.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberResolveResult">
      <summary>
            Represents the result of a member invocation.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ByReferenceResolveResult">
      <summary>
            Represents the resolve result of an 'ref x' or 'out x' expression.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ConstantResolveResult">
      <summary>
            ResolveResult representing a compile-time constant.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IConversions">
      <summary>
            Interface used to check whether types are convertible.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.Conversions">
      <summary>
            Contains logic that determines whether an implicit conversion exists between two types.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.IdentityConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets whether there is an identity conversion from <paramref name="fromType" /> to <paramref name="toType" /></summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.BetterConversion(ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets the better conversion (C# 4.0 spec, 7.5.3.3)
            </summary>
      <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.BetterConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets the better conversion (C# 4.0 spec, 7.5.3.4)
            </summary>
      <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.Conversions.BetterConversionTarget(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets the better conversion target (C# 4.0 spec, 7.5.3.5)
            </summary>
      <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeVisitor">
      <summary>
            Base class for the visitor pattern on <see cref="T:ICSharpCode.NRefactory.TypeSystem.IType" />.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver">
      <summary>
            Contains the main resolver logic.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.PushBlock">
      <summary>
            Opens a new scope for local variables.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.PopBlock">
      <summary>
            Closes the current scope for local variables; removing all variables in that scope.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.AddVariable(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,ICSharpCode.NRefactory.TypeSystem.IConstantValue)">
      <summary>
            Adds a new variable to the current block.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.Clone">
      <summary>
            Creates a copy of this CSharp resolver.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.HandleEnumComparison(ICSharpCode.NRefactory.CSharp.BinaryOperatorType,ICSharpCode.NRefactory.TypeSystem.IType,System.Boolean,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult)">
      <summary>
            Handle the case where an enum value is compared with another enum value
            bool operator op(E x, E y);
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.HandleEnumSubtraction(System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult)">
      <summary>
            Handle the case where an enum value is subtracted from another enum value
            U operator (E x, E y);
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.HandleEnumAdditionOrSubtraction(System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.CSharp.BinaryOperatorType,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult,ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult)">
      <summary>
            Handle the case where an integral value is added to or subtracted from an enum value,
            or when two enum values of the same type are combined using a bitwise operator.
            E operator +(E x, U y);
            E operator (E x, U y);
            E operator &amp;(E x, E y);
            E operator |(E x, E y);
            E operator ^(E x, E y);
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveAlias(System.String)">
      <summary>
            Looks up an alias (identifier in front of :: operator)
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.GetExtensionMethods(ICSharpCode.NRefactory.TypeSystem.IType,System.String,System.Int32)">
      <summary>
            Gets the extension methods that are called 'name', and can be called with 'typeArgumentCount' explicit type arguments;
            and are applicable with a first argument type of 'targetType'.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveSizeOf(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Resolves 'sizeof(type)'.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveThisReference">
      <summary>
            Resolves 'this'.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.ResolveBaseReference">
      <summary>
            Resolves 'base'.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.Context">
      <summary>
            Gets the type resolve context used by the resolver.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.CheckForOverflow">
      <summary>
            Gets/Sets whether the current context is <c>checked</c>.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.CurrentMember">
      <summary>
            Gets/Sets the current member definition that is used to look up identifiers as parameters
            or type parameters.
            </summary>
      <remarks>Don't forget to also set CurrentTypeDefinition when setting CurrentMember;
            setting one of the properties does not automatically set the other.</remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.CurrentTypeDefinition">
      <summary>
            Gets/Sets the current type definition that is used to look up identifiers as simple members.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.UsingScope">
      <summary>
            Gets/Sets the current using scope that is used to look up identifiers as class names.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver.LocalVariables">
      <summary>
            Gets all currently visible local variables.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IVariable">
      <summary>
            Represents a variable (name/return type pair).
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Name">
      <summary>
            Gets the name of the variable.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Type">
      <summary>
            Gets the type of the variable.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.IsConst">
      <summary>
            Gets whether this field is a constant (C#-like const).
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.ConstantValue">
      <summary>
            If this field is a constant, retrieves the value.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.Immutable">
      <summary>
            Base class for immutable objects. Provides implementation for IFreezable that reports the
            object as always-frozen.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.FullName">
      <summary>
            Gets the fully qualified name of the class the return type is pointing to.
            </summary>
      <returns>
            "System.Int32[]" for int[]<br />
            "System.Collections.Generic.List" for List&lt;string&gt;
            "System.Environment.SpecialFolder" for Environment.SpecialFolder
            </returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Name">
      <summary>
            Gets the short name of the class the return type is pointing to.
            </summary>
      <returns>
            "Int32[]" for int[]<br />
            "List" for List&lt;string&gt;
            "SpecialFolder" for Environment.SpecialFolder
            </returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Namespace">
      <summary>
            Gets the namespace of the class the return type is pointing to.
            </summary>
      <returns>
            "System" for int[]<br />
            "System.Collections.Generic" for List&lt;string&gt;
            "System" for Environment.SpecialFolder
            </returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.ReflectionName">
      <summary>
            Gets the full reflection name of the element.
            </summary>
      <remarks>
            For types, the reflection name can be parsed back into a ITypeReference by using
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String,ICSharpCode.NRefactory.TypeSystem.IEntity)" />.
            </remarks>
      <returns>
            "System.Int32[]" for int[]<br />
            "System.Int32[][,]" for C# int[,][]<br />
            "System.Collections.Generic.List`1[[System.String]]" for List&lt;string&gt;
            "System.Environment+SpecialFolder" for Environment.SpecialFolder
            </returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Region">
      <summary>
            Gets the complete entity region (including header+body)
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.BodyRegion">
      <summary>
            Gets the entity body region.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition">
      <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Accessibility">
      <summary>
            Gets the accessibility of this entity.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsStatic">
      <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsAbstract">
      <summary>
            Returns whether this entity is abstract.
            </summary>
      <remarks>Static classes also count as abstract classes.</remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSealed">
      <summary>
            Returns whether this entity is sealed.
            </summary>
      <remarks>Static classes also count as sealed classes.</remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsShadowing">
      <summary>
            Gets whether this member is declared to be shadowing another member with the same name.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSynthetic">
      <summary>
            Gets whether this member is generated by a macro/compiler feature.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.ProjectContent">
      <summary>
            The assembly in which this entity is defined.
            This property never returns null.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IMember">
      <summary>
            Method/field/entity.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.DeclaringType">
      <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property never returns null -- for top-level members, it returns SharedTypes.UnknownType.
            If this is not a specialized member, the value returned is equal to <see cref="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition" />.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.MemberDefinition">
      <summary>
            Gets the original member definition for this member.
            Returns <c>this</c> if this is not a specialized member.
            Specialized members are the result of overload resolution with type substitution.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.ReturnType">
      <summary>
            Gets the return type of this member.
            This property never returns null.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.InterfaceImplementations">
      <summary>
            Gets the list of interfaces this member is implementing explicitly.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsVirtual">
      <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are already overriding a method.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsOverridable">
      <summary>
            Gets if the member can be overridden. Returns true when the member is "virtual" or "override" but not "sealed".
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IParameterizedMember">
      <summary>
            Represents a method or property.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution">
      <summary>
            C# overload resolution (C# 4.0 spec: 7.5).
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.ILiftedOperator">
      <summary>
            Implement this interface to give overload resolution a hint that the member represents a lifted operator,
            which is used in the tie-breaking rules.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.CalculateCandidate(ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate)">
      <summary>
            Calculates applicability etc. for the candidate.
            </summary>
      <returns>True if the calculation was successful, false if the candidate should be removed without reporting an error</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.BetterFunctionMember(ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate,ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolution.Candidate)">
      <summary>
            Returns 1 if c1 is better than c2; 2 if c2 is better than c1; or 0 if neither is better.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MethodTypeParameterSubstitution">
      <summary>
            Substitutes method type parameters with type arguments. Does not modify class type parameters.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ErrorResolveResult">
      <summary>
            Represents a resolve error.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator">
      <summary>
            Allows controlling which nodes are resolved by the resolve visitor.
            </summary>
      <seealso cref="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor" />
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode">
      <summary>
            Represents the operation mode of the resolve visitor.
            </summary>
      <seealso cref="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor" />
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.Scan">
      <summary>
            Scan into the children of the current node, without resolving the current node.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.Skip">
      <summary>
            Skip the current node - do not scan into it; do not resolve it.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.Resolve">
      <summary>
            Resolve the current node; but only scan subnodes which are not required for resolving the current node.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitorNavigationMode.ResolveAll">
      <summary>
            Resolves all nodes in the current subtree.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.LocalResolveResult">
      <summary>
            Represents a local variable.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup">
      <summary>
            Implementation of member lookup (C# 4.0 spec, 7.4).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup.IsInvocable(ICSharpCode.NRefactory.TypeSystem.IMember,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets whether the member is considered to be invocable.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup.IsAccessible(ICSharpCode.NRefactory.TypeSystem.IEntity,System.Boolean)">
      <summary>
            Gets whether <paramref name="entity" /> is accessible in the current class.
            </summary>
      <param name="entity">The entity to test</param>
      <param name="allowProtectedAccess">Whether protected access is allowed.
            True if the type of the reference is derived from the current class.</param>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.MemberLookup.Lookup(ICSharpCode.NRefactory.TypeSystem.IType,System.String,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean)">
      <summary>
            Performs a member lookup.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MemberTypeOrNamespaceReference">
      <summary>
            Reference to a qualified type or namespace name.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.MethodGroupResolveResult">
      <summary>
            Represents a group of methods.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.MethodGroupResolveResult.ExtensionMethods">
      <summary>
            List of extension methods, used to avoid re-calculating it in ResolveInvocation() when it was already
            calculated by ResolveMemberAccess().
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.NamespaceResolveResult">
      <summary>
            Represents that an expression resolved to a namespace.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.NodeListResolveVisitorNavigator">
      <summary>
        <see cref="T:ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator" /> implementation that resolves a list of nodes.
            We will skip all nodes which are not the target nodes or ancestors of the target nodes.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.NodeListResolveVisitorNavigator.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.AstNode})">
      <summary>
            Creates a new NodeListResolveVisitorNavigator that resolves the specified nodes.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.NodeListResolveVisitorNavigator.Scan(ICSharpCode.NRefactory.CSharp.AstNode)">
      <inheritdoc />
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.TooManyPositionalArguments">
      <summary>
            Too many positional arguments (some could not be mapped to any parameter).
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.NoParameterFoundForNamedArgument">
      <summary>
            A named argument could not be mapped to any parameter
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.TypeInferenceFailed">
      <summary>
            Type inference failed for a generic method.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.WrongNumberOfTypeArguments">
      <summary>
            Type arguments were explicitly specified, but did not match the number of type parameters.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.ConstructedTypeDoesNotSatisfyConstraint">
      <summary>
            After substituting type parameters with the inferred types; a constructed type within the formal parameters
            does not satisfy its constraint.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.MissingArgumentForRequiredParameter">
      <summary>
            No argument was mapped to a non-optional parameter
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.MultipleArgumentsForSingleParameter">
      <summary>
            Several arguments were mapped to a single (non-params-array) parameter
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.ParameterPassingModeMismatch">
      <summary>
            'ref'/'out' passing mode doesn't match for at least 1 parameter
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.ArgumentTypeMismatch">
      <summary>
            Argument type cannot be converted to parameter type
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.OverloadResolutionErrors.AmbiguousMatch">
      <summary>
            There is no unique best overload
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor">
      <summary>
            Traverses the DOM and resolves expressions.
            </summary>
      <remarks>
            The ResolveVisitor does two jobs at the same time: it tracks the resolve context (properties on CSharpResolver)
            and it resolves the expressions visited.
            To allow using the context tracking without having to resolve every expression in the file (e.g. when you want to resolve
            only a single node deep within the DOM), you can use the <see cref="T:ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator" /> interface.
            The navigator allows you to switch the between scanning mode and resolving mode.
            In scanning mode, the context is tracked (local variables registered etc.), but nodes are not resolved.
            While scanning, the navigator will get asked about every node that the resolve visitor is about to enter.
            This allows the navigator whether to keep scanning, whether switch to resolving mode, or whether to completely skip the
            subtree rooted at that node.
            
            In resolving mode, the context is tracked and nodes will be resolved.
            The resolve visitor may decide that it needs to resolve other nodes as well in order to resolve the current node.
            In this case, those nodes will be resolved automatically, without asking the navigator interface.
            For child nodes that are not essential to resolving, the resolve visitor will switch back to scanning mode (and thus will
            ask the navigator for further instructions).
            
            Moreover, there is the <c>ResolveAll</c> mode - it works similar to resolving mode, but will not switch back to scanning mode.
            The whole subtree will be resolved without notifying the navigator.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.#ctor(ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver,ICSharpCode.NRefactory.CSharp.ParsedFile,ICSharpCode.NRefactory.CSharp.Resolver.IResolveVisitorNavigator)">
      <summary>
            Creates a new ResolveVisitor instance.
            </summary>
      <param name="resolver">
            The CSharpResolver, describing the initial resolve context.
            If you visit a whole CompilationUnit with the resolve visitor, you can simply pass
            <c>new CSharpResolver(typeResolveContext)</c> without setting up the context.
            If you only visit a subtree, you need to pass a CSharpResolver initialized to the context for that subtree.
            </param>
      <param name="parsedFile">
            Result of the <see cref="T:ICSharpCode.NRefactory.CSharp.TypeSystemConvertVisitor" /> for the file being passed. This is used for setting up the context on the resolver.
            You may pass <c>null</c> if you are only visiting a part of a method body and have already set up the context in the <paramref name="resolver" />.
            </param>
      <param name="navigator">
            The navigator, which controls where the resolve visitor will switch between scanning mode and resolving mode.
            If you pass <c>null</c>, then <c>ResolveAll</c> mode will be used.
            </param>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.GetResolveResult(ICSharpCode.NRefactory.CSharp.AstNode)">
      <summary>
            Gets the cached resolve result for the specified node.
            Returns <c>null</c> if no cached result was found (e.g. if the node was not visited; or if it was visited in scanning mode).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.MakeTypeReference(ICSharpCode.NRefactory.CSharp.AstType,ICSharpCode.NRefactory.CSharp.AstNode,System.Boolean)">
      <summary>
            Creates a type reference for the specified type node.
            If the type node is 'var', performs type inference on the initializer expression.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.TypeResolveContext">
      <summary>
            Gets the TypeResolveContext used by this ResolveVisitor.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.ResolveVisitor.CancellationToken">
      <summary>
            Gets the CancellationToken used by this ResolveVisitor.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.SimpleTypeOrNamespaceReference">
      <summary>
            Represents a simple C# name. (a single non-qualified identifier with an optional list of type arguments)
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.TypeInferenceAlgorithm.CSharp4">
      <summary>
            C# 4.0 type inference.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.TypeInferenceAlgorithm.Improved">
      <summary>
            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.CSharp.Resolver.TypeInferenceAlgorithm.ImprovedReturnAllResults">
      <summary>
            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing;
            uses <see cref="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType" /> to report all results (in case of ambiguities).
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference">
      <summary>
            Implements C# 4.0 Type Inference (7.5.2).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.InferTypeArgumentsFromBounds(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.ITypeParameter},ICSharpCode.NRefactory.TypeSystem.IType,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean@)">
      <summary>
            Infers type arguments for the <paramref name="typeParameters" /> occurring in the <paramref name="targetType" />
            so that the resulting type (after substition) satisfies the given bounds.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.MakeExactInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Make exact inference from U to V.
            C# 4.0 spec: 7.5.2.8 Exact inferences
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.MakeLowerBoundInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Make lower bound inference from U to V.
            C# 4.0 spec: 7.5.2.9 Lower-bound inferences
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.MakeUpperBoundInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Make upper bound inference from U to V.
            C# 4.0 spec: 7.5.2.10 Upper-bound inferences
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.GetBestCommonType(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.CSharp.Resolver.ResolveResult},System.Boolean@)">
      <summary>
            Gets the best common type (C# 4.0 spec: 7.5.2.14) of a set of expressions.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.FindTypeInBounds(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
      <summary>
            Finds a type that satisfies the given lower and upper bounds.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.TypeInference.Algorithm">
      <summary>
            Gets/Sets the type inference algorithm used.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetDefinition">
      <summary>
            Gets the underlying type definition.
            Can return null for types which do not have a type definition (for example arrays, pointers, type parameters)
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.AcceptVisitor(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
      <summary>
            Calls ITypeVisitor.Visit for this type.
            </summary>
      <returns>The return value of the ITypeVisitor.Visit call</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.VisitChildren(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
      <summary>
            Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based
            on the return values of the visit calls.
            </summary>
      <returns>A copy of this type, with all children replaced by the return value of the corresponding visitor call.
            If the visitor returned the original types for all children (or if there are no children), returns <c>this</c>.
            </returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetBaseTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets the direct base types.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition})">
      <summary>
            Gets inner classes (including inherited inner classes).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IMethod})">
      <summary>
            Gets all methods that can be called on this return type.
            </summary>
      <remarks>The list does not include constructors.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetConstructors(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IMethod})">
      <summary>
            Gets all instance constructors for this type.
            </summary>
      <remarks>This list does not include constructors in base classes or static constructors.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetProperties(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IProperty})">
      <summary>
            Gets all properties that can be called on this return type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetFields(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IField})">
      <summary>
            Gets all fields that can be called on this return type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetEvents(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Predicate{ICSharpCode.NRefactory.TypeSystem.IEvent})">
      <summary>
            Gets all events that can be called on this return type.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.IsReferenceType">
      <summary>
            Gets whether the type is a reference type or value type.
            </summary>
      <returns>
            true, if the type is a reference type.
            false, if the type is a value type.
            null, if the type is not known (e.g. unconstrained generic type parameter or type not found)
            </returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.DeclaringType">
      <summary>
            Gets the parent type, if this is a nested type.
            Returns null for top-level types.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.TypeParameterCount">
      <summary>
            Gets the number of type parameters.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractType">
      <summary>
            Default implementation for IType interface.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter">
      <summary>
            Type parameter of a generic class/method.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.OwnerType">
      <summary>
            Get the type of this type parameter's owner.
            </summary>
      <returns>EntityType.TypeDefinition or EntityType.Method</returns>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Index">
      <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Attributes">
      <summary>
            Gets the list of attributes declared on this type parameter.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Constraints">
      <summary>
            Gets the contraints of this type parameter.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint">
      <summary>
            Gets if the type parameter has the 'new()' constraint.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasReferenceTypeConstraint">
      <summary>
            Gets if the type parameter has the 'class' constraint.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasValueTypeConstraint">
      <summary>
            Gets if the type parameter has the 'struct' constraint.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Variance">
      <summary>
            Gets the variance of this type parameter.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.BoundTo">
      <summary>
            Gets the type that was used to bind this type parameter.
            This property returns null for generic methods/classes, it
            is non-null only for constructed versions of generic methods.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.UnboundTypeParameter">
      <summary>
            If this type parameter was bound, returns the unbound version of it.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Region">
      <summary>
            Gets the region where the type parameter is defined.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UnknownMemberResolveResult">
      <summary>
            Represents an unknown member.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.CSharp.Resolver.UnknownMemberResolveResult.TargetType">
      <summary>
            The type on which the method is being called.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UnknownMethodResolveResult">
      <summary>
            Represents an unknown method.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UnknownIdentifierResolveResult">
      <summary>
            Represents an unknown identifier.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope">
      <summary>
            Represents a scope that contains "using" statements.
            This is either the file itself, or a namespace declaration.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope.#ctor(ICSharpCode.NRefactory.TypeSystem.IProjectContent)">
      <summary>
            Creates a new root using scope.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope.#ctor(ICSharpCode.NRefactory.CSharp.Resolver.UsingScope,System.String)">
      <summary>
            Creates a new nested using scope.
            </summary>
      <param name="parent">The parent using scope.</param>
      <param name="namespaceName">The full namespace name.</param>
    </member>
    <member name="M:ICSharpCode.NRefactory.CSharp.Resolver.UsingScope.HasAlias(System.String)">
      <summary>
            Gets whether this using scope has an alias (either using or extern)
            with the specified name.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IDocumentationProvider">
      <summary>
            Provides XML documentation for members.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
      <summary>
            Gets the XML documentation for the specified entity.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider">
      <summary>
            Provides documentation from an .xml file (as generated by the Microsoft C# compiler).
            </summary>
      <remarks>
            This class first creates an in-memory index of the .xml file, and then uses that to read only the requested members.
            This way, we avoid keeping all the documentation in memory.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.#ctor(System.String)">
      <summary>
            Creates a new XmlDocumentationProvider.
            </summary>
      <param name="fileName">Name of the .xml file.</param>
    </member>
    <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.SaveIndex(System.IO.BinaryWriter)">
      <summary>
            Saves the index into a binary file.
            Use <see cref="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LoadFromIndex(System.IO.BinaryReader)" /> to load the saved file.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LoadFromIndex(System.IO.BinaryReader)">
      <summary>
            Restores XmlDocumentationProvider from the index file (created by <see cref="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.SaveIndex(System.IO.BinaryWriter)" />).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(System.String)">
      <summary>
            Get the documentation for the member with the specified documentation key.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.AnyNode">
      <summary>
            Matches any node.
            </summary>
      <remarks>Does not match null nodes.</remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.Backreference">
      <summary>
            Matches the last entry in the specified named group.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.IdentifierExpressionBackreference">
      <summary>
            Matches identifier expressions that have the same identifier as the referenced variable/type definition/method definition.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.BacktrackingInfo">
      <summary>
            Container for the backtracking info.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.Choice">
      <summary>
            Matches one of several alternatives.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.PatternMatching.PatternExtensions.Match(ICSharpCode.NRefactory.PatternMatching.INode,ICSharpCode.NRefactory.PatternMatching.INode)">
      <summary>
            Performs a pattern matching operation.
            <c>this</c> is the pattern, <paramref name="other" /> is the AST that is being matched.
            </summary>
      <returns>
            A match object. Check <see cref="!:Match.Success" /> to see whether the match was successful.
            </returns>
      <remarks>
            Patterns are ASTs that contain special pattern nodes (from the PatternMatching namespace).
            However, it is also possible to match two ASTs without any pattern nodes -
            doing so will produce a successful match if the two ASTs are structurally identical.
            </remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.Match">
      <summary>
            Represents the result of a pattern matching operation.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.NamedNode">
      <summary>
            Represents a named node within a pattern.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.PatternMatching.Repeat">
      <summary>
            Represents an optional node.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Accessibility">
      <summary>
            Enum that describes the accessibility of an entity.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.None">
      <summary>
            The entity is completely inaccessible. This is used for C# explicit interface implementations.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Private">
      <summary>
            The entity is only accessible within the same class.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Public">
      <summary>
            The entity is accessible everywhere.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Protected">
      <summary>
            The entity is only accessible within the same class and in derived classes.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Internal">
      <summary>
            The entity is accessible within the same project content.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedOrInternal">
      <summary>
            The entity is accessible both everywhere in the project content, and in all derived classes.
            </summary>
      <remarks>This corresponds to C# 'protected internal'.</remarks>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedAndInternal">
      <summary>
            The entity is accessible in derived classes within the same project content.
            </summary>
      <remarks>C# does not support this accessibility.</remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ArrayType">
      <summary>
            Represents an array type.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning">
      <summary>
            Interface for TypeSystem objects that support interning.
            See <see cref="T:ICSharpCode.NRefactory.TypeSystem.IInterningProvider" /> for more information.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.PrepareForInterning(ICSharpCode.NRefactory.TypeSystem.IInterningProvider)">
      <summary>
            Interns child objects and strings.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.GetHashCodeForInterning">
      <summary>
            Gets a hash code for interning.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.EqualsForInterning(ICSharpCode.NRefactory.TypeSystem.ISupportsInterning)">
      <summary>
            Equality test for interning.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader">
      <summary>
            Allows loading an IProjectContent from an already compiled assembly.
            </summary>
      <remarks>Instance methods are not thread-safe; you need to create multiple instances of CecilLoader
            if you want to load multiple project contents in parallel.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadAssembly(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Loads the assembly definition into a project content.
            </summary>
      <returns>IProjectContent that represents the assembly</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadType(Mono.Cecil.TypeDefinition,ICSharpCode.NRefactory.TypeSystem.IProjectContent)">
      <summary>
            Loads a type from Cecil.
            </summary>
      <param name="typeDefinition">The Cecil TypeDefinition.</param>
      <param name="projectContent">The project content used as parent for the new type.</param>
      <returns>ITypeDefinition representing the Cecil type.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.ReadTypeReference(Mono.Cecil.TypeReference,Mono.Cecil.ICustomAttributeProvider,ICSharpCode.NRefactory.TypeSystem.IEntity)">
      <summary>
            Reads a type reference.
            </summary>
      <param name="type">The Cecil type reference that should be converted into
            a type system type reference.</param>
      <param name="typeAttributes">Attributes associated with the Cecil type reference.
            This is used to support the 'dynamic' type.</param>
      <param name="entity">The entity that owns this type reference.
            Used for generic type references.</param>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.EarlyBindContext">
      <summary>
            Gets/Sets the early bind context.
            This context is used to pre-resolve type references - setting this property will cause the CecilLoader
            to directly reference the resolved types, and create links (<see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference" />) to types
            that could not be resolved.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.IncludeInternalMembers">
      <summary>
            Specifies whether to include internal members. The default is false.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.DocumentationProvider">
      <summary>
            Gets/Sets the documentation provider that is used to retrieve the XML documentation for all members.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.InterningProvider">
      <summary>
            Gets/Sets the interning provider.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext">
      <summary>
            Proxy that forwards calls to another TypeResolveContext.
            Useful as base class for decorators.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Creates a new ProxyTypeResolveContext.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetClasses">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetClasses(System.String,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetNamespaces">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.GetNamespace(System.String,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.Synchronize">
      <inheritdoc />
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.ProxyTypeResolveContext.CacheManager">
      <inheritdoc />
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition">
      <summary>
            Represents a class, enum, interface, struct, delegate or VB module.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.GetCompoundClass">
      <summary>
            If this is a partial class, gets the compound class containing information from all parts.
            If this is not a partial class, a reference to this class is returned.
            
            This method will always retrieve the latest version of the class, which might not contain this class as a part.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.GetParts">
      <summary>
            If this is a compound class (combination of class parts), this method retrieves all individual class parts.
            Otherwise, a list containing <c>this</c> is returned.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.Members">
      <summary>
            Gets all members declared in this class. This is the union of Fields,Properties,Methods and Events.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.HasExtensionMethods">
      <summary>
            Gets whether this type contains extension methods.
            </summary>
      <remarks>This property is used to speed up the search for extension methods.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition.RemoveDuplicates``1(System.Collections.Generic.List{``0})">
      <summary>
            Removes duplicate members from the list.
            This is necessary when the same member can be inherited twice due to multiple inheritance.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeDefinition.AddDefaultConstructorIfRequired">
      <summary>
            Gets whether a default constructor should be added to this class if it is required.
            Such automatic default constructors will not appear in ITypeDefinition.Methods, but will be present
            in IType.GetMethods().
            </summary>
      <remarks>This way of creating the default constructor is necessary because
            we cannot create it directly in the IClass - we need to consider partial classes.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.DomRegion.IsInside(System.Int32,System.Int32)">
      <remarks>
            Returns true, if the given coordinates (line, column) are in the region.
            This method assumes that for an unknown end the end line is == -1
            </remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndLine">
      <value>
            if the end line is == -1 the end column is -1 too
            this stands for an unknwon end
            </value>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndColumn">
      <value>
            if the end column is == -1 the end line is -1 too
            this stands for an unknown end
            </value>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods">
      <summary>
            Contains extension methods for the type system.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllBaseTypes(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets all base types.
            </summary>
      <remarks>This is the reflexive and transitive closure of <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetBaseTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)" />.
            Note that this method does not return all supertypes - doing so is impossible due to contravariance
            (and undesirable for covariance as the list could become very large).
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllBaseTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets all base type definitions.
            </summary>
      <remarks>
            This is equivalent to type.GetAllBaseTypes().Select(t =&gt; t.GetDefinition()).Where(d =&gt; d != null).Distinct().
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsDerivedFrom(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets whether this type definition is derived from the base type defintiion.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsOpen(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets whether the type is an open type (contains type parameters).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsUnbound(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets whether the type is unbound.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsEnum(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets whether the type is an enumeration type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetEnumUnderlyingType(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets the underlying type for this enum type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsDelegate(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets whether the type is an delegate type.
            </summary>
      <remarks>This method returns <c>false</c> for System.Delegate itself</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetDelegateInvokeMethod(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets the invoke method for a delegate type.
            </summary>
      <remarks>
            Returns null if the type is not a delegate type; or if the invoke method could not be found.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.InternalsVisibleTo(ICSharpCode.NRefactory.TypeSystem.IProjectContent,ICSharpCode.NRefactory.TypeSystem.IProjectContent,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets whether the internals of this project are visible to the other project
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllClasses(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets all classes, including nested classes.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IAccessor">
      <summary>
            Represents an accessor (property getter/setter; or event add/remove/invoke).
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.Region">
      <summary>
            Gets the accessor region.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.Attributes">
      <summary>
            Gets the attributes defined on this accessor.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.ReturnTypeAttributes">
      <summary>
            Gets the attributes defined on the return type of the accessor. (e.g. [return: MarshalAs(...)])
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAccessor.Accessibility">
      <summary>
            Gets the accessibility of this accessor.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IAttribute">
      <summary>
            Represents an attribute.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IAttribute.ResolveConstructor(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Resolves the constructor method used for this attribute invocation.
            Returns null if the constructor cannot be found.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.Region">
      <summary>
            Gets the code region of this attribute.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.AttributeType">
      <summary>
            Gets the type of the attribute.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.PositionalArguments">
      <summary>
            Gets the positional arguments passed to the attribute.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.NamedArguments">
      <summary>
            Gets the named arguments passed to the attribute.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IConstantValue.GetValueType(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets the type of the constant value.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IConstantValue.GetValue(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Gets the .NET value of the constant value.
            Possible return values are:
            - null
            - primitive integers
            - float/double
            - bool
            - string
            - IType (for typeof-expressions)
            and arrays of these values. Enum values are returned using the underlying primitive integer.
            
            TODO: how do we represent errors (value not available?)
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IExplicitInterfaceImplementation">
      <summary>
            Represents an explicit interface implementation.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IExplicitInterfaceImplementation.InterfaceType">
      <summary>
            Gets the type of the interface.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IExplicitInterfaceImplementation.MemberName">
      <summary>
            Gets the member name.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IField">
      <summary>
            Represents a field or constant.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.Name">
      <summary>
            Gets the name of the field.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsReadOnly">
      <summary>
            Gets whether this field is readonly.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsVolatile">
      <summary>
            Gets whether this field is volatile.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IInterningProvider">
      <summary>
            Provider used for interning.
            </summary>
      <remarks>
            A simple IInterningProvider implementation could use 3 dictionaries:
             1. using value equality comparer (for certain types known to implement value equality, e.g. string and IType)
             2. using comparer that calls into ISupportsInterning (for types implementing ISupportsInterning)
             3. list comparer (for InternList method)
            
            On the first Intern()-call, the provider tells the object to prepare for interning (ISupportsInterning.PrepareForInterning)
            and stores it into a dictionary. On further Intern() calls, the original object is returned for all equal objects.
            This allows reducing the memory usage by using a single object instance where possible.
            
            Interning provider implementations could also use the interning logic for different purposes:
            for example, it could be used to determine which objects are used jointly between multiple type definitions
            and which are used only within a single type definition. Then a persistent file format could be organized so
            that shared objects are loaded only once, yet non-shared objects get loaded lazily together with the class.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.IInterningProvider.Intern``1(``0)">
      <summary>
            Interns the specified object.
            The object must implement <see cref="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning" />, or must be of one of the types
            known to the interning provider to use value equality,
            otherwise it will be returned without being interned.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IMethod">
      <summary>
            Represents a method, constructor, destructor or operator.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.ReturnTypeAttributes">
      <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractMember">
      <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMember" /> implementations.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractMember.#ctor(ICSharpCode.NRefactory.TypeSystem.IMember)">
      <summary>
            Copy constructor
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext">
      <summary>
            Represents multiple type resolve contexts.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.Combine(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Creates a <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext" /> that combines the given resolve contexts.
            If one of the input parameters is null, the other input parameter is returned directly.
            If both input parameters are null, the function returns null.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext})">
      <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext" /></summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetClasses">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetClasses(System.String,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetNamespaces">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.GetNamespace(System.String,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.CompositeTypeResolveContext.Synchronize">
      <inheritdoc />
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAccessor">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IAccessor" />.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAccessor.GetFromAccessibility(ICSharpCode.NRefactory.TypeSystem.Accessibility)">
      <summary>
            Gets the default accessor with the specified accessibility (and without attributes or region).
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAttribute">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IAttribute" />.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultEvent">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IEvent" />.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultEvent.#ctor(ICSharpCode.NRefactory.TypeSystem.IEvent)">
      <summary>
            Copy constructor
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultExplicitInterfaceImplementation">
      <summary>
            Default implementation for IExplicitInterfaceImplementation.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultField">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IField" />.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMethod">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod" /> interface.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMethod.#ctor(ICSharpCode.NRefactory.TypeSystem.IMethod)">
      <summary>
            Copy constructor
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.Attributes">
      <summary>
            Gets the list of attributes.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.DefaultValue">
      <summary>
            Gets the default value of optional parameters.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.Region">
      <summary>
            Gets the code region where the parameter is defined.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsRef">
      <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOut">
      <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsParams">
      <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOptional">
      <summary>
            Gets whether this parameter is optional.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter">
      <summary>
            Default implementation for IParameter.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter.#ctor(ICSharpCode.NRefactory.TypeSystem.IParameter)">
      <summary>
            Copy constructor
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IProperty">
      <summary>
            Represents a property or indexer.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultProperty">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IProperty" />.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultTypeParameter">
      <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter" />.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference">
      <summary>
            Type Reference used when the fully qualified type name is known.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference">
      <summary>
            Type reference used to reference nested types.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,System.Int32)">
      <summary>
            Creates a new NestedTypeReference.
            </summary>
      <param name="declaringTypeRef">Reference to the declaring type.</param>
      <param name="name">Name of the nested class</param>
      <param name="additionalTypeParameterCount">Number of type parameters on the inner class (without type parameters on baseTypeRef)</param>
      <remarks>
        <paramref name="declaringTypeRef" /> must be exactly the (unbound) declaring type, not a derived type, not a parameterized type.
            NestedTypeReference thus always resolves to a type definition, never to (partially) parameterized types.
            </remarks>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleConstantValue">
      <summary>
            A simple constant value that is independent of the resolve context.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleInterningProvider">
      <summary>
            Simple interning provider.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleProjectContent">
      <summary>
            Simple <see cref="T:ICSharpCode.NRefactory.TypeSystem.IProjectContent" /> implementation that stores the list of classes/namespaces.
            Synchronization is implemented using a <see cref="T:System.Threading.ReaderWriterLockSlim" />.
            </summary>
      <remarks>
            Compared with <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage" />, this class adds support for the IProjectContent interface,
            for partial classes, and for multi-threading.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleProjectContent.UpdateProjectContent(System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.IAttribute},System.Collections.Generic.ICollection{ICSharpCode.NRefactory.TypeSystem.IAttribute})">
      <summary>
            Removes oldTypes from the project, adds newTypes.
            Removes oldAssemblyAttributes, adds newAssemblyAttributes.
            </summary>
      <remarks>
            The update is done inside a write lock; when other threads access this project content
            from within a <c>using (Synchronize())</c> block, they will not see intermediate (inconsistent) state.
            </remarks>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleProjectContent.AssemblyAttributes">
      <inheritdoc />
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent">
      <summary>
            Represents a specialized IEvent (e.g. after type substitution).
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField">
      <summary>
            Represents a specialized IField (e.g. after type substitution).
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod">
      <summary>
            Represents a specialized IMethod (e.g. after type substitution).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod.SubstituteTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
      <summary>
            Performs type substitution in parameter types and in the return type.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty">
      <summary>
            Represents a specialized IProperty (e.g. after type substitution).
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty.SubstituteTypes(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
      <summary>
            Performs type substitution in parameter types and in the return type.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage">
      <summary>
            Stores a set of types and allows resolving them.
            </summary>
      <remarks>
            Concurrent read accesses are thread-safe, but a write access concurrent to any other access is not safe.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetClass(System.String,System.String,System.Int32,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetClasses">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetClasses(System.String,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetNamespaces">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.GetNamespace(System.String,System.StringComparer)">
      <inheritdoc />
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.Synchronize">
      <summary>
            TypeStorage is mutable and does not provide any means for synchronization, so this method
            always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.RemoveType(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
      <summary>
            Removes a type definition from this project content.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.UpdateType(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
      <summary>
            Adds the type definition to this project content.
            Replaces existing type definitions with the same name.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeStorage.CacheManager">
      <inheritdoc />
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.VoidTypeDefinition">
      <summary>
            Special type definition for 'void'.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType">
      <summary>
            Represents the intersection of several types.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.VarianceModifier">
      <summary>
            Represents the variance of a type parameter.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Invariant">
      <summary>
            The type parameter is not variant.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Covariant">
      <summary>
            The type parameter is covariant (used in output position).
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Contravariant">
      <summary>
            The type parameter is contravariant (used in input position).
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference">
      <summary>
            Contains well-known type references.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Void">
      <summary>
            Gets a type reference pointing to the <c>void</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Object">
      <summary>
            Gets a type reference pointing to the <c>object</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Boolean">
      <summary>
            Gets a type reference pointing to the <c>bool</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.SByte">
      <summary>
            Gets a type reference pointing to the <c>sbyte</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Byte">
      <summary>
            Gets a type reference pointing to the <c>byte</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int16">
      <summary>
            Gets a type reference pointing to the <c>short</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt16">
      <summary>
            Gets a type reference pointing to the <c>ushort</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int32">
      <summary>
            Gets a type reference pointing to the <c>int</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt32">
      <summary>
            Gets a type reference pointing to the <c>uint</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int64">
      <summary>
            Gets a type reference pointing to the <c>long</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt64">
      <summary>
            Gets a type reference pointing to the <c>ulong</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.String">
      <summary>
            Gets a type reference pointing to the <c>string</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Char">
      <summary>
            Gets a type reference pointing to the <c>char</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Single">
      <summary>
            Gets a type reference pointing to the <c>float</c> type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Double">
      <summary>
            Gets a type reference pointing to the <c>double</c> type.
            </summary>
    </member>
    <member name="P:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.AllKnownTypeReferences">
      <summary>
            Gets all known type references.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.NullableType">
      <summary>
            Static helper methods for working with nullable types.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.IsNullable(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets whether the specified type is a nullable type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.GetUnderlyingType(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Returns the element type, if <paramref name="type" /> is a nullable type.
            Otherwise, returns the type itself.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
      <summary>
            Creates a nullable type.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.ITypeReference)">
      <summary>
            Creates a nullable type reference.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType">
      <summary>
            ParameterizedType represents an instance of a generic type.
            Example: List&lt;string&gt;
            </summary>
      <remarks>
            When getting the members, this type modifies the lists so that
            type parameters in the signatures of the members are replaced with
            the type arguments.
            </remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.IType[])">
      <summary>
            Fast internal version of the constructor. (no safety checks)
            Keeps the array that was passed and assumes it won't be modified.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.SubstituteInType(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Substitutes the class type parameters in the <paramref name="type" /> with the
            type arguments of this parameterized type.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedTypeReference">
      <summary>
            ParameterizedTypeReference is a reference to generic class that specifies the type parameters.
            Example: List&lt;string&gt;
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper">
      <summary>
            Static helper methods for reflection names.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Null">
      <summary>
            A reflection class used to represent <c>null</c>.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Dynamic">
      <summary>
            A reflection class used to represent <c>dynamic</c>.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.GetClass(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext,System.Type)">
      <summary>
            Retrieves a class.
            </summary>
      <returns>Returns the class; or null if it is not found.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.Type,ICSharpCode.NRefactory.TypeSystem.IEntity)">
      <summary>
            Creates a reference to the specified type.
            </summary>
      <param name="type">The type to be converted.</param>
      <param name="entity">The parent entity, used to fetch the ITypeParameter for generic types.</param>
      <returns>Returns the type reference.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String)">
      <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
      <remarks>Do not use this method with the full name of inner classes.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String,System.Int32@)">
      <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
      <remarks>Do not use this method with the full name of inner classes.</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.TypeCode)">
      <summary>
            Creates a reference to the specified type.
            </summary>
      <param name="typeCode">The type to be converted.</param>
      <returns>Returns the type reference.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.GetTypeCode(ICSharpCode.NRefactory.TypeSystem.IType)">
      <summary>
            Gets the type code for the specified type, or TypeCode.Empty if none of the other type codes matches.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String,ICSharpCode.NRefactory.TypeSystem.IEntity)">
      <summary>
            Parses a reflection name into a type reference.
            </summary>
      <param name="reflectionTypeName">The reflection name of the type.</param>
      <param name="parentEntity">Parent entity, used to find the type parameters for open types.
            If no entity is provided, type parameters are converted to <see cref="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.UnknownType" />.</param>
      <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the reflection type name is invalid</exception>
      <returns>A type reference that represents the reflection name.</returns>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">
      <summary>
            Represents an error while parsing a reflection name.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes">
      <summary>
            Contains static implementations of well-known types.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes.UnknownTypeImpl">
      <summary>
            Type representing resolve errors.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes.NullType">
      <summary>
            Type of the 'null' literal.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.TypeSystem.SharedTypes.DynamicType">
      <summary>
            Type representing the C# 'dynamic' type.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.UnknownType">
      <summary>
            Gets the type representing resolve errors.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.Null">
      <summary>
            The null type is used as type of the null literal. It is a reference type without any members; and it is a subtype of all reference types.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.TypeSystem.SharedTypes.Dynamic">
      <summary>
            Type representing the C# 'dynamic' type.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.BitVector16">
      <summary>
            Holds 16 boolean values.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.BusyManager">
      <summary>
            This class is used to prevent stack overflows by representing a 'busy' flag
            that prevents reentrance when another call is running.
            However, using a simple 'bool busy' is not thread-safe, so we use a
            thread-static BusyManager.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.CacheManager">
      <summary>
            Allows the registration of static "caching types" which can then be used to efficiently retrieve an
            instance per CacheManager (or even per CacheManager and thread).
            </summary>
      <remarks>This class is thread-safe</remarks>
    </member>
    <member name="M:ICSharpCode.NRefactory.Utils.CacheManager.Dispose">
      <summary>
            Invokes the <see cref="E:ICSharpCode.NRefactory.Utils.CacheManager.Disposed" /> event.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast">
      <summary>
            Static helper method for converting between primitive types.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast.Cast(System.TypeCode,System.Object,System.Boolean)">
      <summary>
            Performs a conversion between primitive types.
            Unfortunately we cannot use Convert.ChangeType because it has different semantics
            (e.g. rounding behavior for floats, overflow, etc.), so we write down every possible primitive C# cast
            and let the compiler figure out the exact semantics.
            And we have to do everything twice, once in a checked-block, once in an unchecked-block.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.ExtensionMethods">
      <summary>
            Contains extension methods for use within NRefactory.
            </summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.GraphVizGraph">
      <summary>
            GraphViz graph.
            </summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.color">
      <summary>edge stroke color</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.constraint">
      <summary>use edge to affect node ranking</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.fontsize">
      <summary>point size of label</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.fontsize">
      <summary>point size of label</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.height">
      <summary>minimum height in inches</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.margin">
      <summary>space around label</summary>
    </member>
    <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.shape">
      <summary>node shape</summary>
    </member>
    <member name="T:ICSharpCode.NRefactory.Utils.TreeTraversal">
      <summary>
            Static helper methods for traversing trees.
            </summary>
    </member>
    <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
      <param name="root">The root element of the tree.</param>
      <param name="recursion">The function that gets the children of an element.</param>
      <returns>Iterator that enumerates the tree structure in pre-order.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
      <param name="input">The root elements of the forest.</param>
      <param name="recursion">The function that gets the children of an element.</param>
      <returns>Iterator that enumerates the tree structure in pre-order.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
      <param name="root">The root element of the tree.</param>
      <param name="recursion">The function that gets the children of an element.</param>
      <returns>Iterator that enumerates the tree structure in post-order.</returns>
    </member>
    <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
      <param name="input">The root elements of the forest.</param>
      <param name="recursion">The function that gets the children of an element.</param>
      <returns>Iterator that enumerates the tree structure in post-order.</returns>
    </member>
    <member name="T:ICSharpCode.ILSpy.CSharpLanguage">
      <summary>
            Decompiler logic for C#.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.DecompilationOptions">
      <summary>
            Options passed to the decompiler.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.DecompilationOptions.FullDecompilation">
      <summary>
            Gets whether a full decompilation (all members recursively) is desired.
            If this option is false, language bindings are allowed to show the only headers of the decompiled element's children.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.DecompilationOptions.SaveAsProjectDirectory">
      <summary>
            Gets/Sets the directory into which the project is saved.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.DecompilationOptions.CancellationToken">
      <summary>
            Gets the cancellation token that is used to abort the decompiler.
            </summary>
      <remarks>
            Decompilers should regularly call <c>options.CancellationToken.ThrowIfCancellationRequested();</c>
            to allow for cooperative cancellation of the decompilation task.
            </remarks>
    </member>
    <member name="P:ICSharpCode.ILSpy.DecompilationOptions.DecompilerSettings">
      <summary>
            Gets the settings for the decompiler.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.ExtensionMethods">
      <summary>
            ExtensionMethods used in ILSpy.
            </summary>
    </member>
    <member name="M:ICSharpCode.ILSpy.ExtensionMethods.SetValueToExtension(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Markup.MarkupExtension)">
      <summary>
            Sets the value of a dependency property on <paramref name="targetObject" /> using a markup extension.
            </summary>
      <remarks>This method does not support markup extensions like x:Static that depend on
            having a XAML file as context.</remarks>
    </member>
    <member name="T:ICSharpCode.ILSpy.FilterSettings">
      <summary>
            Represents the filters applied to the tree view.
            </summary>
      <remarks>
            This class is mutable; but the ILSpyTreeNode filtering assumes that filter settings are immutable.
            Thus, the main window will use one mutable instance (for data-binding), and will assign a new
            clone to the ILSpyTreeNodes whenever the main mutable instance changes.
            </remarks>
    </member>
    <member name="M:ICSharpCode.ILSpy.FilterSettings.SearchTermMatches(System.String)">
      <summary>
            Gets whether a node with the specified text is matched by the current search term.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.FilterSettings.SearchTerm">
      <summary>
            Gets/Sets the search term.
            Only tree nodes containing the search term will be shown.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.FilterSettings.ShowInternalApi">
      <summary>
            Gets/Sets whether internal API members should be shown.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.FilterSettings.Language">
      <summary>
            Gets/Sets the current language.
            </summary>
      <remarks>
            While this isn't related to filtering, having it as part of the FilterSettings
            makes it easy to pass it down into all tree nodes.
            </remarks>
    </member>
    <member name="T:ICSharpCode.ILSpy.GacInterop">
      <summary>
            Interop with the .NET GAC.
            </summary>
    </member>
    <member name="M:ICSharpCode.ILSpy.GacInterop.GetGacAssemblyFullNames">
      <summary>
            Gets the names of all assemblies in the GAC.
            </summary>
    </member>
    <member name="M:ICSharpCode.ILSpy.GacInterop.FindAssemblyInNetGac(Mono.Cecil.AssemblyNameReference)">
      <summary>
            Gets the file name for an assembly stored in the GAC.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.ILLanguage">
      <summary>
            IL language support.
            </summary>
      <remarks>
            Currently comes in two versions:
            flat IL (detectControlStructure=false) and structured IL (detectControlStructure=true).
            </remarks>
    </member>
    <member name="M:ICSharpCode.ILSpy.Languages.GetLanguage(System.String)">
      <summary>
            Gets a language using its name.
            If the language is not found, C# is returned instead.
            </summary>
    </member>
    <member name="P:ICSharpCode.ILSpy.Languages.AllLanguages">
      <summary>
            A list of all languages.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.XmlDoc.AddXmlDocTransform">
      <summary>
            Adds XML documentation for member definitions.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.XmlDoc.XmlDocKeyProvider">
      <summary>
            Provides XML documentation tags.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.XmlDoc.XmlDocLoader">
      <summary>
            Helps finding and loading .xml documentation.
            </summary>
    </member>
    <member name="T:ICSharpCode.ILSpy.XmlDoc.XmlDocRenderer">
      <summary>
            Renders XML documentation into a WPF <see cref="T:System.Windows.Controls.TextBlock" />.
            </summary>
    </member>
  </members>
</doc>