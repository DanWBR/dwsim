#region Translated by Jose Antonio De Santiago-Castillo.

//Translated by Jose Antonio De Santiago-Castillo.
//E-mail:JAntonioDeSantiago@gmail.com
//Website: www.DotNumerics.com
//
//Fortran to C# Translation.
//Translated by:
//F2CSharp Version 0.72 (Dicember 7, 2009)
//Code Optimizations: , assignment operator, for-loop: array indexes
//
#endregion

using System;
using DotNumerics.FortranLibrary;

namespace DotNumerics.Optimization.LBFGSB
{
    // c================    L-BFGS-B (version 2.1)   ==========================
    public class SETULB
    {
    

        #region Dependencies
        
        MAINLB _mainlb; 

        #endregion

        public SETULB(MAINLB mainlb)
        {
    

            #region Set Dependencies
            
            this._mainlb = mainlb; 

            #endregion

        }
    
        public SETULB()
        {
    

            #region Dependencies (Initialization)
            
            HPSOLB hpsolb = new HPSOLB();
            DDOT ddot = new DDOT();
            DAXPY daxpy = new DAXPY();
            DSCAL dscal = new DSCAL();
            DCOPY dcopy = new DCOPY();
            DCSTEP dcstep = new DCSTEP();
            ERRCLB errclb = new ERRCLB();
            PRN1LB prn1lb = new PRN1LB();
            PRN2LB prn2lb = new PRN2LB();
            PRN3LB prn3lb = new PRN3LB();
            ACTIVE active = new ACTIVE();
            PROJGR projgr = new PROJGR();
            FREEV freev = new FREEV();
            TIMER timer = new TIMER();
            DPMEPS dpmeps = new DPMEPS();
            DTRSL dtrsl = new DTRSL(ddot, daxpy);
            BMV bmv = new BMV(dtrsl);
            CAUCHY cauchy = new CAUCHY(hpsolb, bmv, dscal, dcopy, daxpy, ddot);
            SUBSM subsm = new SUBSM(dtrsl);
            DCSRCH dcsrch = new DCSRCH(dcstep);
            LNSRLB lnsrlb = new LNSRLB(dtrsl, ddot, dcsrch, dcopy);
            DPOFA dpofa = new DPOFA(ddot);
            FORMK formk = new FORMK(dcopy, dpofa, dtrsl, ddot);
            CMPRLB cmprlb = new CMPRLB(bmv);
            MATUPD matupd = new MATUPD(dcopy, ddot);
            FORMT formt = new FORMT(dpofa);
            MAINLB mainlb = new MAINLB(cauchy, subsm, lnsrlb, formk, errclb, prn1lb, prn2lb, prn3lb, active, projgr
                                       , freev, cmprlb, matupd, formt, timer, dpmeps, dcopy, ddot, dscal);

            #endregion


            #region Set Dependencies
            
            this._mainlb = mainlb; 

            #endregion

        }
        /// <param name="N">
        /// is an integer variable.
        /// On entry n is the dimension of the problem.
        /// On exit n is unchanged.
        ///</param>
        /// <param name="M">
        /// is an integer variable.
        /// On entry m is the maximum number of variable metric corrections
        /// used to define the limited memory matrix.
        /// On exit m is unchanged.
        ///</param>
        /// <param name="X">
        /// is a double precision array of dimension n.
        /// On entry x is an approximation to the solution.
        /// On exit x is the current approximation.
        ///</param>
        /// <param name="L">
        /// is a double precision array of dimension n.
        /// On entry l is the lower bound on x.
        /// On exit l is unchanged.
        ///</param>
        /// <param name="U">
        /// is a double precision array of dimension n.
        /// On entry u is the upper bound on x.
        /// On exit u is unchanged.
        ///</param>
        /// <param name="NBD">
        /// is an integer array of dimension n.
        /// On entry nbd represents the type of bounds imposed on the
        /// variables, and must be specified as follows:
        /// nbd(i)=0 if x(i) is unbounded,
        /// 1 if x(i) has only a lower bound,
        /// 2 if x(i) has both lower and upper bounds, and
        /// 3 if x(i) has only an upper bound.
        /// On exit nbd is unchanged.
        ///</param>
        /// <param name="F">
        /// is a double precision variable.
        /// On first entry f is unspecified.
        /// On final exit f is the value of the function at x.
        ///</param>
        /// <param name="G">
        /// is a double precision array of dimension n.
        /// On first entry g is unspecified.
        /// On final exit g is the value of the gradient at x.
        ///</param>
        /// <param name="FACTR">
        /// is a double precision variable.
        /// On entry factr .GE. 0 is specified by the user.  The iteration
        /// will stop when
        /// 
        /// (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} .LE. factr*epsmch
        /// 
        /// where epsmch is the machine precision, which is automatically
        /// generated by the code. Typical values for factr: 1.d+12 for
        /// low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
        /// high accuracy.
        /// On exit factr is unchanged.
        ///</param>
        /// <param name="PGTOL">
        /// is a double precision variable.
        /// On entry pgtol .GE. 0 is specified by the user.  The iteration
        /// will stop when
        /// 
        /// max{|proj g_i | i = 1, ..., n} .LE. pgtol
        /// 
        /// where pg_i is the ith component of the projected gradient.   
        /// On exit pgtol is unchanged.
        ///</param>
        /// <param name="WA">
        /// is a double precision working array of length 
        /// (2mmax + 4)nmax + 12mmax^2 + 12mmax.
        ///</param>
        /// <param name="IWA">
        /// is an integer working array of length 3nmax.
        ///</param>
        /// <param name="TASK">
        /// is a working string of characters of length 60 indicating
        /// the current job when entering and quitting this subroutine.
        ///</param>
        /// <param name="IPRINT">
        /// is an integer variable that must be set by the user.
        /// It controls the frequency and type of output generated:
        /// iprint.LT.0    no output is generated;
        /// iprint=0    print only one line at the last iteration;
        /// 0.LT.iprint.LT.99 print also f and |proj g| every iprint iterations;
        /// iprint=99   print details of every iteration except n-vectors;
        /// iprint=100  print also the changes of active set and final x;
        /// iprint.GT.100  print details of every iteration including x and g;
        /// When iprint .GT. 0, the file iterate.dat will be created to
        /// summarize the iteration.
        ///</param>
        /// <param name="CSAVE">
        /// is a working string of characters of length 60.
        ///</param>
        /// <param name="LSAVE">
        /// is a logical working array of dimension 4.
        /// On exit with 'task' = NEW_X, the following information is 
        /// available:
        /// If lsave(1) = .true.  then  the initial X has been replaced by
        /// its projection in the feasible set;
        /// If lsave(2) = .true.  then  the problem is constrained;
        /// If lsave(3) = .true.  then  each variable has upper and lower
        /// bounds;
        ///</param>
        /// <param name="ISAVE">
        /// is an integer working array of dimension 44.
        /// On exit with 'task' = NEW_X, the following information is 
        /// available:
        /// isave(22) = the total number of intervals explored in the 
        /// search of Cauchy points;
        /// isave(26) = the total number of skipped BFGS updates before 
        /// the current iteration;
        /// isave(30) = the number of current iteration;
        /// isave(31) = the total number of BFGS updates prior the current
        /// iteration;
        /// isave(33) = the number of intervals explored in the search of
        /// Cauchy point in the current iteration;
        /// isave(34) = the total number of function and gradient 
        /// evaluations;
        /// isave(36) = the number of function value or gradient
        /// evaluations in the current iteration;
        /// if isave(37) = 0  then the subspace argmin is within the box;
        /// if isave(37) = 1  then the subspace argmin is beyond the box;
        /// isave(38) = the number of free variables in the current
        /// iteration;
        /// isave(39) = the number of active constraints in the current
        /// iteration;
        /// n + 1 - isave(40) = the number of variables leaving the set of
        /// active constraints in the current iteration;
        /// isave(41) = the number of variables entering the set of active
        /// constraints in the current iteration.
        ///</param>
        /// <param name="DSAVE">
        /// is a double precision working array of dimension 29.
        /// On exit with 'task' = NEW_X, the following information is
        /// available:
        /// dsave(1) = current 'theta' in the BFGS matrix;
        /// dsave(2) = f(x) in the previous iteration;
        /// dsave(3) = factr*epsmch;
        /// dsave(4) = 2-norm of the line search direction vector;
        /// dsave(5) = the machine precision epsmch generated by the code;
        /// dsave(7) = the accumulated time spent on searching for
        /// Cauchy points;
        /// dsave(8) = the accumulated time spent on
        /// subspace minimization;
        /// dsave(9) = the accumulated time spent on line search;
        /// dsave(11) = the slope of the line search function at
        /// the current point of line search;
        /// dsave(12) = the maximum relative step length imposed in
        /// line search;
        /// dsave(13) = the infinity norm of the projected gradient;
        /// dsave(14) = the relative step length in the line search;
        /// dsave(15) = the slope of the line search function at
        /// the starting point of the line search;
        /// dsave(16) = the square of the 2-norm of the line search
        /// direction vector.
        ///</param>
        public void Run(int N, int M, ref double[] X, int offset_x, double[] L, int offset_l, double[] U, int offset_u, int[] NBD, int offset_nbd
                         , ref double F, ref double[] G, int offset_g, double FACTR, double PGTOL, ref double[] WA, int offset_wa, ref int[] IWA, int offset_iwa
                         , ref BFGSTask TASK, int IPRINT, ref BFGSTask CSAVE, ref bool[] LSAVE, int offset_lsave, ref int[] ISAVE, int offset_isave, ref double[] DSAVE, int offset_dsave)
        {

            #region Variables
            
            int L1 = 0; int L2 = 0; int L3 = 0; int LWS = 0; int LR = 0; int LZ = 0; int LT = 0; int LD = 0; int LSG = 0; 
            int LWA = 0;int LYG = 0; int LSGO = 0; int LWY = 0; int LSY = 0; int LSS = 0; int LYY = 0; int LWT = 0; int LWN = 0; 
            int LSND = 0;int LYGO = 0; 

            #endregion


            #region Array Index Correction
            
             int o_x = -1 + offset_x;  int o_l = -1 + offset_l;  int o_u = -1 + offset_u;  int o_nbd = -1 + offset_nbd; 
             int o_g = -1 + offset_g; int o_wa = -1 + offset_wa;  int o_iwa = -1 + offset_iwa;  int o_lsave = -1 + offset_lsave; 
             int o_isave = -1 + offset_isave; int o_dsave = -1 + offset_dsave; 

            #endregion


            #region Prolog
            
            
            
            // c     ************
            // c
            // c     Subroutine setulb
            // c
            // c     This subroutine partitions the working arrays wa and iwa, and 
            // c       then uses the limited memory BFGS method to solve the bound
            // c       constrained optimization problem by calling mainlb.
            // c       (The direct method will be used in the subspace minimization.)
            // c
            // c     n is an integer variable.
            // c       On entry n is the dimension of the problem.
            // c       On exit n is unchanged.
            // c
            // c     m is an integer variable.
            // c       On entry m is the maximum number of variable metric corrections
            // c         used to define the limited memory matrix.
            // c       On exit m is unchanged.
            // c
            // c     x is a double precision array of dimension n.
            // c       On entry x is an approximation to the solution.
            // c       On exit x is the current approximation.
            // c
            // c     l is a double precision array of dimension n.
            // c       On entry l is the lower bound on x.
            // c       On exit l is unchanged.
            // c
            // c     u is a double precision array of dimension n.
            // c       On entry u is the upper bound on x.
            // c       On exit u is unchanged.
            // c
            // c     nbd is an integer array of dimension n.
            // c       On entry nbd represents the type of bounds imposed on the
            // c         variables, and must be specified as follows:
            // c         nbd(i)=0 if x(i) is unbounded,
            // c                1 if x(i) has only a lower bound,
            // c                2 if x(i) has both lower and upper bounds, and
            // c                3 if x(i) has only an upper bound.
            // c       On exit nbd is unchanged.
            // c
            // c     f is a double precision variable.
            // c       On first entry f is unspecified.
            // c       On final exit f is the value of the function at x.
            // c
            // c     g is a double precision array of dimension n.
            // c       On first entry g is unspecified.
            // c       On final exit g is the value of the gradient at x.
            // c
            // c     factr is a double precision variable.
            // c       On entry factr >= 0 is specified by the user.  The iteration
            // c         will stop when
            // c
            // c         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
            // c
            // c         where epsmch is the machine precision, which is automatically
            // c         generated by the code. Typical values for factr: 1.d+12 for
            // c         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
            // c         high accuracy.
            // c       On exit factr is unchanged.
            // c
            // c     pgtol is a double precision variable.
            // c       On entry pgtol >= 0 is specified by the user.  The iteration
            // c         will stop when
            // c
            // c                 max{|proj g_i | i = 1, ..., n} <= pgtol
            // c
            // c         where pg_i is the ith component of the projected gradient.   
            // c       On exit pgtol is unchanged.
            // c
            // c     wa is a double precision working array of length 
            // c       (2mmax + 4)nmax + 12mmax^2 + 12mmax.
            // c
            // c     iwa is an integer working array of length 3nmax.
            // c
            // c     task is a working string of characters of length 60 indicating
            // c       the current job when entering and quitting this subroutine.
            // c
            // c     iprint is an integer variable that must be set by the user.
            // c       It controls the frequency and type of output generated:
            // c        iprint<0    no output is generated;
            // c        iprint=0    print only one line at the last iteration;
            // c        0<iprint<99 print also f and |proj g| every iprint iterations;
            // c        iprint=99   print details of every iteration except n-vectors;
            // c        iprint=100  print also the changes of active set and final x;
            // c        iprint>100  print details of every iteration including x and g;
            // c       When iprint > 0, the file iterate.dat will be created to
            // c                        summarize the iteration.
            // c
            // c     csave is a working string of characters of length 60.
            // c
            // c     lsave is a logical working array of dimension 4.
            // c       On exit with 'task' = NEW_X, the following information is 
            // c                                                             available:
            // c         If lsave(1) = .true.  then  the initial X has been replaced by
            // c                                     its projection in the feasible set;
            // c         If lsave(2) = .true.  then  the problem is constrained;
            // c         If lsave(3) = .true.  then  each variable has upper and lower
            // c                                     bounds;
            // c
            // c     isave is an integer working array of dimension 44.
            // c       On exit with 'task' = NEW_X, the following information is 
            // c                                                             available:
            // c         isave(22) = the total number of intervals explored in the 
            // c                         search of Cauchy points;
            // c         isave(26) = the total number of skipped BFGS updates before 
            // c                         the current iteration;
            // c         isave(30) = the number of current iteration;
            // c         isave(31) = the total number of BFGS updates prior the current
            // c                         iteration;
            // c         isave(33) = the number of intervals explored in the search of
            // c                         Cauchy point in the current iteration;
            // c         isave(34) = the total number of function and gradient 
            // c                         evaluations;
            // c         isave(36) = the number of function value or gradient
            // c                                  evaluations in the current iteration;
            // c         if isave(37) = 0  then the subspace argmin is within the box;
            // c         if isave(37) = 1  then the subspace argmin is beyond the box;
            // c         isave(38) = the number of free variables in the current
            // c                         iteration;
            // c         isave(39) = the number of active constraints in the current
            // c                         iteration;
            // c         n + 1 - isave(40) = the number of variables leaving the set of
            // c                           active constraints in the current iteration;
            // c         isave(41) = the number of variables entering the set of active
            // c                         constraints in the current iteration.
            // c
            // c     dsave is a double precision working array of dimension 29.
            // c       On exit with 'task' = NEW_X, the following information is
            // c                                                             available:
            // c         dsave(1) = current 'theta' in the BFGS matrix;
            // c         dsave(2) = f(x) in the previous iteration;
            // c         dsave(3) = factr*epsmch;
            // c         dsave(4) = 2-norm of the line search direction vector;
            // c         dsave(5) = the machine precision epsmch generated by the code;
            // c         dsave(7) = the accumulated time spent on searching for
            // c                                                         Cauchy points;
            // c         dsave(8) = the accumulated time spent on
            // c                                                 subspace minimization;
            // c         dsave(9) = the accumulated time spent on line search;
            // c         dsave(11) = the slope of the line search function at
            // c                                  the current point of line search;
            // c         dsave(12) = the maximum relative step length imposed in
            // c                                                           line search;
            // c         dsave(13) = the infinity norm of the projected gradient;
            // c         dsave(14) = the relative step length in the line search;
            // c         dsave(15) = the slope of the line search function at
            // c                                 the starting point of the line search;
            // c         dsave(16) = the square of the 2-norm of the line search
            // c                                                      direction vector.
            // c
            // c     Subprograms called:
            // c
            // c       L-BFGS-B Library ... mainlb.    
            // c
            // c
            // c     References:
            // c
            // c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
            // c       memory algorithm for bound constrained optimization'',
            // c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
            // c
            // c       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
            // c       limited memory FORTRAN code for solving bound constrained
            // c       optimization problems'', Tech. Report, NAM-11, EECS Department,
            // c       Northwestern University, 1994.
            // c
            // c       (Postscript files of these papers are available via anonymous
            // c        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
            // c
            // c                           *  *  *
            // c
            // c     NEOS, November 1994. (Latest revision June 1996.)
            // c     Optimization Technology Center.
            // c     Argonne National Laboratory and Northwestern University.
            // c     Written by
            // c                        Ciyou Zhu
            // c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
            // c
            // c
            // c     ************
            
            
            
            

            #endregion


            #region Body

             if (TASK == BFGSTask.START)
            {
                ISAVE[1 + o_isave] = M * N;
                ISAVE[2 + o_isave] = (int)Math.Pow(M,2);
                ISAVE[3 + o_isave] = 4 * (int)Math.Pow(M,2);
                ISAVE[4 + o_isave] = 1;
                ISAVE[5 + o_isave] = ISAVE[4 + o_isave] + ISAVE[1 + o_isave];
                ISAVE[6 + o_isave] = ISAVE[5 + o_isave] + ISAVE[1 + o_isave];
                ISAVE[7 + o_isave] = ISAVE[6 + o_isave] + ISAVE[2 + o_isave];
                ISAVE[8 + o_isave] = ISAVE[7 + o_isave] + ISAVE[2 + o_isave];
                ISAVE[9 + o_isave] = ISAVE[8 + o_isave] + ISAVE[2 + o_isave];
                ISAVE[10 + o_isave] = ISAVE[9 + o_isave] + ISAVE[2 + o_isave];
                ISAVE[11 + o_isave] = ISAVE[10 + o_isave] + ISAVE[3 + o_isave];
                ISAVE[12 + o_isave] = ISAVE[11 + o_isave] + ISAVE[3 + o_isave];
                ISAVE[13 + o_isave] = ISAVE[12 + o_isave] + N;
                ISAVE[14 + o_isave] = ISAVE[13 + o_isave] + N;
                ISAVE[15 + o_isave] = ISAVE[14 + o_isave] + N;
                ISAVE[16 + o_isave] = ISAVE[15 + o_isave] + N;
                ISAVE[17 + o_isave] = ISAVE[16 + o_isave] + 8 * M;
                ISAVE[18 + o_isave] = ISAVE[17 + o_isave] + M;
                ISAVE[19 + o_isave] = ISAVE[18 + o_isave] + M;
                ISAVE[20 + o_isave] = ISAVE[19 + o_isave] + M;
            }
            L1 = ISAVE[1 + o_isave];
            L2 = ISAVE[2 + o_isave];
            L3 = ISAVE[3 + o_isave];
            LWS = ISAVE[4 + o_isave];
            LWY = ISAVE[5 + o_isave];
            LSY = ISAVE[6 + o_isave];
            LSS = ISAVE[7 + o_isave];
            LYY = ISAVE[8 + o_isave];
            LWT = ISAVE[9 + o_isave];
            LWN = ISAVE[10 + o_isave];
            LSND = ISAVE[11 + o_isave];
            LZ = ISAVE[12 + o_isave];
            LR = ISAVE[13 + o_isave];
            LD = ISAVE[14 + o_isave];
            LT = ISAVE[15 + o_isave];
            LWA = ISAVE[16 + o_isave];
            LSG = ISAVE[17 + o_isave];
            LSGO = ISAVE[18 + o_isave];
            LYG = ISAVE[19 + o_isave];
            LYGO = ISAVE[20 + o_isave];
            
            this._mainlb.Run(N, M, ref X, offset_x, L, offset_l, U, offset_u, NBD, offset_nbd
                             , ref F, ref G, offset_g, FACTR, PGTOL, ref WA, LWS + o_wa, ref WA, LWY + o_wa
                             , ref WA, LSY + o_wa, ref WA, LSS + o_wa, WA, LYY + o_wa, ref WA, LWT + o_wa, ref WA, LWN + o_wa, ref WA, LSND + o_wa
                             , ref WA, LZ + o_wa, ref WA, LR + o_wa, ref WA, LD + o_wa, ref WA, LT + o_wa, ref WA, LWA + o_wa, WA, LSG + o_wa
                             , WA, LSGO + o_wa, WA, LYG + o_wa, WA, LYGO + o_wa, ref IWA, 1 + o_iwa, ref IWA, N + 1 + o_iwa, ref IWA, 2 * N + 1 + o_iwa
                             , ref TASK, IPRINT, ref CSAVE, ref LSAVE, offset_lsave, ref ISAVE, 22 + o_isave, ref DSAVE, offset_dsave);
            
            return;
            

            #endregion

        }
    }
    
    // c======================= The end of setulb =============================
}
